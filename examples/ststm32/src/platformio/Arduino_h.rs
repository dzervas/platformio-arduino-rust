/* automatically generated by rust-bindgen */

#[repr(C)]
#[derive(Default)]
pub struct __IncompleteArrayField<T>(::core::marker::PhantomData<T>, [T; 0]);
impl<T> __IncompleteArrayField<T> {
    #[inline]
    pub const fn new() -> Self {
        __IncompleteArrayField(::core::marker::PhantomData, [])
    }
    #[inline]
    pub fn as_ptr(&self) -> *const T {
        self as *const _ as *const T
    }
    #[inline]
    pub fn as_mut_ptr(&mut self) -> *mut T {
        self as *mut _ as *mut T
    }
    #[inline]
    pub unsafe fn as_slice(&self, len: usize) -> &[T] {
        ::core::slice::from_raw_parts(self.as_ptr(), len)
    }
    #[inline]
    pub unsafe fn as_mut_slice(&mut self, len: usize) -> &mut [T] {
        ::core::slice::from_raw_parts_mut(self.as_mut_ptr(), len)
    }
}
impl<T> ::core::fmt::Debug for __IncompleteArrayField<T> {
    fn fmt(&self, fmt: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        fmt.write_str("__IncompleteArrayField")
    }
}
#[repr(C)]
pub struct __BindgenUnionField<T>(::core::marker::PhantomData<T>);
impl<T> __BindgenUnionField<T> {
    #[inline]
    pub const fn new() -> Self {
        __BindgenUnionField(::core::marker::PhantomData)
    }
    #[inline]
    pub unsafe fn as_ref(&self) -> &T {
        ::core::mem::transmute(self)
    }
    #[inline]
    pub unsafe fn as_mut(&mut self) -> &mut T {
        ::core::mem::transmute(self)
    }
}
impl<T> ::core::default::Default for __BindgenUnionField<T> {
    #[inline]
    fn default() -> Self {
        Self::new()
    }
}
impl<T> ::core::clone::Clone for __BindgenUnionField<T> {
    #[inline]
    fn clone(&self) -> Self {
        Self::new()
    }
}
impl<T> ::core::marker::Copy for __BindgenUnionField<T> {}
impl<T> ::core::fmt::Debug for __BindgenUnionField<T> {
    fn fmt(&self, fmt: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        fmt.write_str("__BindgenUnionField")
    }
}
impl<T> ::core::hash::Hash for __BindgenUnionField<T> {
    fn hash<H: ::core::hash::Hasher>(&self, _state: &mut H) {}
}
impl<T> ::core::cmp::PartialEq for __BindgenUnionField<T> {
    fn eq(&self, _other: &__BindgenUnionField<T>) -> bool {
        true
    }
}
impl<T> ::core::cmp::Eq for __BindgenUnionField<T> {}
pub const _GLIBCXX_STDLIB_H: u32 = 1;
pub const _GLIBCXX_CXX_CONFIG_H: u32 = 1;
pub const _GLIBCXX_RELEASE: u32 = 7;
pub const __GLIBCXX__: u32 = 20170904;
pub const _GLIBCXX_HAVE_ATTRIBUTE_VISIBILITY: u32 = 1;
pub const _GLIBCXX_USE_DEPRECATED: u32 = 1;
pub const _GLIBCXX_EXTERN_TEMPLATE: u32 = 1;
pub const _GLIBCXX_USE_DUAL_ABI: u32 = 1;
pub const _GLIBCXX_USE_CXX11_ABI: u32 = 1;
pub const _GLIBCXX_INLINE_VERSION: u32 = 0;
pub const _GLIBCXX_USE_ALLOCATOR_NEW: u32 = 1;
pub const _GLIBCXX_OS_DEFINES: u32 = 1;
pub const _GLIBCXX_CPU_DEFINES: u32 = 1;
pub const _GLIBCXX_FAST_MATH: u32 = 0;
pub const _GLIBCXX_HAVE_ACOSF: u32 = 1;
pub const _GLIBCXX_HAVE_ASINF: u32 = 1;
pub const _GLIBCXX_HAVE_AS_SYMVER_DIRECTIVE: u32 = 1;
pub const _GLIBCXX_HAVE_ATAN2F: u32 = 1;
pub const _GLIBCXX_HAVE_ATANF: u32 = 1;
pub const _GLIBCXX_HAVE_CEILF: u32 = 1;
pub const _GLIBCXX_HAVE_COMPLEX_H: u32 = 1;
pub const _GLIBCXX_HAVE_COSF: u32 = 1;
pub const _GLIBCXX_HAVE_COSHF: u32 = 1;
pub const _GLIBCXX_HAVE_EBADMSG: u32 = 1;
pub const _GLIBCXX_HAVE_ECANCELED: u32 = 1;
pub const _GLIBCXX_HAVE_ECHILD: u32 = 1;
pub const _GLIBCXX_HAVE_EIDRM: u32 = 1;
pub const _GLIBCXX_HAVE_ENODATA: u32 = 1;
pub const _GLIBCXX_HAVE_ENOLINK: u32 = 1;
pub const _GLIBCXX_HAVE_ENOSPC: u32 = 1;
pub const _GLIBCXX_HAVE_ENOSR: u32 = 1;
pub const _GLIBCXX_HAVE_ENOSTR: u32 = 1;
pub const _GLIBCXX_HAVE_ENOTRECOVERABLE: u32 = 1;
pub const _GLIBCXX_HAVE_ENOTSUP: u32 = 1;
pub const _GLIBCXX_HAVE_EOVERFLOW: u32 = 1;
pub const _GLIBCXX_HAVE_EOWNERDEAD: u32 = 1;
pub const _GLIBCXX_HAVE_EPERM: u32 = 1;
pub const _GLIBCXX_HAVE_EPROTO: u32 = 1;
pub const _GLIBCXX_HAVE_ETIME: u32 = 1;
pub const _GLIBCXX_HAVE_ETIMEDOUT: u32 = 1;
pub const _GLIBCXX_HAVE_ETXTBSY: u32 = 1;
pub const _GLIBCXX_HAVE_EWOULDBLOCK: u32 = 1;
pub const _GLIBCXX_HAVE_EXPF: u32 = 1;
pub const _GLIBCXX_HAVE_FABSF: u32 = 1;
pub const _GLIBCXX_HAVE_FCNTL_H: u32 = 1;
pub const _GLIBCXX_HAVE_FLOAT_H: u32 = 1;
pub const _GLIBCXX_HAVE_FLOORF: u32 = 1;
pub const _GLIBCXX_HAVE_FMODF: u32 = 1;
pub const _GLIBCXX_HAVE_FREXPF: u32 = 1;
pub const _GLIBCXX_HAVE_GETIPINFO: u32 = 1;
pub const _GLIBCXX_HAVE_GETS: u32 = 1;
pub const _GLIBCXX_HAVE_HYPOT: u32 = 1;
pub const _GLIBCXX_HAVE_ICONV: u32 = 1;
pub const _GLIBCXX_HAVE_IEEEFP_H: u32 = 1;
pub const _GLIBCXX_HAVE_INT64_T: u32 = 1;
pub const _GLIBCXX_HAVE_INT64_T_LONG_LONG: u32 = 1;
pub const _GLIBCXX_HAVE_INTTYPES_H: u32 = 1;
pub const _GLIBCXX_HAVE_ISWBLANK: u32 = 1;
pub const _GLIBCXX_HAVE_LC_MESSAGES: u32 = 1;
pub const _GLIBCXX_HAVE_LDEXPF: u32 = 1;
pub const _GLIBCXX_HAVE_LIMIT_AS: u32 = 0;
pub const _GLIBCXX_HAVE_LIMIT_DATA: u32 = 0;
pub const _GLIBCXX_HAVE_LIMIT_FSIZE: u32 = 0;
pub const _GLIBCXX_HAVE_LIMIT_RSS: u32 = 0;
pub const _GLIBCXX_HAVE_LIMIT_VMEM: u32 = 0;
pub const _GLIBCXX_HAVE_LOCALE_H: u32 = 1;
pub const _GLIBCXX_HAVE_LOG10F: u32 = 1;
pub const _GLIBCXX_HAVE_LOGF: u32 = 1;
pub const _GLIBCXX_HAVE_MACHINE_ENDIAN_H: u32 = 1;
pub const _GLIBCXX_HAVE_MACHINE_PARAM_H: u32 = 1;
pub const _GLIBCXX_HAVE_MBSTATE_T: u32 = 1;
pub const _GLIBCXX_HAVE_MEMALIGN: u32 = 1;
pub const _GLIBCXX_HAVE_MEMORY_H: u32 = 1;
pub const _GLIBCXX_HAVE_MODFF: u32 = 1;
pub const _GLIBCXX_HAVE_POWF: u32 = 1;
pub const _GLIBCXX_HAVE_SINF: u32 = 1;
pub const _GLIBCXX_HAVE_SINHF: u32 = 1;
pub const _GLIBCXX_HAVE_SLEEP: u32 = 1;
pub const _GLIBCXX_HAVE_SQRTF: u32 = 1;
pub const _GLIBCXX_HAVE_STDALIGN_H: u32 = 1;
pub const _GLIBCXX_HAVE_STDBOOL_H: u32 = 1;
pub const _GLIBCXX_HAVE_STDINT_H: u32 = 1;
pub const _GLIBCXX_HAVE_STDLIB_H: u32 = 1;
pub const _GLIBCXX_HAVE_STRERROR_R: u32 = 1;
pub const _GLIBCXX_HAVE_STRINGS_H: u32 = 1;
pub const _GLIBCXX_HAVE_STRING_H: u32 = 1;
pub const _GLIBCXX_HAVE_STRTOF: u32 = 1;
pub const _GLIBCXX_HAVE_SYS_PARAM_H: u32 = 1;
pub const _GLIBCXX_HAVE_SYS_RESOURCE_H: u32 = 1;
pub const _GLIBCXX_HAVE_SYS_STAT_H: u32 = 1;
pub const _GLIBCXX_HAVE_SYS_TIME_H: u32 = 1;
pub const _GLIBCXX_HAVE_SYS_TYPES_H: u32 = 1;
pub const _GLIBCXX_HAVE_S_ISREG: u32 = 1;
pub const _GLIBCXX_HAVE_TANF: u32 = 1;
pub const _GLIBCXX_HAVE_TANHF: u32 = 1;
pub const _GLIBCXX_HAVE_TGMATH_H: u32 = 1;
pub const _GLIBCXX_HAVE_UNISTD_H: u32 = 1;
pub const _GLIBCXX_HAVE_USLEEP: u32 = 1;
pub const _GLIBCXX_HAVE_UTIME_H: u32 = 1;
pub const _GLIBCXX_HAVE_VFWSCANF: u32 = 1;
pub const _GLIBCXX_HAVE_VSWSCANF: u32 = 1;
pub const _GLIBCXX_HAVE_VWSCANF: u32 = 1;
pub const _GLIBCXX_HAVE_WCHAR_H: u32 = 1;
pub const _GLIBCXX_HAVE_WCSTOF: u32 = 1;
pub const _GLIBCXX_HAVE_WCTYPE_H: u32 = 1;
pub const LT_OBJDIR: &'static [u8; 7usize] = b".libs/\0";
pub const _GLIBCXX_PACKAGE_BUGREPORT: &'static [u8; 1usize] = b"\0";
pub const _GLIBCXX_PACKAGE_NAME: &'static [u8; 15usize] = b"package-unused\0";
pub const _GLIBCXX_PACKAGE_STRING: &'static [u8; 30usize] = b"package-unused version-unused\0";
pub const _GLIBCXX_PACKAGE_TARNAME: &'static [u8; 10usize] = b"libstdc++\0";
pub const _GLIBCXX_PACKAGE_URL: &'static [u8; 1usize] = b"\0";
pub const _GLIBCXX_PACKAGE__GLIBCXX_VERSION: &'static [u8; 15usize] = b"version-unused\0";
pub const STDC_HEADERS: u32 = 1;
pub const _GLIBCXX11_USE_C99_MATH: u32 = 1;
pub const _GLIBCXX11_USE_C99_STDIO: u32 = 1;
pub const _GLIBCXX11_USE_C99_STDLIB: u32 = 1;
pub const _GLIBCXX11_USE_C99_WCHAR: u32 = 1;
pub const _GLIBCXX98_USE_C99_MATH: u32 = 1;
pub const _GLIBCXX98_USE_C99_STDIO: u32 = 1;
pub const _GLIBCXX98_USE_C99_STDLIB: u32 = 1;
pub const _GLIBCXX98_USE_C99_WCHAR: u32 = 1;
pub const _GLIBCXX_FULLY_DYNAMIC_STRING: u32 = 0;
pub const _GLIBCXX_HOSTED: u32 = 1;
pub const _GLIBCXX_PTRDIFF_T_IS_INT: u32 = 1;
pub const _GLIBCXX_SIZE_T_IS_UINT: u32 = 1;
pub const _GLIBCXX_STDIO_EOF: i32 = -1;
pub const _GLIBCXX_STDIO_SEEK_CUR: u32 = 1;
pub const _GLIBCXX_STDIO_SEEK_END: u32 = 2;
pub const _GLIBCXX_USE_C99_CTYPE_TR1: u32 = 1;
pub const _GLIBCXX_USE_C99_INTTYPES_TR1: u32 = 1;
pub const _GLIBCXX_USE_C99_INTTYPES_WCHAR_T_TR1: u32 = 1;
pub const _GLIBCXX_USE_C99_MATH_TR1: u32 = 1;
pub const _GLIBCXX_USE_C99_STDINT_TR1: u32 = 1;
pub const _GLIBCXX_USE_FCHMOD: u32 = 1;
pub const _GLIBCXX_USE_FCHMODAT: u32 = 1;
pub const _GLIBCXX_USE_GETTIMEOFDAY: u32 = 1;
pub const _GLIBCXX_USE_LONG_LONG: u32 = 1;
pub const _GLIBCXX_USE_SC_NPROCESSORS_ONLN: u32 = 1;
pub const _GLIBCXX_USE_TMPNAM: u32 = 1;
pub const _GLIBCXX_USE_WCHAR_T: u32 = 1;
pub const _GLIBCXX_VERBOSE: u32 = 1;
pub const _GTHREAD_USE_MUTEX_TIMEDLOCK: u32 = 1;
pub const _GLIBCXX_CSTDLIB: u32 = 1;
pub const __OBSOLETE_MATH_DEFAULT: u32 = 1;
pub const __OBSOLETE_MATH: u32 = 1;
pub const __NEWLIB_H__: u32 = 1;
pub const _NEWLIB_VERSION_H__: u32 = 1;
pub const _NEWLIB_VERSION: &'static [u8; 6usize] = b"2.5.0\0";
pub const __NEWLIB__: u32 = 2;
pub const __NEWLIB_MINOR__: u32 = 5;
pub const __NEWLIB_PATCHLEVEL__: u32 = 0;
pub const _WANT_IO_LONG_LONG: u32 = 1;
pub const _WANT_REGISTER_FINI: u32 = 1;
pub const _MB_LEN_MAX: u32 = 1;
pub const HAVE_INITFINI_ARRAY: u32 = 1;
pub const _ATEXIT_DYNAMIC_ALLOC: u32 = 1;
pub const _HAVE_LONG_DOUBLE: u32 = 1;
pub const _HAVE_CC_INHIBIT_LOOP_TO_LIBCALL: u32 = 1;
pub const _LDBL_EQ_DBL: u32 = 1;
pub const _FVWRITE_IN_STREAMIO: u32 = 1;
pub const _FSEEK_OPTIMIZATION: u32 = 1;
pub const _WIDE_ORIENT: u32 = 1;
pub const _UNBUF_STREAM_OPT: u32 = 1;
pub const _RETARGETABLE_LOCKING: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __ATFILE_VISIBLE: u32 = 1;
pub const __BSD_VISIBLE: u32 = 1;
pub const __GNU_VISIBLE: u32 = 0;
pub const __ISO_C_VISIBLE: u32 = 2011;
pub const __LARGEFILE_VISIBLE: u32 = 0;
pub const __MISC_VISIBLE: u32 = 1;
pub const __POSIX_VISIBLE: u32 = 200809;
pub const __SVID_VISIBLE: u32 = 1;
pub const __XSI_VISIBLE: u32 = 0;
pub const __RAND_MAX: u32 = 2147483647;
pub const __have_longlong64: u32 = 1;
pub const __have_long32: u32 = 1;
pub const ___int8_t_defined: u32 = 1;
pub const ___int16_t_defined: u32 = 1;
pub const ___int32_t_defined: u32 = 1;
pub const ___int64_t_defined: u32 = 1;
pub const ___int_least8_t_defined: u32 = 1;
pub const ___int_least16_t_defined: u32 = 1;
pub const ___int_least32_t_defined: u32 = 1;
pub const ___int_least64_t_defined: u32 = 1;
pub const _NULL: u32 = 0;
pub const _ATEXIT_SIZE: u32 = 32;
pub const _RAND48_SEED_0: u32 = 13070;
pub const _RAND48_SEED_1: u32 = 43981;
pub const _RAND48_SEED_2: u32 = 4660;
pub const _RAND48_MULT_0: u32 = 58989;
pub const _RAND48_MULT_1: u32 = 57068;
pub const _RAND48_MULT_2: u32 = 5;
pub const _RAND48_ADD: u32 = 11;
pub const _REENT_EMERGENCY_SIZE: u32 = 25;
pub const _REENT_ASCTIME_SIZE: u32 = 26;
pub const _REENT_SIGNAL_SIZE: u32 = 24;
pub const _N_LISTS: u32 = 30;
pub const __GNUCLIKE_ASM: u32 = 3;
pub const __GNUCLIKE___TYPEOF: u32 = 1;
pub const __GNUCLIKE___OFFSETOF: u32 = 1;
pub const __GNUCLIKE___SECTION: u32 = 1;
pub const __GNUCLIKE_CTOR_SECTION_HANDLING: u32 = 1;
pub const __GNUCLIKE_BUILTIN_CONSTANT_P: u32 = 1;
pub const __GNUCLIKE_BUILTIN_VARARGS: u32 = 1;
pub const __GNUCLIKE_BUILTIN_STDARG: u32 = 1;
pub const __GNUCLIKE_BUILTIN_VAALIST: u32 = 1;
pub const __GNUC_VA_LIST_COMPATIBILITY: u32 = 1;
pub const __GNUCLIKE_BUILTIN_NEXT_ARG: u32 = 1;
pub const __GNUCLIKE_BUILTIN_MEMCPY: u32 = 1;
pub const __CC_SUPPORTS_INLINE: u32 = 1;
pub const __CC_SUPPORTS___INLINE: u32 = 1;
pub const __CC_SUPPORTS___INLINE__: u32 = 1;
pub const __CC_SUPPORTS___FUNC__: u32 = 1;
pub const __CC_SUPPORTS_WARNING: u32 = 1;
pub const __CC_SUPPORTS_VARADIC_XXX: u32 = 1;
pub const __CC_SUPPORTS_DYNAMIC_ARRAY_INIT: u32 = 1;
pub const EXIT_FAILURE: u32 = 1;
pub const EXIT_SUCCESS: u32 = 0;
pub const RAND_MAX: u32 = 2147483647;
pub const __GNUC_VA_LIST: u32 = 1;
pub const __BIT_TYPES_DEFINED__: u32 = 1;
pub const __int8_t_defined: u32 = 1;
pub const __int16_t_defined: u32 = 1;
pub const __int32_t_defined: u32 = 1;
pub const __int64_t_defined: u32 = 1;
pub const _LITTLE_ENDIAN: u32 = 1234;
pub const _BIG_ENDIAN: u32 = 4321;
pub const _PDP_ENDIAN: u32 = 3412;
pub const _BYTE_ORDER: u32 = 1234;
pub const _QUAD_HIGHWORD: u32 = 1;
pub const _QUAD_LOWWORD: u32 = 0;
pub const LITTLE_ENDIAN: u32 = 1234;
pub const BIG_ENDIAN: u32 = 4321;
pub const PDP_ENDIAN: u32 = 3412;
pub const BYTE_ORDER: u32 = 1234;
pub const FD_SETSIZE: u32 = 64;
pub const SCHED_OTHER: u32 = 0;
pub const SCHED_FIFO: u32 = 1;
pub const SCHED_RR: u32 = 2;
pub const PTHREAD_SCOPE_PROCESS: u32 = 0;
pub const PTHREAD_SCOPE_SYSTEM: u32 = 1;
pub const PTHREAD_INHERIT_SCHED: u32 = 1;
pub const PTHREAD_EXPLICIT_SCHED: u32 = 2;
pub const PTHREAD_CREATE_DETACHED: u32 = 0;
pub const PTHREAD_CREATE_JOINABLE: u32 = 1;
pub const __SLBF: u32 = 1;
pub const __SNBF: u32 = 2;
pub const __SRD: u32 = 4;
pub const __SWR: u32 = 8;
pub const __SRW: u32 = 16;
pub const __SEOF: u32 = 32;
pub const __SERR: u32 = 64;
pub const __SMBF: u32 = 128;
pub const __SAPP: u32 = 256;
pub const __SSTR: u32 = 512;
pub const __SOPT: u32 = 1024;
pub const __SNPT: u32 = 2048;
pub const __SOFF: u32 = 4096;
pub const __SORD: u32 = 8192;
pub const __SL64: u32 = 32768;
pub const __SNLK: u32 = 1;
pub const __SWID: u32 = 8192;
pub const _IOFBF: u32 = 0;
pub const _IOLBF: u32 = 1;
pub const _IONBF: u32 = 2;
pub const EOF: i32 = -1;
pub const BUFSIZ: u32 = 1024;
pub const FOPEN_MAX: u32 = 20;
pub const FILENAME_MAX: u32 = 1024;
pub const L_tmpnam: u32 = 1024;
pub const P_tmpdir: &'static [u8; 5usize] = b"/tmp\0";
pub const SEEK_SET: u32 = 0;
pub const SEEK_CUR: u32 = 1;
pub const SEEK_END: u32 = 2;
pub const TMP_MAX: u32 = 26;
pub const L_ctermid: u32 = 16;
pub const _U: u32 = 1;
pub const _L: u32 = 2;
pub const _N: u32 = 4;
pub const _S: u32 = 8;
pub const _P: u32 = 16;
pub const _C: u32 = 32;
pub const _X: u32 = 64;
pub const _B: u32 = 128;
pub const __PGMSPACE_H_: u32 = 1;
pub const __int20: u32 = 2;
pub const __INT8: &'static [u8; 3usize] = b"hh\0";
pub const __INT16: &'static [u8; 2usize] = b"h\0";
pub const __INT64: &'static [u8; 3usize] = b"ll\0";
pub const __FAST8: &'static [u8; 3usize] = b"hh\0";
pub const __FAST16: &'static [u8; 2usize] = b"h\0";
pub const __FAST64: &'static [u8; 3usize] = b"ll\0";
pub const __LEAST8: &'static [u8; 3usize] = b"hh\0";
pub const __LEAST16: &'static [u8; 2usize] = b"h\0";
pub const __LEAST64: &'static [u8; 3usize] = b"ll\0";
pub const __int_least8_t_defined: u32 = 1;
pub const __int_least16_t_defined: u32 = 1;
pub const __int_least32_t_defined: u32 = 1;
pub const __int_least64_t_defined: u32 = 1;
pub const __int_fast8_t_defined: u32 = 1;
pub const __int_fast16_t_defined: u32 = 1;
pub const __int_fast32_t_defined: u32 = 1;
pub const __int_fast64_t_defined: u32 = 1;
pub const WINT_MIN: u32 = 0;
pub const STM32_SERIES_F1: u32 = 0;
pub const STM32_SERIES_F2: u32 = 1;
pub const STM32_SERIES_L1: u32 = 2;
pub const STM32_SERIES_F4: u32 = 3;
pub const STM32_MCU_SERIES: u32 = 0;
pub const STM32_F1_LINE_VALUE: u32 = 0;
pub const STM32_F1_LINE_ACCESS: u32 = 1;
pub const STM32_F1_LINE_USB_ACCESS: u32 = 2;
pub const STM32_F1_LINE_PERFORMANCE: u32 = 3;
pub const STM32_F1_LINE_CONNECTIVITY: u32 = 5;
pub const STM32_F1_LINE: u32 = 3;
pub const STM32_NR_GPIO_PORTS: u32 = 3;
pub const STM32_HAVE_USB: u32 = 1;
pub const STM32_NR_INTERRUPTS: u32 = 43;
pub const STM32_TIMER_MASK: u32 = 30;
pub const STM32_HAVE_FSMC: u32 = 0;
pub const STM32_HAVE_DAC: u32 = 0;
pub const NR_INTERRUPTS: u32 = 43;
pub const NR_GPIO_PORTS: u32 = 3;
pub const GPIO_CR_CNF: u32 = 12;
pub const GPIO_CR_CNF_INPUT_ANALOG: u32 = 0;
pub const GPIO_CR_CNF_INPUT_FLOATING: u32 = 4;
pub const GPIO_CR_CNF_INPUT_PU_PD: u32 = 8;
pub const GPIO_CR_CNF_OUTPUT_PP: u32 = 0;
pub const GPIO_CR_CNF_OUTPUT_OD: u32 = 4;
pub const GPIO_CR_CNF_AF_OUTPUT_PP: u32 = 8;
pub const GPIO_CR_CNF_AF_OUTPUT_OD: u32 = 12;
pub const GPIO_CR_MODE: u32 = 3;
pub const GPIO_CR_MODE_INPUT: u32 = 0;
pub const GPIO_CR_MODE_OUTPUT_10MHZ: u32 = 1;
pub const GPIO_CR_MODE_OUTPUT_2MHZ: u32 = 2;
pub const GPIO_CR_MODE_OUTPUT_50MHZ: u32 = 3;
pub const AFIO_EVCR_EVOE: u32 = 128;
pub const AFIO_EVCR_PORT_PA: u32 = 0;
pub const AFIO_EVCR_PORT_PB: u32 = 16;
pub const AFIO_EVCR_PORT_PC: u32 = 32;
pub const AFIO_EVCR_PORT_PD: u32 = 48;
pub const AFIO_EVCR_PORT_PE: u32 = 64;
pub const AFIO_EVCR_PIN_0: u32 = 0;
pub const AFIO_EVCR_PIN_1: u32 = 1;
pub const AFIO_EVCR_PIN_2: u32 = 2;
pub const AFIO_EVCR_PIN_3: u32 = 3;
pub const AFIO_EVCR_PIN_4: u32 = 4;
pub const AFIO_EVCR_PIN_5: u32 = 5;
pub const AFIO_EVCR_PIN_6: u32 = 6;
pub const AFIO_EVCR_PIN_7: u32 = 7;
pub const AFIO_EVCR_PIN_8: u32 = 8;
pub const AFIO_EVCR_PIN_9: u32 = 9;
pub const AFIO_EVCR_PIN_10: u32 = 10;
pub const AFIO_EVCR_PIN_11: u32 = 11;
pub const AFIO_EVCR_PIN_12: u32 = 12;
pub const AFIO_EVCR_PIN_13: u32 = 13;
pub const AFIO_EVCR_PIN_14: u32 = 14;
pub const AFIO_EVCR_PIN_15: u32 = 15;
pub const AFIO_MAPR_SWJ_CFG: u32 = 117440512;
pub const AFIO_MAPR_SWJ_CFG_FULL_SWJ: u32 = 0;
pub const AFIO_MAPR_SWJ_CFG_FULL_SWJ_NO_NJRST: u32 = 16777216;
pub const AFIO_MAPR_SWJ_CFG_NO_JTAG_SW: u32 = 33554432;
pub const AFIO_MAPR_SWJ_CFG_NO_JTAG_NO_SW: u32 = 67108864;
pub const AFIO_MAPR_ADC2_ETRGREG_REMAP: u32 = 1048576;
pub const AFIO_MAPR_ADC2_ETRGINJ_REMAP: u32 = 524288;
pub const AFIO_MAPR_ADC1_ETRGREG_REMAP: u32 = 262144;
pub const AFIO_MAPR_ADC1_ETRGINJ_REMAP: u32 = 131072;
pub const AFIO_MAPR_TIM5CH4_IREMAP: u32 = 65536;
pub const AFIO_MAPR_PD01_REMAP: u32 = 32768;
pub const AFIO_MAPR_CAN_REMAP: u32 = 24576;
pub const AFIO_MAPR_CAN_REMAP_NONE: u32 = 0;
pub const AFIO_MAPR_CAN_REMAP_PB8_PB9: u32 = 16384;
pub const AFIO_MAPR_CAN_REMAP_PD0_PD1: u32 = 24576;
pub const AFIO_MAPR_TIM4_REMAP: u32 = 4096;
pub const AFIO_MAPR_TIM3_REMAP: u32 = 3072;
pub const AFIO_MAPR_TIM3_REMAP_NONE: u32 = 0;
pub const AFIO_MAPR_TIM3_REMAP_PARTIAL: u32 = 2048;
pub const AFIO_MAPR_TIM3_REMAP_FULL: u32 = 3072;
pub const AFIO_MAPR_TIM2_REMAP: u32 = 768;
pub const AFIO_MAPR_TIM2_REMAP_NONE: u32 = 0;
pub const AFIO_MAPR_TIM2_REMAP_PA15_PB3_PA2_PA3: u32 = 256;
pub const AFIO_MAPR_TIM2_REMAP_PA0_PA1_PB10_PB11: u32 = 512;
pub const AFIO_MAPR_TIM2_REMAP_FULL: u32 = 768;
pub const AFIO_MAPR_TIM1_REMAP: u32 = 192;
pub const AFIO_MAPR_TIM1_REMAP_NONE: u32 = 0;
pub const AFIO_MAPR_TIM1_REMAP_PARTIAL: u32 = 64;
pub const AFIO_MAPR_TIM1_REMAP_FULL: u32 = 192;
pub const AFIO_MAPR_USART3_REMAP: u32 = 48;
pub const AFIO_MAPR_USART3_REMAP_NONE: u32 = 0;
pub const AFIO_MAPR_USART3_REMAP_PARTIAL: u32 = 16;
pub const AFIO_MAPR_USART3_REMAP_FULL: u32 = 48;
pub const AFIO_MAPR_USART2_REMAP: u32 = 8;
pub const AFIO_MAPR_USART1_REMAP: u32 = 4;
pub const AFIO_MAPR_I2C1_REMAP: u32 = 2;
pub const AFIO_MAPR_SPI1_REMAP: u32 = 1;
pub const AFIO_EXTICR1_EXTI3: u32 = 61440;
pub const AFIO_EXTICR1_EXTI3_PA: u32 = 0;
pub const AFIO_EXTICR1_EXTI3_PB: u32 = 4096;
pub const AFIO_EXTICR1_EXTI3_PC: u32 = 8192;
pub const AFIO_EXTICR1_EXTI3_PD: u32 = 12288;
pub const AFIO_EXTICR1_EXTI3_PE: u32 = 16384;
pub const AFIO_EXTICR1_EXTI3_PF: u32 = 20480;
pub const AFIO_EXTICR1_EXTI3_PG: u32 = 24576;
pub const AFIO_EXTICR1_EXTI2: u32 = 3840;
pub const AFIO_EXTICR1_EXTI2_PA: u32 = 0;
pub const AFIO_EXTICR1_EXTI2_PB: u32 = 256;
pub const AFIO_EXTICR1_EXTI2_PC: u32 = 512;
pub const AFIO_EXTICR1_EXTI2_PD: u32 = 768;
pub const AFIO_EXTICR1_EXTI2_PE: u32 = 1024;
pub const AFIO_EXTICR1_EXTI2_PF: u32 = 1280;
pub const AFIO_EXTICR1_EXTI2_PG: u32 = 1536;
pub const AFIO_EXTICR1_EXTI1: u32 = 240;
pub const AFIO_EXTICR1_EXTI1_PA: u32 = 0;
pub const AFIO_EXTICR1_EXTI1_PB: u32 = 16;
pub const AFIO_EXTICR1_EXTI1_PC: u32 = 32;
pub const AFIO_EXTICR1_EXTI1_PD: u32 = 48;
pub const AFIO_EXTICR1_EXTI1_PE: u32 = 64;
pub const AFIO_EXTICR1_EXTI1_PF: u32 = 80;
pub const AFIO_EXTICR1_EXTI1_PG: u32 = 96;
pub const AFIO_EXTICR1_EXTI0: u32 = 15;
pub const AFIO_EXTICR1_EXTI0_PA: u32 = 0;
pub const AFIO_EXTICR1_EXTI0_PB: u32 = 1;
pub const AFIO_EXTICR1_EXTI0_PC: u32 = 2;
pub const AFIO_EXTICR1_EXTI0_PD: u32 = 3;
pub const AFIO_EXTICR1_EXTI0_PE: u32 = 4;
pub const AFIO_EXTICR1_EXTI0_PF: u32 = 5;
pub const AFIO_EXTICR1_EXTI0_PG: u32 = 6;
pub const AFIO_EXTICR2_EXTI7: u32 = 61440;
pub const AFIO_EXTICR2_EXTI7_PA: u32 = 0;
pub const AFIO_EXTICR2_EXTI7_PB: u32 = 4096;
pub const AFIO_EXTICR2_EXTI7_PC: u32 = 8192;
pub const AFIO_EXTICR2_EXTI7_PD: u32 = 12288;
pub const AFIO_EXTICR2_EXTI7_PE: u32 = 16384;
pub const AFIO_EXTICR2_EXTI7_PF: u32 = 20480;
pub const AFIO_EXTICR2_EXTI7_PG: u32 = 24576;
pub const AFIO_EXTICR2_EXTI6: u32 = 3840;
pub const AFIO_EXTICR2_EXTI6_PA: u32 = 0;
pub const AFIO_EXTICR2_EXTI6_PB: u32 = 256;
pub const AFIO_EXTICR2_EXTI6_PC: u32 = 512;
pub const AFIO_EXTICR2_EXTI6_PD: u32 = 768;
pub const AFIO_EXTICR2_EXTI6_PE: u32 = 1024;
pub const AFIO_EXTICR2_EXTI6_PF: u32 = 1280;
pub const AFIO_EXTICR2_EXTI6_PG: u32 = 1536;
pub const AFIO_EXTICR2_EXTI5: u32 = 240;
pub const AFIO_EXTICR2_EXTI5_PA: u32 = 0;
pub const AFIO_EXTICR2_EXTI5_PB: u32 = 16;
pub const AFIO_EXTICR2_EXTI5_PC: u32 = 32;
pub const AFIO_EXTICR2_EXTI5_PD: u32 = 48;
pub const AFIO_EXTICR2_EXTI5_PE: u32 = 64;
pub const AFIO_EXTICR2_EXTI5_PF: u32 = 80;
pub const AFIO_EXTICR2_EXTI5_PG: u32 = 96;
pub const AFIO_EXTICR2_EXTI4: u32 = 15;
pub const AFIO_EXTICR2_EXTI4_PA: u32 = 0;
pub const AFIO_EXTICR2_EXTI4_PB: u32 = 1;
pub const AFIO_EXTICR2_EXTI4_PC: u32 = 2;
pub const AFIO_EXTICR2_EXTI4_PD: u32 = 3;
pub const AFIO_EXTICR2_EXTI4_PE: u32 = 4;
pub const AFIO_EXTICR2_EXTI4_PF: u32 = 5;
pub const AFIO_EXTICR2_EXTI4_PG: u32 = 6;
pub const AFIO_MAPR2_FSMC_NADV: u32 = 1024;
pub const AFIO_MAPR2_TIM14_REMAP: u32 = 512;
pub const AFIO_MAPR2_TIM13_REMAP: u32 = 256;
pub const AFIO_MAPR2_TIM11_REMAP: u32 = 128;
pub const AFIO_MAPR2_TIM10_REMAP: u32 = 64;
pub const AFIO_MAPR2_TIM9_REMAP: u32 = 32;
pub const AFIO_REMAP_USE_MAPR2: u32 = 2147483648;
pub const BB_SRAM_REF: u32 = 536870912;
pub const BB_SRAM_BASE: u32 = 570425344;
pub const BB_PERI_REF: u32 = 1073741824;
pub const BB_PERI_BASE: u32 = 1107296256;
pub const RCC_CR_PLLRDY_BIT: u32 = 25;
pub const RCC_CR_PLLON_BIT: u32 = 24;
pub const RCC_CR_CSSON_BIT: u32 = 19;
pub const RCC_CR_HSEBYP_BIT: u32 = 18;
pub const RCC_CR_HSERDY_BIT: u32 = 17;
pub const RCC_CR_HSEON_BIT: u32 = 16;
pub const RCC_CR_HSIRDY_BIT: u32 = 1;
pub const RCC_CR_HSION_BIT: u32 = 0;
pub const RCC_CR_PLLRDY: u32 = 33554432;
pub const RCC_CR_PLLON: u32 = 16777216;
pub const RCC_CR_CSSON: u32 = 524288;
pub const RCC_CR_HSEBYP: u32 = 262144;
pub const RCC_CR_HSERDY: u32 = 131072;
pub const RCC_CR_HSEON: u32 = 65536;
pub const RCC_CR_HSICAL: u32 = 65280;
pub const RCC_CR_HSITRIM: u32 = 248;
pub const RCC_CR_HSIRDY: u32 = 2;
pub const RCC_CR_HSION: u32 = 1;
pub const RCC_CFGR_USBPRE_BIT: u32 = 22;
pub const RCC_CFGR_PLLXTPRE_BIT: u32 = 17;
pub const RCC_CFGR_PLLSRC_BIT: u32 = 16;
pub const RCC_CFGR_MCO: u32 = 50331648;
pub const RCC_CFGR_USBPRE: u32 = 12582912;
pub const RCC_CFGR_PLLMUL: u32 = 3932160;
pub const RCC_CFGR_PLLXTPRE: u32 = 131072;
pub const RCC_CFGR_PLLSRC: u32 = 65536;
pub const RCC_CFGR_ADCPRE: u32 = 49152;
pub const RCC_CFGR_PPRE2: u32 = 14336;
pub const RCC_CFGR_PPRE1: u32 = 1792;
pub const RCC_CFGR_HPRE: u32 = 240;
pub const RCC_CFGR_SWS: u32 = 12;
pub const RCC_CFGR_SWS_PLL: u32 = 8;
pub const RCC_CFGR_SWS_HSE: u32 = 4;
pub const RCC_CFGR_SW: u32 = 3;
pub const RCC_CFGR_SW_PLL: u32 = 2;
pub const RCC_CFGR_SW_HSE: u32 = 1;
pub const RCC_CIR_CSSC_BIT: u32 = 23;
pub const RCC_CIR_PLLRDYC_BIT: u32 = 20;
pub const RCC_CIR_HSERDYC_BIT: u32 = 19;
pub const RCC_CIR_HSIRDYC_BIT: u32 = 18;
pub const RCC_CIR_LSERDYC_BIT: u32 = 17;
pub const RCC_CIR_LSIRDYC_BIT: u32 = 16;
pub const RCC_CIR_PLLRDYIE_BIT: u32 = 12;
pub const RCC_CIR_HSERDYIE_BIT: u32 = 11;
pub const RCC_CIR_HSIRDYIE_BIT: u32 = 10;
pub const RCC_CIR_LSERDYIE_BIT: u32 = 9;
pub const RCC_CIR_LSIRDYIE_BIT: u32 = 8;
pub const RCC_CIR_CSSF_BIT: u32 = 7;
pub const RCC_CIR_PLLRDYF_BIT: u32 = 4;
pub const RCC_CIR_HSERDYF_BIT: u32 = 3;
pub const RCC_CIR_HSIRDYF_BIT: u32 = 2;
pub const RCC_CIR_LSERDYF_BIT: u32 = 1;
pub const RCC_CIR_LSIRDYF_BIT: u32 = 0;
pub const RCC_CIR_CSSC: u32 = 8388608;
pub const RCC_CIR_PLLRDYC: u32 = 1048576;
pub const RCC_CIR_HSERDYC: u32 = 524288;
pub const RCC_CIR_HSIRDYC: u32 = 262144;
pub const RCC_CIR_LSERDYC: u32 = 131072;
pub const RCC_CIR_LSIRDYC: u32 = 65536;
pub const RCC_CIR_PLLRDYIE: u32 = 4096;
pub const RCC_CIR_HSERDYIE: u32 = 2048;
pub const RCC_CIR_HSIRDYIE: u32 = 1024;
pub const RCC_CIR_LSERDYIE: u32 = 512;
pub const RCC_CIR_LSIRDYIE: u32 = 256;
pub const RCC_CIR_CSSF: u32 = 128;
pub const RCC_CIR_PLLRDYF: u32 = 16;
pub const RCC_CIR_HSERDYF: u32 = 8;
pub const RCC_CIR_HSIRDYF: u32 = 4;
pub const RCC_CIR_LSERDYF: u32 = 2;
pub const RCC_CIR_LSIRDYF: u32 = 1;
pub const RCC_APB2RSTR_TIM11RST_BIT: u32 = 21;
pub const RCC_APB2RSTR_TIM10RST_BIT: u32 = 20;
pub const RCC_APB2RSTR_TIM9RST_BIT: u32 = 19;
pub const RCC_APB2RSTR_ADC3RST_BIT: u32 = 15;
pub const RCC_APB2RSTR_USART1RST_BIT: u32 = 14;
pub const RCC_APB2RSTR_TIM8RST_BIT: u32 = 13;
pub const RCC_APB2RSTR_SPI1RST_BIT: u32 = 12;
pub const RCC_APB2RSTR_TIM1RST_BIT: u32 = 11;
pub const RCC_APB2RSTR_ADC2RST_BIT: u32 = 10;
pub const RCC_APB2RSTR_ADC1RST_BIT: u32 = 9;
pub const RCC_APB2RSTR_IOPGRST_BIT: u32 = 8;
pub const RCC_APB2RSTR_IOPFRST_BIT: u32 = 7;
pub const RCC_APB2RSTR_IOPERST_BIT: u32 = 6;
pub const RCC_APB2RSTR_IOPDRST_BIT: u32 = 5;
pub const RCC_APB2RSTR_IOPCRST_BIT: u32 = 4;
pub const RCC_APB2RSTR_IOPBRST_BIT: u32 = 3;
pub const RCC_APB2RSTR_IOPARST_BIT: u32 = 2;
pub const RCC_APB2RSTR_AFIORST_BIT: u32 = 0;
pub const RCC_APB2RSTR_TIM11RST: u32 = 2097152;
pub const RCC_APB2RSTR_TIM10RST: u32 = 1048576;
pub const RCC_APB2RSTR_TIM9RST: u32 = 524288;
pub const RCC_APB2RSTR_ADC3RST: u32 = 32768;
pub const RCC_APB2RSTR_USART1RST: u32 = 16384;
pub const RCC_APB2RSTR_TIM8RST: u32 = 8192;
pub const RCC_APB2RSTR_SPI1RST: u32 = 4096;
pub const RCC_APB2RSTR_TIM1RST: u32 = 2048;
pub const RCC_APB2RSTR_ADC2RST: u32 = 1024;
pub const RCC_APB2RSTR_ADC1RST: u32 = 512;
pub const RCC_APB2RSTR_IOPGRST: u32 = 256;
pub const RCC_APB2RSTR_IOPFRST: u32 = 128;
pub const RCC_APB2RSTR_IOPERST: u32 = 64;
pub const RCC_APB2RSTR_IOPDRST: u32 = 32;
pub const RCC_APB2RSTR_IOPCRST: u32 = 16;
pub const RCC_APB2RSTR_IOPBRST: u32 = 8;
pub const RCC_APB2RSTR_IOPARST: u32 = 4;
pub const RCC_APB2RSTR_AFIORST: u32 = 1;
pub const RCC_APB1RSTR_DACRST_BIT: u32 = 29;
pub const RCC_APB1RSTR_PWRRST_BIT: u32 = 28;
pub const RCC_APB1RSTR_BKPRST_BIT: u32 = 27;
pub const RCC_APB1RSTR_CANRST_BIT: u32 = 25;
pub const RCC_APB1RSTR_USBRST_BIT: u32 = 23;
pub const RCC_APB1RSTR_I2C2RST_BIT: u32 = 22;
pub const RCC_APB1RSTR_I2C1RST_BIT: u32 = 21;
pub const RCC_APB1RSTR_UART5RST_BIT: u32 = 20;
pub const RCC_APB1RSTR_UART4RST_BIT: u32 = 19;
pub const RCC_APB1RSTR_USART3RST_BIT: u32 = 18;
pub const RCC_APB1RSTR_USART2RST_BIT: u32 = 17;
pub const RCC_APB1RSTR_SPI3RST_BIT: u32 = 15;
pub const RCC_APB1RSTR_SPI2RST_BIT: u32 = 14;
pub const RCC_APB1RSTR_WWDRST_BIT: u32 = 11;
pub const RCC_APB1RSTR_TIM14RST_BIT: u32 = 8;
pub const RCC_APB1RSTR_TIM13RST_BIT: u32 = 7;
pub const RCC_APB1RSTR_TIM12RST_BIT: u32 = 6;
pub const RCC_APB1RSTR_TIM7RST_BIT: u32 = 5;
pub const RCC_APB1RSTR_TIM6RST_BIT: u32 = 4;
pub const RCC_APB1RSTR_TIM5RST_BIT: u32 = 3;
pub const RCC_APB1RSTR_TIM4RST_BIT: u32 = 2;
pub const RCC_APB1RSTR_TIM3RST_BIT: u32 = 1;
pub const RCC_APB1RSTR_TIM2RST_BIT: u32 = 0;
pub const RCC_APB1RSTR_DACRST: u32 = 536870912;
pub const RCC_APB1RSTR_PWRRST: u32 = 268435456;
pub const RCC_APB1RSTR_BKPRST: u32 = 134217728;
pub const RCC_APB1RSTR_CANRST: u32 = 33554432;
pub const RCC_APB1RSTR_USBRST: u32 = 8388608;
pub const RCC_APB1RSTR_I2C2RST: u32 = 4194304;
pub const RCC_APB1RSTR_I2C1RST: u32 = 2097152;
pub const RCC_APB1RSTR_UART5RST: u32 = 1048576;
pub const RCC_APB1RSTR_UART4RST: u32 = 524288;
pub const RCC_APB1RSTR_USART3RST: u32 = 262144;
pub const RCC_APB1RSTR_USART2RST: u32 = 131072;
pub const RCC_APB1RSTR_SPI3RST: u32 = 32768;
pub const RCC_APB1RSTR_SPI2RST: u32 = 16384;
pub const RCC_APB1RSTR_WWDRST: u32 = 2048;
pub const RCC_APB1RSTR_TIM14RST: u32 = 256;
pub const RCC_APB1RSTR_TIM13RST: u32 = 128;
pub const RCC_APB1RSTR_TIM12RST: u32 = 64;
pub const RCC_APB1RSTR_TIM7RST: u32 = 32;
pub const RCC_APB1RSTR_TIM6RST: u32 = 16;
pub const RCC_APB1RSTR_TIM5RST: u32 = 8;
pub const RCC_APB1RSTR_TIM4RST: u32 = 4;
pub const RCC_APB1RSTR_TIM3RST: u32 = 2;
pub const RCC_APB1RSTR_TIM2RST: u32 = 1;
pub const RCC_AHBENR_SDIOEN_BIT: u32 = 10;
pub const RCC_AHBENR_FSMCEN_BIT: u32 = 8;
pub const RCC_AHBENR_CRCEN_BIT: u32 = 7;
pub const RCC_AHBENR_FLITFEN_BIT: u32 = 4;
pub const RCC_AHBENR_SRAMEN_BIT: u32 = 2;
pub const RCC_AHBENR_DMA2EN_BIT: u32 = 1;
pub const RCC_AHBENR_DMA1EN_BIT: u32 = 0;
pub const RCC_AHBENR_SDIOEN: u32 = 1024;
pub const RCC_AHBENR_FSMCEN: u32 = 256;
pub const RCC_AHBENR_CRCEN: u32 = 128;
pub const RCC_AHBENR_FLITFEN: u32 = 16;
pub const RCC_AHBENR_SRAMEN: u32 = 4;
pub const RCC_AHBENR_DMA2EN: u32 = 2;
pub const RCC_AHBENR_DMA1EN: u32 = 1;
pub const RCC_APB2ENR_TIM11EN_BIT: u32 = 21;
pub const RCC_APB2ENR_TIM10EN_BIT: u32 = 20;
pub const RCC_APB2ENR_TIM9EN_BIT: u32 = 19;
pub const RCC_APB2ENR_ADC3EN_BIT: u32 = 15;
pub const RCC_APB2ENR_USART1EN_BIT: u32 = 14;
pub const RCC_APB2ENR_TIM8EN_BIT: u32 = 13;
pub const RCC_APB2ENR_SPI1EN_BIT: u32 = 12;
pub const RCC_APB2ENR_TIM1EN_BIT: u32 = 11;
pub const RCC_APB2ENR_ADC2EN_BIT: u32 = 10;
pub const RCC_APB2ENR_ADC1EN_BIT: u32 = 9;
pub const RCC_APB2ENR_IOPGEN_BIT: u32 = 8;
pub const RCC_APB2ENR_IOPFEN_BIT: u32 = 7;
pub const RCC_APB2ENR_IOPEEN_BIT: u32 = 6;
pub const RCC_APB2ENR_IOPDEN_BIT: u32 = 5;
pub const RCC_APB2ENR_IOPCEN_BIT: u32 = 4;
pub const RCC_APB2ENR_IOPBEN_BIT: u32 = 3;
pub const RCC_APB2ENR_IOPAEN_BIT: u32 = 2;
pub const RCC_APB2ENR_AFIOEN_BIT: u32 = 0;
pub const RCC_APB2ENR_TIM11EN: u32 = 2097152;
pub const RCC_APB2ENR_TIM10EN: u32 = 1048576;
pub const RCC_APB2ENR_TIM9EN: u32 = 524288;
pub const RCC_APB2ENR_ADC3EN: u32 = 32768;
pub const RCC_APB2ENR_USART1EN: u32 = 16384;
pub const RCC_APB2ENR_TIM8EN: u32 = 8192;
pub const RCC_APB2ENR_SPI1EN: u32 = 4096;
pub const RCC_APB2ENR_TIM1EN: u32 = 2048;
pub const RCC_APB2ENR_ADC2EN: u32 = 1024;
pub const RCC_APB2ENR_ADC1EN: u32 = 512;
pub const RCC_APB2ENR_IOPGEN: u32 = 256;
pub const RCC_APB2ENR_IOPFEN: u32 = 128;
pub const RCC_APB2ENR_IOPEEN: u32 = 64;
pub const RCC_APB2ENR_IOPDEN: u32 = 32;
pub const RCC_APB2ENR_IOPCEN: u32 = 16;
pub const RCC_APB2ENR_IOPBEN: u32 = 8;
pub const RCC_APB2ENR_IOPAEN: u32 = 4;
pub const RCC_APB2ENR_AFIOEN: u32 = 1;
pub const RCC_APB1ENR_DACEN_BIT: u32 = 29;
pub const RCC_APB1ENR_PWREN_BIT: u32 = 28;
pub const RCC_APB1ENR_BKPEN_BIT: u32 = 27;
pub const RCC_APB1ENR_CANEN_BIT: u32 = 25;
pub const RCC_APB1ENR_USBEN_BIT: u32 = 23;
pub const RCC_APB1ENR_I2C2EN_BIT: u32 = 22;
pub const RCC_APB1ENR_I2C1EN_BIT: u32 = 21;
pub const RCC_APB1ENR_UART5EN_BIT: u32 = 20;
pub const RCC_APB1ENR_UART4EN_BIT: u32 = 19;
pub const RCC_APB1ENR_USART3EN_BIT: u32 = 18;
pub const RCC_APB1ENR_USART2EN_BIT: u32 = 17;
pub const RCC_APB1ENR_SPI3EN_BIT: u32 = 15;
pub const RCC_APB1ENR_SPI2EN_BIT: u32 = 14;
pub const RCC_APB1ENR_WWDEN_BIT: u32 = 11;
pub const RCC_APB1ENR_TIM14EN_BIT: u32 = 8;
pub const RCC_APB1ENR_TIM13EN_BIT: u32 = 7;
pub const RCC_APB1ENR_TIM12EN_BIT: u32 = 6;
pub const RCC_APB1ENR_TIM7EN_BIT: u32 = 5;
pub const RCC_APB1ENR_TIM6EN_BIT: u32 = 4;
pub const RCC_APB1ENR_TIM5EN_BIT: u32 = 3;
pub const RCC_APB1ENR_TIM4EN_BIT: u32 = 2;
pub const RCC_APB1ENR_TIM3EN_BIT: u32 = 1;
pub const RCC_APB1ENR_TIM2EN_BIT: u32 = 0;
pub const RCC_APB1ENR_DACEN: u32 = 536870912;
pub const RCC_APB1ENR_PWREN: u32 = 268435456;
pub const RCC_APB1ENR_BKPEN: u32 = 134217728;
pub const RCC_APB1ENR_CANEN: u32 = 33554432;
pub const RCC_APB1ENR_USBEN: u32 = 8388608;
pub const RCC_APB1ENR_I2C2EN: u32 = 4194304;
pub const RCC_APB1ENR_I2C1EN: u32 = 2097152;
pub const RCC_APB1ENR_UART5EN: u32 = 1048576;
pub const RCC_APB1ENR_UART4EN: u32 = 524288;
pub const RCC_APB1ENR_USART3EN: u32 = 262144;
pub const RCC_APB1ENR_USART2EN: u32 = 131072;
pub const RCC_APB1ENR_SPI3EN: u32 = 32768;
pub const RCC_APB1ENR_SPI2EN: u32 = 16384;
pub const RCC_APB1ENR_WWDEN: u32 = 2048;
pub const RCC_APB1ENR_TIM14EN: u32 = 256;
pub const RCC_APB1ENR_TIM13EN: u32 = 128;
pub const RCC_APB1ENR_TIM12EN: u32 = 64;
pub const RCC_APB1ENR_TIM7EN: u32 = 32;
pub const RCC_APB1ENR_TIM6EN: u32 = 16;
pub const RCC_APB1ENR_TIM5EN: u32 = 8;
pub const RCC_APB1ENR_TIM4EN: u32 = 4;
pub const RCC_APB1ENR_TIM3EN: u32 = 2;
pub const RCC_APB1ENR_TIM2EN: u32 = 1;
pub const RCC_BDCR_BDRST_BIT: u32 = 16;
pub const RCC_BDCR_RTCEN_BIT: u32 = 15;
pub const RCC_BDCR_LSEBYP_BIT: u32 = 2;
pub const RCC_BDCR_LSERDY_BIT: u32 = 1;
pub const RCC_BDCR_LSEON_BIT: u32 = 0;
pub const RCC_BDCR_BDRST: u32 = 65536;
pub const RCC_BDCR_RTCSEL: u32 = 768;
pub const RCC_BDCR_RTCSEL_NONE: u32 = 0;
pub const RCC_BDCR_RTCSEL_LSE: u32 = 256;
pub const RCC_BDCR_RTCSEL_LSI: u32 = 512;
pub const RCC_BDCR_RTCSEL_HSE: u32 = 768;
pub const RCC_BDCR_LSEBYP: u32 = 4;
pub const RCC_BDCR_LSERDY: u32 = 2;
pub const RCC_BDCR_LSEON: u32 = 1;
pub const RCC_CSR_LPWRRSTF_BIT: u32 = 31;
pub const RCC_CSR_WWDGRSTF_BIT: u32 = 30;
pub const RCC_CSR_IWDGRSTF_BIT: u32 = 29;
pub const RCC_CSR_SFTRSTF_BIT: u32 = 28;
pub const RCC_CSR_PORRSTF_BIT: u32 = 27;
pub const RCC_CSR_PINRSTF_BIT: u32 = 26;
pub const RCC_CSR_RMVF_BIT: u32 = 24;
pub const RCC_CSR_LSIRDY_BIT: u32 = 1;
pub const RCC_CSR_LSION_BIT: u32 = 0;
pub const RCC_CSR_LPWRRSTF: u32 = 2147483648;
pub const RCC_CSR_WWDGRSTF: u32 = 1073741824;
pub const RCC_CSR_IWDGRSTF: u32 = 536870912;
pub const RCC_CSR_SFTRSTF: u32 = 268435456;
pub const RCC_CSR_PORRSTF: u32 = 134217728;
pub const RCC_CSR_PINRSTF: u32 = 67108864;
pub const RCC_CSR_RMVF: u32 = 16777216;
pub const RCC_CSR_LSIRDY: u32 = 2;
pub const RCC_CSR_LSION: u32 = 1;
pub const DEBUG_NONE: u32 = 0;
pub const DEBUG_FAULT: u32 = 1;
pub const DEBUG_ALL: u32 = 2;
pub const DEBUG_LEVEL: u32 = 2;
pub const TIMER_CR1_ARPE_BIT: u32 = 7;
pub const TIMER_CR1_DIR_BIT: u32 = 4;
pub const TIMER_CR1_OPM_BIT: u32 = 3;
pub const TIMER_CR1_URS_BIT: u32 = 2;
pub const TIMER_CR1_UDIS_BIT: u32 = 1;
pub const TIMER_CR1_CEN_BIT: u32 = 0;
pub const TIMER_CR1_CKD: u32 = 768;
pub const TIMER_CR1_CKD_1TCKINT: u32 = 0;
pub const TIMER_CR1_CKD_2TCKINT: u32 = 256;
pub const TIMER_CR1_CKD_4TICKINT: u32 = 512;
pub const TIMER_CR1_ARPE: u32 = 128;
pub const TIMER_CR1_CKD_CMS: u32 = 96;
pub const TIMER_CR1_CKD_CMS_EDGE: u32 = 0;
pub const TIMER_CR1_CKD_CMS_CENTER1: u32 = 32;
pub const TIMER_CR1_CKD_CMS_CENTER2: u32 = 64;
pub const TIMER_CR1_CKD_CMS_CENTER3: u32 = 96;
pub const TIMER_CR1_DIR: u32 = 16;
pub const TIMER_CR1_OPM: u32 = 8;
pub const TIMER_CR1_URS: u32 = 4;
pub const TIMER_CR1_UDIS: u32 = 2;
pub const TIMER_CR1_CEN: u32 = 1;
pub const TIMER_CR2_OIS4_BIT: u32 = 14;
pub const TIMER_CR2_OIS3N_BIT: u32 = 13;
pub const TIMER_CR2_OIS3_BIT: u32 = 12;
pub const TIMER_CR2_OIS2N_BIT: u32 = 11;
pub const TIMER_CR2_OIS2_BIT: u32 = 10;
pub const TIMER_CR2_OIS1N_BIT: u32 = 9;
pub const TIMER_CR2_OIS1_BIT: u32 = 8;
pub const TIMER_CR2_TI1S_BIT: u32 = 7;
pub const TIMER_CR2_CCDS_BIT: u32 = 3;
pub const TIMER_CR2_CCUS_BIT: u32 = 2;
pub const TIMER_CR2_CCPC_BIT: u32 = 0;
pub const TIMER_CR2_OIS4: u32 = 16384;
pub const TIMER_CR2_OIS3N: u32 = 8192;
pub const TIMER_CR2_OIS3: u32 = 4096;
pub const TIMER_CR2_OIS2N: u32 = 2048;
pub const TIMER_CR2_OIS2: u32 = 1024;
pub const TIMER_CR2_OIS1N: u32 = 512;
pub const TIMER_CR2_OIS1: u32 = 256;
pub const TIMER_CR2_TI1S: u32 = 128;
pub const TIMER_CR2_MMS: u32 = 112;
pub const TIMER_CR2_MMS_RESET: u32 = 0;
pub const TIMER_CR2_MMS_ENABLE: u32 = 16;
pub const TIMER_CR2_MMS_UPDATE: u32 = 32;
pub const TIMER_CR2_MMS_COMPARE_PULSE: u32 = 48;
pub const TIMER_CR2_MMS_COMPARE_OC1REF: u32 = 64;
pub const TIMER_CR2_MMS_COMPARE_OC2REF: u32 = 80;
pub const TIMER_CR2_MMS_COMPARE_OC3REF: u32 = 96;
pub const TIMER_CR2_MMS_COMPARE_OC4REF: u32 = 112;
pub const TIMER_CR2_CCDS: u32 = 8;
pub const TIMER_CR2_CCUS: u32 = 4;
pub const TIMER_CR2_CCPC: u32 = 1;
pub const TIMER_SMCR_ETP_BIT: u32 = 15;
pub const TIMER_SMCR_ECE_BIT: u32 = 14;
pub const TIMER_SMCR_MSM_BIT: u32 = 7;
pub const TIMER_SMCR_ETP: u32 = 32768;
pub const TIMER_SMCR_ECE: u32 = 16384;
pub const TIMER_SMCR_ETPS: u32 = 12288;
pub const TIMER_SMCR_ETPS_OFF: u32 = 0;
pub const TIMER_SMCR_ETPS_DIV2: u32 = 4096;
pub const TIMER_SMCR_ETPS_DIV4: u32 = 8192;
pub const TIMER_SMCR_ETPS_DIV8: u32 = 12288;
pub const TIMER_SMCR_ETF: u32 = 61440;
pub const TIMER_SMCR_MSM: u32 = 128;
pub const TIMER_SMCR_TS: u32 = 112;
pub const TIMER_SMCR_TS_ITR0: u32 = 0;
pub const TIMER_SMCR_TS_ITR1: u32 = 16;
pub const TIMER_SMCR_TS_ITR2: u32 = 32;
pub const TIMER_SMCR_TS_ITR3: u32 = 48;
pub const TIMER_SMCR_TS_TI1F_ED: u32 = 64;
pub const TIMER_SMCR_TS_TI1FP1: u32 = 80;
pub const TIMER_SMCR_TS_TI2FP2: u32 = 96;
pub const TIMER_SMCR_TS_ETRF: u32 = 112;
pub const TIMER_SMCR_SMS: u32 = 7;
pub const TIMER_SMCR_SMS_DISABLED: u32 = 0;
pub const TIMER_SMCR_SMS_ENCODER1: u32 = 1;
pub const TIMER_SMCR_SMS_ENCODER2: u32 = 2;
pub const TIMER_SMCR_SMS_ENCODER3: u32 = 3;
pub const TIMER_SMCR_SMS_RESET: u32 = 4;
pub const TIMER_SMCR_SMS_GATED: u32 = 5;
pub const TIMER_SMCR_SMS_TRIGGER: u32 = 6;
pub const TIMER_SMCR_SMS_EXTERNAL: u32 = 7;
pub const TIMER_DIER_TDE_BIT: u32 = 14;
pub const TIMER_DIER_COMDE_BIT: u32 = 13;
pub const TIMER_DIER_CC4DE_BIT: u32 = 12;
pub const TIMER_DIER_CC3DE_BIT: u32 = 11;
pub const TIMER_DIER_CC2DE_BIT: u32 = 10;
pub const TIMER_DIER_CC1DE_BIT: u32 = 9;
pub const TIMER_DIER_UDE_BIT: u32 = 8;
pub const TIMER_DIER_BIE_BIT: u32 = 7;
pub const TIMER_DIER_TIE_BIT: u32 = 6;
pub const TIMER_DIER_COMIE_BIT: u32 = 5;
pub const TIMER_DIER_CC4IE_BIT: u32 = 4;
pub const TIMER_DIER_CC3IE_BIT: u32 = 3;
pub const TIMER_DIER_CC2IE_BIT: u32 = 2;
pub const TIMER_DIER_CC1IE_BIT: u32 = 1;
pub const TIMER_DIER_UIE_BIT: u32 = 0;
pub const TIMER_DIER_TDE: u32 = 16384;
pub const TIMER_DIER_COMDE: u32 = 8192;
pub const TIMER_DIER_CC4DE: u32 = 4096;
pub const TIMER_DIER_CC3DE: u32 = 2048;
pub const TIMER_DIER_CC2DE: u32 = 1024;
pub const TIMER_DIER_CC1DE: u32 = 512;
pub const TIMER_DIER_UDE: u32 = 256;
pub const TIMER_DIER_BIE: u32 = 128;
pub const TIMER_DIER_TIE: u32 = 64;
pub const TIMER_DIER_COMIE: u32 = 32;
pub const TIMER_DIER_CC4IE: u32 = 16;
pub const TIMER_DIER_CC3IE: u32 = 8;
pub const TIMER_DIER_CC2IE: u32 = 4;
pub const TIMER_DIER_CC1IE: u32 = 2;
pub const TIMER_DIER_UIE: u32 = 1;
pub const TIMER_SR_CC4OF_BIT: u32 = 12;
pub const TIMER_SR_CC3OF_BIT: u32 = 11;
pub const TIMER_SR_CC2OF_BIT: u32 = 10;
pub const TIMER_SR_CC1OF_BIT: u32 = 9;
pub const TIMER_SR_BIF_BIT: u32 = 7;
pub const TIMER_SR_TIF_BIT: u32 = 6;
pub const TIMER_SR_COMIF_BIT: u32 = 5;
pub const TIMER_SR_CC4IF_BIT: u32 = 4;
pub const TIMER_SR_CC3IF_BIT: u32 = 3;
pub const TIMER_SR_CC2IF_BIT: u32 = 2;
pub const TIMER_SR_CC1IF_BIT: u32 = 1;
pub const TIMER_SR_UIF_BIT: u32 = 0;
pub const TIMER_SR_CC4OF: u32 = 4096;
pub const TIMER_SR_CC3OF: u32 = 2048;
pub const TIMER_SR_CC2OF: u32 = 1024;
pub const TIMER_SR_CC1OF: u32 = 512;
pub const TIMER_SR_BIF: u32 = 128;
pub const TIMER_SR_TIF: u32 = 64;
pub const TIMER_SR_COMIF: u32 = 32;
pub const TIMER_SR_CC4IF: u32 = 16;
pub const TIMER_SR_CC3IF: u32 = 8;
pub const TIMER_SR_CC2IF: u32 = 4;
pub const TIMER_SR_CC1IF: u32 = 2;
pub const TIMER_SR_UIF: u32 = 1;
pub const TIMER_EGR_BG_BIT: u32 = 7;
pub const TIMER_EGR_TG_BIT: u32 = 6;
pub const TIMER_EGR_COMG_BIT: u32 = 5;
pub const TIMER_EGR_CC4G_BIT: u32 = 4;
pub const TIMER_EGR_CC3G_BIT: u32 = 3;
pub const TIMER_EGR_CC2G_BIT: u32 = 2;
pub const TIMER_EGR_CC1G_BIT: u32 = 1;
pub const TIMER_EGR_UG_BIT: u32 = 0;
pub const TIMER_EGR_BG: u32 = 128;
pub const TIMER_EGR_TG: u32 = 64;
pub const TIMER_EGR_COMG: u32 = 32;
pub const TIMER_EGR_CC4G: u32 = 16;
pub const TIMER_EGR_CC3G: u32 = 8;
pub const TIMER_EGR_CC2G: u32 = 4;
pub const TIMER_EGR_CC1G: u32 = 2;
pub const TIMER_EGR_UG: u32 = 1;
pub const TIMER_CCMR_CCS_INPUT_TI1: u32 = 1;
pub const TIMER_CCMR_CCS_INPUT_TI2: u32 = 2;
pub const TIMER_CCMR_CCS_INPUT_TRC: u32 = 3;
pub const TIMER_CCMR1_OC2CE_BIT: u32 = 15;
pub const TIMER_CCMR1_OC2PE_BIT: u32 = 11;
pub const TIMER_CCMR1_OC2FE_BIT: u32 = 10;
pub const TIMER_CCMR1_OC1CE_BIT: u32 = 7;
pub const TIMER_CCMR1_OC1PE_BIT: u32 = 3;
pub const TIMER_CCMR1_OC1FE_BIT: u32 = 2;
pub const TIMER_CCMR1_OC2CE: u32 = 32768;
pub const TIMER_CCMR1_OC2M: u32 = 28672;
pub const TIMER_CCMR1_IC2F: u32 = 61440;
pub const TIMER_CCMR1_OC2PE: u32 = 2048;
pub const TIMER_CCMR1_OC2FE: u32 = 1024;
pub const TIMER_CCMR1_IC2PSC: u32 = 3072;
pub const TIMER_CCMR1_CC2S: u32 = 768;
pub const TIMER_CCMR1_CC2S_OUTPUT: u32 = 0;
pub const TIMER_CCMR1_CC2S_INPUT_TI2: u32 = 256;
pub const TIMER_CCMR1_CC2S_INPUT_TI1: u32 = 512;
pub const TIMER_CCMR1_CC2S_INPUT_TRC: u32 = 768;
pub const TIMER_CCMR1_OC1CE: u32 = 128;
pub const TIMER_CCMR1_OC1M: u32 = 112;
pub const TIMER_CCMR1_IC1F: u32 = 240;
pub const TIMER_CCMR1_OC1PE: u32 = 8;
pub const TIMER_CCMR1_OC1FE: u32 = 4;
pub const TIMER_CCMR1_IC1PSC: u32 = 12;
pub const TIMER_CCMR1_CC1S: u32 = 3;
pub const TIMER_CCMR1_CC1S_OUTPUT: u32 = 0;
pub const TIMER_CCMR1_CC1S_INPUT_TI1: u32 = 1;
pub const TIMER_CCMR1_CC1S_INPUT_TI2: u32 = 2;
pub const TIMER_CCMR1_CC1S_INPUT_TRC: u32 = 3;
pub const TIMER_CCMR2_OC4CE_BIT: u32 = 15;
pub const TIMER_CCMR2_OC4PE_BIT: u32 = 11;
pub const TIMER_CCMR2_OC4FE_BIT: u32 = 10;
pub const TIMER_CCMR2_OC3CE_BIT: u32 = 7;
pub const TIMER_CCMR2_OC3PE_BIT: u32 = 3;
pub const TIMER_CCMR2_OC3FE_BIT: u32 = 2;
pub const TIMER_CCMR2_OC4CE: u32 = 32768;
pub const TIMER_CCMR2_OC4M: u32 = 28672;
pub const TIMER_CCMR2_IC4F: u32 = 61440;
pub const TIMER_CCMR2_OC4PE: u32 = 2048;
pub const TIMER_CCMR2_OC4FE: u32 = 1024;
pub const TIMER_CCMR2_IC4PSC: u32 = 3072;
pub const TIMER_CCMR2_CC4S: u32 = 768;
pub const TIMER_CCMR2_CC4S_OUTPUT: u32 = 0;
pub const TIMER_CCMR2_CC4S_INPUT_TI4: u32 = 256;
pub const TIMER_CCMR2_CC4S_INPUT_TI3: u32 = 512;
pub const TIMER_CCMR2_CC4S_INPUT_TRC: u32 = 768;
pub const TIMER_CCMR2_OC3CE: u32 = 128;
pub const TIMER_CCMR2_OC3M: u32 = 112;
pub const TIMER_CCMR2_IC3F: u32 = 240;
pub const TIMER_CCMR2_OC3PE: u32 = 8;
pub const TIMER_CCMR2_OC3FE: u32 = 4;
pub const TIMER_CCMR2_IC3PSC: u32 = 12;
pub const TIMER_CCMR2_CC3S: u32 = 3;
pub const TIMER_CCMR2_CC3S_OUTPUT: u32 = 0;
pub const TIMER_CCMR2_CC3S_INPUT_TI3: u32 = 1;
pub const TIMER_CCMR2_CC3S_INPUT_TI4: u32 = 2;
pub const TIMER_CCMR2_CC3S_INPUT_TRC: u32 = 3;
pub const TIMER_CCER_CC4P_BIT: u32 = 13;
pub const TIMER_CCER_CC4E_BIT: u32 = 12;
pub const TIMER_CCER_CC3NP_BIT: u32 = 11;
pub const TIMER_CCER_CC3NE_BIT: u32 = 10;
pub const TIMER_CCER_CC3P_BIT: u32 = 9;
pub const TIMER_CCER_CC3E_BIT: u32 = 8;
pub const TIMER_CCER_CC2NP_BIT: u32 = 7;
pub const TIMER_CCER_CC2NE_BIT: u32 = 6;
pub const TIMER_CCER_CC2P_BIT: u32 = 5;
pub const TIMER_CCER_CC2E_BIT: u32 = 4;
pub const TIMER_CCER_CC1NP_BIT: u32 = 3;
pub const TIMER_CCER_CC1NE_BIT: u32 = 2;
pub const TIMER_CCER_CC1P_BIT: u32 = 1;
pub const TIMER_CCER_CC1E_BIT: u32 = 0;
pub const TIMER_CCER_CC4P: u32 = 8192;
pub const TIMER_CCER_CC4E: u32 = 4096;
pub const TIMER_CCER_CC3NP: u32 = 2048;
pub const TIMER_CCER_CC3NE: u32 = 1024;
pub const TIMER_CCER_CC3P: u32 = 512;
pub const TIMER_CCER_CC3E: u32 = 256;
pub const TIMER_CCER_CC2NP: u32 = 128;
pub const TIMER_CCER_CC2NE: u32 = 64;
pub const TIMER_CCER_CC2P: u32 = 32;
pub const TIMER_CCER_CC2E: u32 = 16;
pub const TIMER_CCER_CC1NP: u32 = 8;
pub const TIMER_CCER_CC1NE: u32 = 4;
pub const TIMER_CCER_CC1P: u32 = 2;
pub const TIMER_CCER_CC1E: u32 = 1;
pub const TIMER_BDTR_MOE_BIT: u32 = 15;
pub const TIMER_BDTR_AOE_BIT: u32 = 14;
pub const TIMER_BDTR_BKP_BIT: u32 = 13;
pub const TIMER_BDTR_BKE_BIT: u32 = 12;
pub const TIMER_BDTR_OSSR_BIT: u32 = 11;
pub const TIMER_BDTR_OSSI_BIT: u32 = 10;
pub const TIMER_BDTR_MOE: u32 = 32768;
pub const TIMER_BDTR_AOE: u32 = 16384;
pub const TIMER_BDTR_BKP: u32 = 8192;
pub const TIMER_BDTR_BKE: u32 = 4096;
pub const TIMER_BDTR_OSSR: u32 = 2048;
pub const TIMER_BDTR_OSSI: u32 = 1024;
pub const TIMER_BDTR_LOCK: u32 = 768;
pub const TIMER_BDTR_LOCK_OFF: u32 = 0;
pub const TIMER_BDTR_LOCK_LEVEL1: u32 = 256;
pub const TIMER_BDTR_LOCK_LEVEL2: u32 = 512;
pub const TIMER_BDTR_LOCK_LEVEL3: u32 = 768;
pub const TIMER_BDTR_DTG: u32 = 255;
pub const TIMER_DCR_DBL: u32 = 7936;
pub const TIMER_DCR_DBL_1_XFER: u32 = 0;
pub const TIMER_DCR_DBL_2_XFER: u32 = 256;
pub const TIMER_DCR_DBL_3_XFER: u32 = 512;
pub const TIMER_DCR_DBL_4_XFER: u32 = 768;
pub const TIMER_DCR_DBL_5_XFER: u32 = 1024;
pub const TIMER_DCR_DBL_6_XFER: u32 = 1280;
pub const TIMER_DCR_DBL_7_XFER: u32 = 1536;
pub const TIMER_DCR_DBL_8_XFER: u32 = 1792;
pub const TIMER_DCR_DBL_9_XFER: u32 = 2048;
pub const TIMER_DCR_DBL_10_XFER: u32 = 2304;
pub const TIMER_DCR_DBL_11_XFER: u32 = 2560;
pub const TIMER_DCR_DBL_12_XFER: u32 = 2816;
pub const TIMER_DCR_DBL_13_XFER: u32 = 3072;
pub const TIMER_DCR_DBL_14_XFER: u32 = 3328;
pub const TIMER_DCR_DBL_15_XFER: u32 = 3584;
pub const TIMER_DCR_DBL_16_XFER: u32 = 3840;
pub const TIMER_DCR_DBL_17_XFER: u32 = 4096;
pub const TIMER_DCR_DBL_18_XFER: u32 = 4352;
pub const TIMER_DCR_DBA: u32 = 31;
pub const TIMER_DCR_DBA_CR1: u32 = 0;
pub const TIMER_DCR_DBA_CR2: u32 = 1;
pub const TIMER_DCR_DBA_SMCR: u32 = 2;
pub const TIMER_DCR_DBA_DIER: u32 = 3;
pub const TIMER_DCR_DBA_SR: u32 = 4;
pub const TIMER_DCR_DBA_EGR: u32 = 5;
pub const TIMER_DCR_DBA_CCMR1: u32 = 6;
pub const TIMER_DCR_DBA_CCMR2: u32 = 7;
pub const TIMER_DCR_DBA_CCER: u32 = 8;
pub const TIMER_DCR_DBA_CNT: u32 = 9;
pub const TIMER_DCR_DBA_PSC: u32 = 10;
pub const TIMER_DCR_DBA_ARR: u32 = 11;
pub const TIMER_DCR_DBA_RCR: u32 = 12;
pub const TIMER_DCR_DBA_CCR1: u32 = 13;
pub const TIMER_DCR_DBA_CCR2: u32 = 14;
pub const TIMER_DCR_DBA_CCR3: u32 = 15;
pub const TIMER_DCR_DBA_CCR4: u32 = 16;
pub const TIMER_DCR_DBA_BDTR: u32 = 17;
pub const TIMER_DCR_DBA_DCR: u32 = 18;
pub const TIMER_DCR_DBA_DMAR: u32 = 19;
pub const ADC_CR2_ADON_BIT: u32 = 0;
pub const ADC_CR2_CONT_BIT: u32 = 1;
pub const ADC_CR2_CAL_BIT: u32 = 2;
pub const ADC_CR2_RSTCAL_BIT: u32 = 3;
pub const ADC_CR2_DMA_BIT: u32 = 8;
pub const ADC_CR2_ALIGN_BIT: u32 = 11;
pub const ADC_CR2_JEXTTRIG_BIT: u32 = 15;
pub const ADC_CR2_EXTTRIG_BIT: u32 = 20;
pub const ADC_CR2_JSWSTART_BIT: u32 = 21;
pub const ADC_CR2_SWSTART_BIT: u32 = 22;
pub const ADC_CR2_TSVREFE_BIT: u32 = 23;
pub const ADC_CR2_ADON: u32 = 1;
pub const ADC_CR2_CONT: u32 = 2;
pub const ADC_CR2_CAL: u32 = 4;
pub const ADC_CR2_RSTCAL: u32 = 8;
pub const ADC_CR2_DMA: u32 = 256;
pub const ADC_CR2_ALIGN: u32 = 2048;
pub const ADC_CR2_JEXTSEL: u32 = 28672;
pub const ADC_CR2_JEXTSEL_TIM1_TRGO: u32 = 0;
pub const ADC_CR2_JEXTSEL_TIM1_CC4: u32 = 4096;
pub const ADC_CR2_JEXTSEL_TIM2_TRGO: u32 = 8192;
pub const ADC_CR2_JEXTSEL_TIM2_CC1: u32 = 12288;
pub const ADC_CR2_JEXTSEL_TIM3_CC4: u32 = 16384;
pub const ADC_CR2_JEXTSEL_TIM4_TRGO: u32 = 20480;
pub const ADC_CR2_JEXTSEL_EXTI15: u32 = 24576;
pub const ADC_CR2_JEXTSEL_JSWSTART: u32 = 28672;
pub const ADC_CR2_JEXTTRIG: u32 = 32768;
pub const ADC_CR2_EXTSEL: u32 = 917504;
pub const ADC_CR2_EXTSEL_TIM1_CC1: u32 = 0;
pub const ADC_CR2_EXTSEL_TIM1_CC2: u32 = 131072;
pub const ADC_CR2_EXTSEL_TIM1_CC3: u32 = 262144;
pub const ADC_CR2_EXTSEL_TIM2_CC2: u32 = 393216;
pub const ADC_CR2_EXTSEL_TIM3_TRGO: u32 = 524288;
pub const ADC_CR2_EXTSEL_TIM4_CC4: u32 = 655360;
pub const ADC_CR2_EXTSEL_EXTI11: u32 = 786432;
pub const ADC_CR2_EXTSEL_SWSTART: u32 = 917504;
pub const ADC_CR2_EXTTRIG: u32 = 1048576;
pub const ADC_CR2_JSWSTART: u32 = 2097152;
pub const ADC_CR2_SWSTART: u32 = 4194304;
pub const ADC_CR2_TSVREFE: u32 = 8388608;
pub const ADC_SR_AWD_BIT: u32 = 0;
pub const ADC_SR_EOC_BIT: u32 = 1;
pub const ADC_SR_JEOC_BIT: u32 = 2;
pub const ADC_SR_JSTRT_BIT: u32 = 3;
pub const ADC_SR_STRT_BIT: u32 = 4;
pub const ADC_CR1_EOCIE_BIT: u32 = 5;
pub const ADC_CR1_AWDIE_BIT: u32 = 6;
pub const ADC_CR1_JEOCIE_BIT: u32 = 7;
pub const ADC_CR1_SCAN_BIT: u32 = 8;
pub const ADC_CR1_AWDSGL_BIT: u32 = 9;
pub const ADC_CR1_JAUTO_BIT: u32 = 10;
pub const ADC_CR1_DISCEN_BIT: u32 = 11;
pub const ADC_CR1_JDISCEN_BIT: u32 = 12;
pub const ADC_CR1_JAWDEN_BIT: u32 = 22;
pub const ADC_CR1_AWDEN_BIT: u32 = 23;
pub const ADC_CR1_AWDCH: u32 = 31;
pub const ADC_CR1_DISCNUM: u32 = 57344;
pub const ADC_SMPR1_SMP17: u32 = 14680064;
pub const ADC_SMPR1_SMP16: u32 = 1835008;
pub const ADC_SMPR1_SMP15: u32 = 229376;
pub const ADC_SMPR1_SMP14: u32 = 28672;
pub const ADC_SMPR1_SMP13: u32 = 3584;
pub const ADC_SMPR1_SMP12: u32 = 448;
pub const ADC_SMPR1_SMP11: u32 = 56;
pub const ADC_SMPR1_SMP10: u32 = 7;
pub const ADC_SMPR2_SMP9: u32 = 939524096;
pub const ADC_SMPR2_SMP8: u32 = 117440512;
pub const ADC_SMPR2_SMP7: u32 = 14680064;
pub const ADC_SMPR2_SMP6: u32 = 1835008;
pub const ADC_SMPR2_SMP5: u32 = 229376;
pub const ADC_SMPR2_SMP4: u32 = 28672;
pub const ADC_SMPR2_SMP3: u32 = 3584;
pub const ADC_SMPR2_SMP2: u32 = 448;
pub const ADC_SMPR2_SMP1: u32 = 56;
pub const ADC_SMPR2_SMP0: u32 = 7;
pub const ADC_JOFR_JOFFSET: u32 = 1023;
pub const ADC_HTR_HT: u32 = 1023;
pub const ADC_LTR_LT: u32 = 1023;
pub const ADC_SQR1_L: u32 = 32505856;
pub const ADC_SQR1_SQ16: u32 = 1015808;
pub const ADC_SQR1_SQ15: u32 = 31744;
pub const ADC_SQR1_SQ14: u32 = 992;
pub const ADC_SQR1_SQ13: u32 = 31;
pub const ADC_SQR2_SQ12: u32 = 1040187392;
pub const ADC_SQR2_SQ11: u32 = 32505856;
pub const ADC_SQR2_SQ10: u32 = 2031616;
pub const ADC_SQR2_SQ9: u32 = 31744;
pub const ADC_SQR2_SQ8: u32 = 992;
pub const ADC_SQR2_SQ7: u32 = 31;
pub const ADC_SQR3_SQ6: u32 = 1040187392;
pub const ADC_SQR3_SQ5: u32 = 32505856;
pub const ADC_SQR3_SQ4: u32 = 2031616;
pub const ADC_SQR3_SQ3: u32 = 31744;
pub const ADC_SQR3_SQ2: u32 = 992;
pub const ADC_SQR3_SQ1: u32 = 31;
pub const ADC_JSQR_JL: u32 = 3145728;
pub const ADC_JSQR_JL_1CONV: u32 = 0;
pub const ADC_JSQR_JL_2CONV: u32 = 1048576;
pub const ADC_JSQR_JL_3CONV: u32 = 2097152;
pub const ADC_JSQR_JL_4CONV: u32 = 3145728;
pub const ADC_JSQR_JSQ4: u32 = 1015808;
pub const ADC_JSQR_JSQ3: u32 = 31744;
pub const ADC_JSQR_JSQ2: u32 = 992;
pub const ADC_JSQR_JSQ1: u32 = 31;
pub const ADC_JDR_JDATA: u32 = 65535;
pub const ADC_DR_ADC2DATA: u32 = 4294901760;
pub const ADC_DR_DATA: u32 = 65535;
pub const ADCx: u32 = 255;
pub const BOARD_NR_USARTS: u32 = 3;
pub const BOARD_USART1_TX_PIN: u32 = 26;
pub const BOARD_USART1_RX_PIN: u32 = 25;
pub const BOARD_USART2_TX_PIN: u32 = 9;
pub const BOARD_USART2_RX_PIN: u32 = 8;
pub const BOARD_USART3_TX_PIN: u32 = 1;
pub const BOARD_USART3_RX_PIN: u32 = 0;
pub const BOARD_NR_SPI: u32 = 2;
pub const BOARD_SPI1_NSS_PIN: u32 = 7;
pub const BOARD_SPI1_MOSI_PIN: u32 = 4;
pub const BOARD_SPI1_MISO_PIN: u32 = 5;
pub const BOARD_SPI1_SCK_PIN: u32 = 6;
pub const BOARD_SPI2_NSS_PIN: u32 = 31;
pub const BOARD_SPI2_MOSI_PIN: u32 = 28;
pub const BOARD_SPI2_MISO_PIN: u32 = 29;
pub const BOARD_SPI2_SCK_PIN: u32 = 30;
pub const BOARD_NR_GPIO_PINS: u32 = 34;
pub const BOARD_NR_PWM_PINS: u32 = 12;
pub const BOARD_NR_ADC_PINS: u32 = 9;
pub const BOARD_NR_USED_PINS: u32 = 4;
pub const BOARD_JTMS_SWDIO_PIN: u32 = 22;
pub const BOARD_JTCK_SWCLK_PIN: u32 = 21;
pub const BOARD_JTDI_PIN: u32 = 20;
pub const BOARD_JTDO_PIN: u32 = 19;
pub const BOARD_NJTRST_PIN: u32 = 18;
pub const BOARD_USB_DISC_BIT: u32 = 9;
pub const BOARD_HAVE_SERIALUSB: u32 = 1;
pub const HIGH: u32 = 1;
pub const LOW: u32 = 0;
pub const BIT0: u32 = 1;
pub const BIT1: u32 = 2;
pub const BIT2: u32 = 4;
pub const BIT3: u32 = 8;
pub const BIT4: u32 = 16;
pub const BIT5: u32 = 32;
pub const BIT6: u32 = 64;
pub const BIT7: u32 = 128;
pub const BIT8: u32 = 256;
pub const BIT9: u32 = 512;
pub const BIT10: u32 = 1024;
pub const BIT11: u32 = 2048;
pub const BIT12: u32 = 4096;
pub const BIT13: u32 = 8192;
pub const BIT14: u32 = 16384;
pub const BIT15: u32 = 32768;
pub const BIT16: u32 = 65536;
pub const BIT17: u32 = 131072;
pub const BIT18: u32 = 262144;
pub const BIT19: u32 = 524288;
pub const BIT20: u32 = 1048576;
pub const BIT21: u32 = 2097152;
pub const BIT22: u32 = 4194304;
pub const BIT23: u32 = 8388608;
pub const BIT24: u32 = 16777216;
pub const BIT25: u32 = 33554432;
pub const BIT26: u32 = 67108864;
pub const BIT27: u32 = 134217728;
pub const BIT28: u32 = 268435456;
pub const BIT29: u32 = 536870912;
pub const BIT30: u32 = 1073741824;
pub const BIT31: u32 = 2147483648;
pub const B0: u32 = 0;
pub const B00: u32 = 0;
pub const B000: u32 = 0;
pub const B0000: u32 = 0;
pub const B00000: u32 = 0;
pub const B000000: u32 = 0;
pub const B0000000: u32 = 0;
pub const B00000000: u32 = 0;
pub const B1: u32 = 1;
pub const B01: u32 = 1;
pub const B001: u32 = 1;
pub const B0001: u32 = 1;
pub const B00001: u32 = 1;
pub const B000001: u32 = 1;
pub const B0000001: u32 = 1;
pub const B00000001: u32 = 1;
pub const B10: u32 = 2;
pub const B010: u32 = 2;
pub const B0010: u32 = 2;
pub const B00010: u32 = 2;
pub const B000010: u32 = 2;
pub const B0000010: u32 = 2;
pub const B00000010: u32 = 2;
pub const B11: u32 = 3;
pub const B011: u32 = 3;
pub const B0011: u32 = 3;
pub const B00011: u32 = 3;
pub const B000011: u32 = 3;
pub const B0000011: u32 = 3;
pub const B00000011: u32 = 3;
pub const B100: u32 = 4;
pub const B0100: u32 = 4;
pub const B00100: u32 = 4;
pub const B000100: u32 = 4;
pub const B0000100: u32 = 4;
pub const B00000100: u32 = 4;
pub const B101: u32 = 5;
pub const B0101: u32 = 5;
pub const B00101: u32 = 5;
pub const B000101: u32 = 5;
pub const B0000101: u32 = 5;
pub const B00000101: u32 = 5;
pub const B110: u32 = 6;
pub const B0110: u32 = 6;
pub const B00110: u32 = 6;
pub const B000110: u32 = 6;
pub const B0000110: u32 = 6;
pub const B00000110: u32 = 6;
pub const B111: u32 = 7;
pub const B0111: u32 = 7;
pub const B00111: u32 = 7;
pub const B000111: u32 = 7;
pub const B0000111: u32 = 7;
pub const B00000111: u32 = 7;
pub const B1000: u32 = 8;
pub const B01000: u32 = 8;
pub const B001000: u32 = 8;
pub const B0001000: u32 = 8;
pub const B00001000: u32 = 8;
pub const B1001: u32 = 9;
pub const B01001: u32 = 9;
pub const B001001: u32 = 9;
pub const B0001001: u32 = 9;
pub const B00001001: u32 = 9;
pub const B1010: u32 = 10;
pub const B01010: u32 = 10;
pub const B001010: u32 = 10;
pub const B0001010: u32 = 10;
pub const B00001010: u32 = 10;
pub const B1011: u32 = 11;
pub const B01011: u32 = 11;
pub const B001011: u32 = 11;
pub const B0001011: u32 = 11;
pub const B00001011: u32 = 11;
pub const B1100: u32 = 12;
pub const B01100: u32 = 12;
pub const B001100: u32 = 12;
pub const B0001100: u32 = 12;
pub const B00001100: u32 = 12;
pub const B1101: u32 = 13;
pub const B01101: u32 = 13;
pub const B001101: u32 = 13;
pub const B0001101: u32 = 13;
pub const B00001101: u32 = 13;
pub const B1110: u32 = 14;
pub const B01110: u32 = 14;
pub const B001110: u32 = 14;
pub const B0001110: u32 = 14;
pub const B00001110: u32 = 14;
pub const B1111: u32 = 15;
pub const B01111: u32 = 15;
pub const B001111: u32 = 15;
pub const B0001111: u32 = 15;
pub const B00001111: u32 = 15;
pub const B10000: u32 = 16;
pub const B010000: u32 = 16;
pub const B0010000: u32 = 16;
pub const B00010000: u32 = 16;
pub const B10001: u32 = 17;
pub const B010001: u32 = 17;
pub const B0010001: u32 = 17;
pub const B00010001: u32 = 17;
pub const B10010: u32 = 18;
pub const B010010: u32 = 18;
pub const B0010010: u32 = 18;
pub const B00010010: u32 = 18;
pub const B10011: u32 = 19;
pub const B010011: u32 = 19;
pub const B0010011: u32 = 19;
pub const B00010011: u32 = 19;
pub const B10100: u32 = 20;
pub const B010100: u32 = 20;
pub const B0010100: u32 = 20;
pub const B00010100: u32 = 20;
pub const B10101: u32 = 21;
pub const B010101: u32 = 21;
pub const B0010101: u32 = 21;
pub const B00010101: u32 = 21;
pub const B10110: u32 = 22;
pub const B010110: u32 = 22;
pub const B0010110: u32 = 22;
pub const B00010110: u32 = 22;
pub const B10111: u32 = 23;
pub const B010111: u32 = 23;
pub const B0010111: u32 = 23;
pub const B00010111: u32 = 23;
pub const B11000: u32 = 24;
pub const B011000: u32 = 24;
pub const B0011000: u32 = 24;
pub const B00011000: u32 = 24;
pub const B11001: u32 = 25;
pub const B011001: u32 = 25;
pub const B0011001: u32 = 25;
pub const B00011001: u32 = 25;
pub const B11010: u32 = 26;
pub const B011010: u32 = 26;
pub const B0011010: u32 = 26;
pub const B00011010: u32 = 26;
pub const B11011: u32 = 27;
pub const B011011: u32 = 27;
pub const B0011011: u32 = 27;
pub const B00011011: u32 = 27;
pub const B11100: u32 = 28;
pub const B011100: u32 = 28;
pub const B0011100: u32 = 28;
pub const B00011100: u32 = 28;
pub const B11101: u32 = 29;
pub const B011101: u32 = 29;
pub const B0011101: u32 = 29;
pub const B00011101: u32 = 29;
pub const B11110: u32 = 30;
pub const B011110: u32 = 30;
pub const B0011110: u32 = 30;
pub const B00011110: u32 = 30;
pub const B11111: u32 = 31;
pub const B011111: u32 = 31;
pub const B0011111: u32 = 31;
pub const B00011111: u32 = 31;
pub const B100000: u32 = 32;
pub const B0100000: u32 = 32;
pub const B00100000: u32 = 32;
pub const B100001: u32 = 33;
pub const B0100001: u32 = 33;
pub const B00100001: u32 = 33;
pub const B100010: u32 = 34;
pub const B0100010: u32 = 34;
pub const B00100010: u32 = 34;
pub const B100011: u32 = 35;
pub const B0100011: u32 = 35;
pub const B00100011: u32 = 35;
pub const B100100: u32 = 36;
pub const B0100100: u32 = 36;
pub const B00100100: u32 = 36;
pub const B100101: u32 = 37;
pub const B0100101: u32 = 37;
pub const B00100101: u32 = 37;
pub const B100110: u32 = 38;
pub const B0100110: u32 = 38;
pub const B00100110: u32 = 38;
pub const B100111: u32 = 39;
pub const B0100111: u32 = 39;
pub const B00100111: u32 = 39;
pub const B101000: u32 = 40;
pub const B0101000: u32 = 40;
pub const B00101000: u32 = 40;
pub const B101001: u32 = 41;
pub const B0101001: u32 = 41;
pub const B00101001: u32 = 41;
pub const B101010: u32 = 42;
pub const B0101010: u32 = 42;
pub const B00101010: u32 = 42;
pub const B101011: u32 = 43;
pub const B0101011: u32 = 43;
pub const B00101011: u32 = 43;
pub const B101100: u32 = 44;
pub const B0101100: u32 = 44;
pub const B00101100: u32 = 44;
pub const B101101: u32 = 45;
pub const B0101101: u32 = 45;
pub const B00101101: u32 = 45;
pub const B101110: u32 = 46;
pub const B0101110: u32 = 46;
pub const B00101110: u32 = 46;
pub const B101111: u32 = 47;
pub const B0101111: u32 = 47;
pub const B00101111: u32 = 47;
pub const B110000: u32 = 48;
pub const B0110000: u32 = 48;
pub const B00110000: u32 = 48;
pub const B110001: u32 = 49;
pub const B0110001: u32 = 49;
pub const B00110001: u32 = 49;
pub const B110010: u32 = 50;
pub const B0110010: u32 = 50;
pub const B00110010: u32 = 50;
pub const B110011: u32 = 51;
pub const B0110011: u32 = 51;
pub const B00110011: u32 = 51;
pub const B110100: u32 = 52;
pub const B0110100: u32 = 52;
pub const B00110100: u32 = 52;
pub const B110101: u32 = 53;
pub const B0110101: u32 = 53;
pub const B00110101: u32 = 53;
pub const B110110: u32 = 54;
pub const B0110110: u32 = 54;
pub const B00110110: u32 = 54;
pub const B110111: u32 = 55;
pub const B0110111: u32 = 55;
pub const B00110111: u32 = 55;
pub const B111000: u32 = 56;
pub const B0111000: u32 = 56;
pub const B00111000: u32 = 56;
pub const B111001: u32 = 57;
pub const B0111001: u32 = 57;
pub const B00111001: u32 = 57;
pub const B111010: u32 = 58;
pub const B0111010: u32 = 58;
pub const B00111010: u32 = 58;
pub const B111011: u32 = 59;
pub const B0111011: u32 = 59;
pub const B00111011: u32 = 59;
pub const B111100: u32 = 60;
pub const B0111100: u32 = 60;
pub const B00111100: u32 = 60;
pub const B111101: u32 = 61;
pub const B0111101: u32 = 61;
pub const B00111101: u32 = 61;
pub const B111110: u32 = 62;
pub const B0111110: u32 = 62;
pub const B00111110: u32 = 62;
pub const B111111: u32 = 63;
pub const B0111111: u32 = 63;
pub const B00111111: u32 = 63;
pub const B1000000: u32 = 64;
pub const B01000000: u32 = 64;
pub const B1000001: u32 = 65;
pub const B01000001: u32 = 65;
pub const B1000010: u32 = 66;
pub const B01000010: u32 = 66;
pub const B1000011: u32 = 67;
pub const B01000011: u32 = 67;
pub const B1000100: u32 = 68;
pub const B01000100: u32 = 68;
pub const B1000101: u32 = 69;
pub const B01000101: u32 = 69;
pub const B1000110: u32 = 70;
pub const B01000110: u32 = 70;
pub const B1000111: u32 = 71;
pub const B01000111: u32 = 71;
pub const B1001000: u32 = 72;
pub const B01001000: u32 = 72;
pub const B1001001: u32 = 73;
pub const B01001001: u32 = 73;
pub const B1001010: u32 = 74;
pub const B01001010: u32 = 74;
pub const B1001011: u32 = 75;
pub const B01001011: u32 = 75;
pub const B1001100: u32 = 76;
pub const B01001100: u32 = 76;
pub const B1001101: u32 = 77;
pub const B01001101: u32 = 77;
pub const B1001110: u32 = 78;
pub const B01001110: u32 = 78;
pub const B1001111: u32 = 79;
pub const B01001111: u32 = 79;
pub const B1010000: u32 = 80;
pub const B01010000: u32 = 80;
pub const B1010001: u32 = 81;
pub const B01010001: u32 = 81;
pub const B1010010: u32 = 82;
pub const B01010010: u32 = 82;
pub const B1010011: u32 = 83;
pub const B01010011: u32 = 83;
pub const B1010100: u32 = 84;
pub const B01010100: u32 = 84;
pub const B1010101: u32 = 85;
pub const B01010101: u32 = 85;
pub const B1010110: u32 = 86;
pub const B01010110: u32 = 86;
pub const B1010111: u32 = 87;
pub const B01010111: u32 = 87;
pub const B1011000: u32 = 88;
pub const B01011000: u32 = 88;
pub const B1011001: u32 = 89;
pub const B01011001: u32 = 89;
pub const B1011010: u32 = 90;
pub const B01011010: u32 = 90;
pub const B1011011: u32 = 91;
pub const B01011011: u32 = 91;
pub const B1011100: u32 = 92;
pub const B01011100: u32 = 92;
pub const B1011101: u32 = 93;
pub const B01011101: u32 = 93;
pub const B1011110: u32 = 94;
pub const B01011110: u32 = 94;
pub const B1011111: u32 = 95;
pub const B01011111: u32 = 95;
pub const B1100000: u32 = 96;
pub const B01100000: u32 = 96;
pub const B1100001: u32 = 97;
pub const B01100001: u32 = 97;
pub const B1100010: u32 = 98;
pub const B01100010: u32 = 98;
pub const B1100011: u32 = 99;
pub const B01100011: u32 = 99;
pub const B1100100: u32 = 100;
pub const B01100100: u32 = 100;
pub const B1100101: u32 = 101;
pub const B01100101: u32 = 101;
pub const B1100110: u32 = 102;
pub const B01100110: u32 = 102;
pub const B1100111: u32 = 103;
pub const B01100111: u32 = 103;
pub const B1101000: u32 = 104;
pub const B01101000: u32 = 104;
pub const B1101001: u32 = 105;
pub const B01101001: u32 = 105;
pub const B1101010: u32 = 106;
pub const B01101010: u32 = 106;
pub const B1101011: u32 = 107;
pub const B01101011: u32 = 107;
pub const B1101100: u32 = 108;
pub const B01101100: u32 = 108;
pub const B1101101: u32 = 109;
pub const B01101101: u32 = 109;
pub const B1101110: u32 = 110;
pub const B01101110: u32 = 110;
pub const B1101111: u32 = 111;
pub const B01101111: u32 = 111;
pub const B1110000: u32 = 112;
pub const B01110000: u32 = 112;
pub const B1110001: u32 = 113;
pub const B01110001: u32 = 113;
pub const B1110010: u32 = 114;
pub const B01110010: u32 = 114;
pub const B1110011: u32 = 115;
pub const B01110011: u32 = 115;
pub const B1110100: u32 = 116;
pub const B01110100: u32 = 116;
pub const B1110101: u32 = 117;
pub const B01110101: u32 = 117;
pub const B1110110: u32 = 118;
pub const B01110110: u32 = 118;
pub const B1110111: u32 = 119;
pub const B01110111: u32 = 119;
pub const B1111000: u32 = 120;
pub const B01111000: u32 = 120;
pub const B1111001: u32 = 121;
pub const B01111001: u32 = 121;
pub const B1111010: u32 = 122;
pub const B01111010: u32 = 122;
pub const B1111011: u32 = 123;
pub const B01111011: u32 = 123;
pub const B1111100: u32 = 124;
pub const B01111100: u32 = 124;
pub const B1111101: u32 = 125;
pub const B01111101: u32 = 125;
pub const B1111110: u32 = 126;
pub const B01111110: u32 = 126;
pub const B1111111: u32 = 127;
pub const B01111111: u32 = 127;
pub const B10000000: u32 = 128;
pub const B10000001: u32 = 129;
pub const B10000010: u32 = 130;
pub const B10000011: u32 = 131;
pub const B10000100: u32 = 132;
pub const B10000101: u32 = 133;
pub const B10000110: u32 = 134;
pub const B10000111: u32 = 135;
pub const B10001000: u32 = 136;
pub const B10001001: u32 = 137;
pub const B10001010: u32 = 138;
pub const B10001011: u32 = 139;
pub const B10001100: u32 = 140;
pub const B10001101: u32 = 141;
pub const B10001110: u32 = 142;
pub const B10001111: u32 = 143;
pub const B10010000: u32 = 144;
pub const B10010001: u32 = 145;
pub const B10010010: u32 = 146;
pub const B10010011: u32 = 147;
pub const B10010100: u32 = 148;
pub const B10010101: u32 = 149;
pub const B10010110: u32 = 150;
pub const B10010111: u32 = 151;
pub const B10011000: u32 = 152;
pub const B10011001: u32 = 153;
pub const B10011010: u32 = 154;
pub const B10011011: u32 = 155;
pub const B10011100: u32 = 156;
pub const B10011101: u32 = 157;
pub const B10011110: u32 = 158;
pub const B10011111: u32 = 159;
pub const B10100000: u32 = 160;
pub const B10100001: u32 = 161;
pub const B10100010: u32 = 162;
pub const B10100011: u32 = 163;
pub const B10100100: u32 = 164;
pub const B10100101: u32 = 165;
pub const B10100110: u32 = 166;
pub const B10100111: u32 = 167;
pub const B10101000: u32 = 168;
pub const B10101001: u32 = 169;
pub const B10101010: u32 = 170;
pub const B10101011: u32 = 171;
pub const B10101100: u32 = 172;
pub const B10101101: u32 = 173;
pub const B10101110: u32 = 174;
pub const B10101111: u32 = 175;
pub const B10110000: u32 = 176;
pub const B10110001: u32 = 177;
pub const B10110010: u32 = 178;
pub const B10110011: u32 = 179;
pub const B10110100: u32 = 180;
pub const B10110101: u32 = 181;
pub const B10110110: u32 = 182;
pub const B10110111: u32 = 183;
pub const B10111000: u32 = 184;
pub const B10111001: u32 = 185;
pub const B10111010: u32 = 186;
pub const B10111011: u32 = 187;
pub const B10111100: u32 = 188;
pub const B10111101: u32 = 189;
pub const B10111110: u32 = 190;
pub const B10111111: u32 = 191;
pub const B11000000: u32 = 192;
pub const B11000001: u32 = 193;
pub const B11000010: u32 = 194;
pub const B11000011: u32 = 195;
pub const B11000100: u32 = 196;
pub const B11000101: u32 = 197;
pub const B11000110: u32 = 198;
pub const B11000111: u32 = 199;
pub const B11001000: u32 = 200;
pub const B11001001: u32 = 201;
pub const B11001010: u32 = 202;
pub const B11001011: u32 = 203;
pub const B11001100: u32 = 204;
pub const B11001101: u32 = 205;
pub const B11001110: u32 = 206;
pub const B11001111: u32 = 207;
pub const B11010000: u32 = 208;
pub const B11010001: u32 = 209;
pub const B11010010: u32 = 210;
pub const B11010011: u32 = 211;
pub const B11010100: u32 = 212;
pub const B11010101: u32 = 213;
pub const B11010110: u32 = 214;
pub const B11010111: u32 = 215;
pub const B11011000: u32 = 216;
pub const B11011001: u32 = 217;
pub const B11011010: u32 = 218;
pub const B11011011: u32 = 219;
pub const B11011100: u32 = 220;
pub const B11011101: u32 = 221;
pub const B11011110: u32 = 222;
pub const B11011111: u32 = 223;
pub const B11100000: u32 = 224;
pub const B11100001: u32 = 225;
pub const B11100010: u32 = 226;
pub const B11100011: u32 = 227;
pub const B11100100: u32 = 228;
pub const B11100101: u32 = 229;
pub const B11100110: u32 = 230;
pub const B11100111: u32 = 231;
pub const B11101000: u32 = 232;
pub const B11101001: u32 = 233;
pub const B11101010: u32 = 234;
pub const B11101011: u32 = 235;
pub const B11101100: u32 = 236;
pub const B11101101: u32 = 237;
pub const B11101110: u32 = 238;
pub const B11101111: u32 = 239;
pub const B11110000: u32 = 240;
pub const B11110001: u32 = 241;
pub const B11110010: u32 = 242;
pub const B11110011: u32 = 243;
pub const B11110100: u32 = 244;
pub const B11110101: u32 = 245;
pub const B11110110: u32 = 246;
pub const B11110111: u32 = 247;
pub const B11111000: u32 = 248;
pub const B11111001: u32 = 249;
pub const B11111010: u32 = 250;
pub const B11111011: u32 = 251;
pub const B11111100: u32 = 252;
pub const B11111101: u32 = 253;
pub const B11111110: u32 = 254;
pub const B11111111: u32 = 255;
pub const _GLIBCXX_MATH_H: u32 = 1;
pub const _CPP_TYPE_TRAITS_H: u32 = 1;
pub const _EXT_TYPE_TRAITS: u32 = 1;
pub const _M_LN2: f64 = 0.6931471805599453;
pub const MATH_ERRNO: u32 = 1;
pub const MATH_ERREXCEPT: u32 = 2;
pub const math_errhandling: u32 = 1;
pub const DOMAIN: u32 = 1;
pub const SING: u32 = 2;
pub const OVERFLOW: u32 = 3;
pub const UNDERFLOW: u32 = 4;
pub const TLOSS: u32 = 5;
pub const PLOSS: u32 = 6;
pub const M_E: f64 = 2.718281828459045;
pub const M_LOG2E: f64 = 1.4426950408889634;
pub const M_LOG10E: f64 = 0.4342944819032518;
pub const M_LN2: f64 = 0.6931471805599453;
pub const M_LN10: f64 = 2.302585092994046;
pub const M_PI: f64 = 3.141592653589793;
pub const M_PI_2: f64 = 1.5707963267948966;
pub const M_PI_4: f64 = 0.7853981633974483;
pub const M_1_PI: f64 = 0.3183098861837907;
pub const M_2_PI: f64 = 0.6366197723675814;
pub const M_2_SQRTPI: f64 = 1.1283791670955126;
pub const M_SQRT2: f64 = 1.4142135623730951;
pub const M_SQRT1_2: f64 = 0.7071067811865476;
pub const M_TWOPI: f64 = 6.283185307179586;
pub const M_SQRTPI: f64 = 1.772453850905516;
pub const M_SQRT3: f64 = 1.7320508075688772;
pub const M_IVLN10: f64 = 0.4342944819032518;
pub const M_LOG2_E: f64 = 0.6931471805599453;
pub const _GLIBCXX_CMATH: u32 = 1;
pub const PI: f64 = 3.141592653589793;
pub const HALF_PI: f64 = 1.5707963267948966;
pub const TWO_PI: f64 = 6.283185307179586;
pub const DEG_TO_RAD: f64 = 0.017453292519943295;
pub const RAD_TO_DEG: f64 = 57.29577951308232;
pub const EULER: f64 = 2.718281828459045;
pub const SERIAL: u32 = 0;
pub const DISPLAY: u32 = 1;
pub const SYSTICK_CSR_CLKSOURCE_EXTERNAL: u32 = 0;
pub const SYSTICK_CSR_TICKINT_NO_PEND: u32 = 0;
pub const SYSTICK_CSR_ENABLE_DISABLED: u32 = 0;
pub const SYSTICK_CVR_TENMS: u32 = 16777215;
pub const US_PER_MS: u32 = 1000;
pub const SERIAL_TX_BUFFER_SIZE: u32 = 16;
pub const SERIAL_RX_BUFFER_SIZE: u32 = 16;
pub const SERIAL_8N1: u32 = 0;
pub const SERIAL_8N2: u32 = 32;
pub const SERIAL_9N1: u32 = 8;
pub const SERIAL_9N2: u32 = 40;
pub const SERIAL_8E1: u32 = 10;
pub const SERIAL_8E2: u32 = 42;
pub const SERIAL_8O1: u32 = 11;
pub const SERIAL_8O2: u32 = 43;
pub type __gnu_cxx___conditional_type___type<_Iftrue> = _Iftrue;
#[repr(C)]
pub struct __gnu_cxx___add_unsigned {
    pub _address: u8,
}
pub type __gnu_cxx___add_unsigned___if_type = u8;
pub type __gnu_cxx___add_unsigned___type = __gnu_cxx___add_unsigned___if_type;
#[test]
fn __bindgen_test_layout___gnu_cxx___add_unsigned_open0_char_close0_instantiation() {
    assert_eq!(
        ::core::mem::size_of::<__gnu_cxx___add_unsigned>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(__gnu_cxx___add_unsigned)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<__gnu_cxx___add_unsigned>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(__gnu_cxx___add_unsigned)
        )
    );
}
#[test]
fn __bindgen_test_layout___gnu_cxx___add_unsigned_open0_signed_char_close0_instantiation() {
    assert_eq!(
        ::core::mem::size_of::<__gnu_cxx___add_unsigned>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(__gnu_cxx___add_unsigned)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<__gnu_cxx___add_unsigned>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(__gnu_cxx___add_unsigned)
        )
    );
}
#[test]
fn __bindgen_test_layout___gnu_cxx___add_unsigned_open0_short_close0_instantiation() {
    assert_eq!(
        ::core::mem::size_of::<__gnu_cxx___add_unsigned>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(__gnu_cxx___add_unsigned)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<__gnu_cxx___add_unsigned>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(__gnu_cxx___add_unsigned)
        )
    );
}
#[test]
fn __bindgen_test_layout___gnu_cxx___add_unsigned_open0_int_close0_instantiation() {
    assert_eq!(
        ::core::mem::size_of::<__gnu_cxx___add_unsigned>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(__gnu_cxx___add_unsigned)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<__gnu_cxx___add_unsigned>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(__gnu_cxx___add_unsigned)
        )
    );
}
#[test]
fn __bindgen_test_layout___gnu_cxx___add_unsigned_open0_long_close0_instantiation() {
    assert_eq!(
        ::core::mem::size_of::<__gnu_cxx___add_unsigned>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(__gnu_cxx___add_unsigned)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<__gnu_cxx___add_unsigned>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(__gnu_cxx___add_unsigned)
        )
    );
}
#[test]
fn __bindgen_test_layout___gnu_cxx___add_unsigned_open0_long_long_close0_instantiation() {
    assert_eq!(
        ::core::mem::size_of::<__gnu_cxx___add_unsigned>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(__gnu_cxx___add_unsigned)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<__gnu_cxx___add_unsigned>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(__gnu_cxx___add_unsigned)
        )
    );
}
#[repr(C)]
pub struct __gnu_cxx___remove_unsigned {
    pub _address: u8,
}
pub type __gnu_cxx___remove_unsigned___if_type = u8;
pub type __gnu_cxx___remove_unsigned___type = __gnu_cxx___remove_unsigned___if_type;
#[test]
fn __bindgen_test_layout___gnu_cxx___remove_unsigned_open0_char_close0_instantiation() {
    assert_eq!(
        ::core::mem::size_of::<__gnu_cxx___remove_unsigned>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(__gnu_cxx___remove_unsigned)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<__gnu_cxx___remove_unsigned>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(__gnu_cxx___remove_unsigned)
        )
    );
}
#[test]
fn __bindgen_test_layout___gnu_cxx___remove_unsigned_open0_unsigned_char_close0_instantiation() {
    assert_eq!(
        ::core::mem::size_of::<__gnu_cxx___remove_unsigned>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(__gnu_cxx___remove_unsigned)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<__gnu_cxx___remove_unsigned>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(__gnu_cxx___remove_unsigned)
        )
    );
}
#[test]
fn __bindgen_test_layout___gnu_cxx___remove_unsigned_open0_unsigned_short_close0_instantiation() {
    assert_eq!(
        ::core::mem::size_of::<__gnu_cxx___remove_unsigned>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(__gnu_cxx___remove_unsigned)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<__gnu_cxx___remove_unsigned>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(__gnu_cxx___remove_unsigned)
        )
    );
}
#[test]
fn __bindgen_test_layout___gnu_cxx___remove_unsigned_open0_unsigned_int_close0_instantiation() {
    assert_eq!(
        ::core::mem::size_of::<__gnu_cxx___remove_unsigned>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(__gnu_cxx___remove_unsigned)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<__gnu_cxx___remove_unsigned>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(__gnu_cxx___remove_unsigned)
        )
    );
}
#[test]
fn __bindgen_test_layout___gnu_cxx___remove_unsigned_open0_unsigned_long_close0_instantiation() {
    assert_eq!(
        ::core::mem::size_of::<__gnu_cxx___remove_unsigned>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(__gnu_cxx___remove_unsigned)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<__gnu_cxx___remove_unsigned>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(__gnu_cxx___remove_unsigned)
        )
    );
}
#[test]
fn __bindgen_test_layout___gnu_cxx___remove_unsigned_open0_unsigned_long_long_close0_instantiation()
{
    assert_eq!(
        ::core::mem::size_of::<__gnu_cxx___remove_unsigned>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(__gnu_cxx___remove_unsigned)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<__gnu_cxx___remove_unsigned>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(__gnu_cxx___remove_unsigned)
        )
    );
}
pub type __gnu_cxx___promote___type = f64;
#[repr(C)]
pub struct __gnu_cxx___promote_2 {
    pub _address: u8,
}
pub type __gnu_cxx___promote_2___type<_Tp2> = _Tp2;
#[repr(C)]
pub struct __gnu_cxx___promote_3 {
    pub _address: u8,
}
pub type __gnu_cxx___promote_3___type<_Tp2> = _Tp2;
#[repr(C)]
pub struct __gnu_cxx___promote_4 {
    pub _address: u8,
}
pub type __gnu_cxx___promote_4___type<_Tp2> = _Tp2;
pub type size_t = super::c_uint;
#[repr(C)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: super::c_longlong,
    pub __clang_max_align_nonce2: f64,
}
#[test]
fn bindgen_test_layout_max_align_t() {
    assert_eq!(
        ::core::mem::size_of::<max_align_t>(),
        16usize,
        concat!("Size of: ", stringify!(max_align_t))
    );
    assert_eq!(
        ::core::mem::align_of::<max_align_t>(),
        8usize,
        concat!("Alignment of ", stringify!(max_align_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<max_align_t>())).__clang_max_align_nonce1 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<max_align_t>())).__clang_max_align_nonce2 as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce2)
        )
    );
}
pub type __int8_t = super::c_schar;
pub type __uint8_t = super::c_uchar;
pub type __int16_t = super::c_short;
pub type __uint16_t = super::c_ushort;
pub type __int32_t = super::c_int;
pub type __uint32_t = super::c_uint;
pub type __int64_t = super::c_longlong;
pub type __uint64_t = super::c_ulonglong;
pub type __int_least8_t = super::c_schar;
pub type __uint_least8_t = super::c_uchar;
pub type __int_least16_t = super::c_short;
pub type __uint_least16_t = super::c_ushort;
pub type __int_least32_t = super::c_int;
pub type __uint_least32_t = super::c_uint;
pub type __int_least64_t = super::c_longlong;
pub type __uint_least64_t = super::c_ulonglong;
pub type __intmax_t = super::c_longlong;
pub type __uintmax_t = super::c_ulonglong;
pub type __intptr_t = super::c_int;
pub type __uintptr_t = super::c_uint;
#[repr(C)]
pub struct __lock {
    _unused: [u8; 0],
}
pub type _LOCK_T = *mut __lock;
extern "C" {
    pub fn __retarget_lock_init(lock: *mut _LOCK_T);
}
extern "C" {
    pub fn __retarget_lock_init_recursive(lock: *mut _LOCK_T);
}
extern "C" {
    pub fn __retarget_lock_close(lock: _LOCK_T);
}
extern "C" {
    pub fn __retarget_lock_close_recursive(lock: _LOCK_T);
}
extern "C" {
    pub fn __retarget_lock_acquire(lock: _LOCK_T);
}
extern "C" {
    pub fn __retarget_lock_acquire_recursive(lock: _LOCK_T);
}
extern "C" {
    pub fn __retarget_lock_try_acquire(lock: _LOCK_T) -> super::c_int;
}
extern "C" {
    pub fn __retarget_lock_try_acquire_recursive(lock: _LOCK_T) -> super::c_int;
}
extern "C" {
    pub fn __retarget_lock_release(lock: _LOCK_T);
}
extern "C" {
    pub fn __retarget_lock_release_recursive(lock: _LOCK_T);
}
pub type __blkcnt_t = super::c_long;
pub type __blksize_t = super::c_long;
pub type __fsblkcnt_t = __uint64_t;
pub type __fsfilcnt_t = __uint32_t;
pub type _off_t = super::c_long;
pub type __pid_t = super::c_int;
pub type __dev_t = super::c_short;
pub type __uid_t = super::c_ushort;
pub type __gid_t = super::c_ushort;
pub type __id_t = __uint32_t;
pub type __ino_t = super::c_ushort;
pub type __mode_t = __uint32_t;
pub type _off64_t = super::c_longlong;
pub type __off_t = _off_t;
pub type __loff_t = _off64_t;
pub type __key_t = super::c_long;
pub type _fpos_t = super::c_long;
pub type __size_t = super::c_uint;
pub type _ssize_t = super::c_int;
pub type __ssize_t = _ssize_t;
pub type wint_t = super::c_int;
#[repr(C)]
pub struct _mbstate_t {
    pub __count: super::c_int,
    pub __value: _mbstate_t__bindgen_ty_1,
}
#[repr(C)]
pub struct _mbstate_t__bindgen_ty_1 {
    pub __wch: __BindgenUnionField<wint_t>,
    pub __wchb: __BindgenUnionField<[super::c_uchar; 4usize]>,
    pub bindgen_union_field: u32,
}
#[test]
fn bindgen_test_layout__mbstate_t__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<_mbstate_t__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(_mbstate_t__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<_mbstate_t__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(_mbstate_t__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_mbstate_t__bindgen_ty_1>())).__wch as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_mbstate_t__bindgen_ty_1),
            "::",
            stringify!(__wch)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_mbstate_t__bindgen_ty_1>())).__wchb as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_mbstate_t__bindgen_ty_1),
            "::",
            stringify!(__wchb)
        )
    );
}
#[test]
fn bindgen_test_layout__mbstate_t() {
    assert_eq!(
        ::core::mem::size_of::<_mbstate_t>(),
        8usize,
        concat!("Size of: ", stringify!(_mbstate_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_mbstate_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_mbstate_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_mbstate_t>())).__count as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_mbstate_t),
            "::",
            stringify!(__count)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_mbstate_t>())).__value as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_mbstate_t),
            "::",
            stringify!(__value)
        )
    );
}
pub type _flock_t = _LOCK_T;
pub type _iconv_t = *mut super::c_void;
pub type __clock_t = super::c_ulong;
pub type __time_t = __int_least64_t;
pub type __clockid_t = super::c_ulong;
pub type __timer_t = super::c_ulong;
pub type __sa_family_t = __uint8_t;
pub type __socklen_t = __uint32_t;
pub type __nlink_t = super::c_ushort;
pub type __suseconds_t = super::c_long;
pub type __useconds_t = super::c_ulong;
pub type __ULong = super::c_ulong;
#[repr(C)]
pub struct __locale_t {
    _unused: [u8; 0],
}
#[repr(C)]
pub struct _Bigint {
    pub _next: *mut _Bigint,
    pub _k: super::c_int,
    pub _maxwds: super::c_int,
    pub _sign: super::c_int,
    pub _wds: super::c_int,
    pub _x: [__ULong; 1usize],
}
#[test]
fn bindgen_test_layout__Bigint() {
    assert_eq!(
        ::core::mem::size_of::<_Bigint>(),
        24usize,
        concat!("Size of: ", stringify!(_Bigint))
    );
    assert_eq!(
        ::core::mem::align_of::<_Bigint>(),
        4usize,
        concat!("Alignment of ", stringify!(_Bigint))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_Bigint>()))._next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_Bigint),
            "::",
            stringify!(_next)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_Bigint>()))._k as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_Bigint),
            "::",
            stringify!(_k)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_Bigint>()))._maxwds as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_Bigint),
            "::",
            stringify!(_maxwds)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_Bigint>()))._sign as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_Bigint),
            "::",
            stringify!(_sign)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_Bigint>()))._wds as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_Bigint),
            "::",
            stringify!(_wds)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_Bigint>()))._x as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_Bigint),
            "::",
            stringify!(_x)
        )
    );
}
#[repr(C)]
pub struct __tm {
    pub __tm_sec: super::c_int,
    pub __tm_min: super::c_int,
    pub __tm_hour: super::c_int,
    pub __tm_mday: super::c_int,
    pub __tm_mon: super::c_int,
    pub __tm_year: super::c_int,
    pub __tm_wday: super::c_int,
    pub __tm_yday: super::c_int,
    pub __tm_isdst: super::c_int,
}
#[test]
fn bindgen_test_layout___tm() {
    assert_eq!(
        ::core::mem::size_of::<__tm>(),
        36usize,
        concat!("Size of: ", stringify!(__tm))
    );
    assert_eq!(
        ::core::mem::align_of::<__tm>(),
        4usize,
        concat!("Alignment of ", stringify!(__tm))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__tm>())).__tm_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__tm),
            "::",
            stringify!(__tm_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__tm>())).__tm_min as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__tm),
            "::",
            stringify!(__tm_min)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__tm>())).__tm_hour as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__tm),
            "::",
            stringify!(__tm_hour)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__tm>())).__tm_mday as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__tm),
            "::",
            stringify!(__tm_mday)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__tm>())).__tm_mon as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__tm),
            "::",
            stringify!(__tm_mon)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__tm>())).__tm_year as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__tm),
            "::",
            stringify!(__tm_year)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__tm>())).__tm_wday as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__tm),
            "::",
            stringify!(__tm_wday)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__tm>())).__tm_yday as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(__tm),
            "::",
            stringify!(__tm_yday)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__tm>())).__tm_isdst as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__tm),
            "::",
            stringify!(__tm_isdst)
        )
    );
}
#[repr(C)]
pub struct _on_exit_args {
    pub _fnargs: [*mut super::c_void; 32usize],
    pub _dso_handle: [*mut super::c_void; 32usize],
    pub _fntypes: __ULong,
    pub _is_cxa: __ULong,
}
#[test]
fn bindgen_test_layout__on_exit_args() {
    assert_eq!(
        ::core::mem::size_of::<_on_exit_args>(),
        264usize,
        concat!("Size of: ", stringify!(_on_exit_args))
    );
    assert_eq!(
        ::core::mem::align_of::<_on_exit_args>(),
        4usize,
        concat!("Alignment of ", stringify!(_on_exit_args))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_on_exit_args>()))._fnargs as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_on_exit_args),
            "::",
            stringify!(_fnargs)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_on_exit_args>()))._dso_handle as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_on_exit_args),
            "::",
            stringify!(_dso_handle)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_on_exit_args>()))._fntypes as *const _ as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(_on_exit_args),
            "::",
            stringify!(_fntypes)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_on_exit_args>()))._is_cxa as *const _ as usize },
        260usize,
        concat!(
            "Offset of field: ",
            stringify!(_on_exit_args),
            "::",
            stringify!(_is_cxa)
        )
    );
}
#[repr(C)]
pub struct _atexit {
    pub _next: *mut _atexit,
    pub _ind: super::c_int,
    pub _fns: [::core::option::Option<unsafe extern "C" fn()>; 32usize],
    pub _on_exit_args: _on_exit_args,
}
#[test]
fn bindgen_test_layout__atexit() {
    assert_eq!(
        ::core::mem::size_of::<_atexit>(),
        400usize,
        concat!("Size of: ", stringify!(_atexit))
    );
    assert_eq!(
        ::core::mem::align_of::<_atexit>(),
        4usize,
        concat!("Alignment of ", stringify!(_atexit))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_atexit>()))._next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_atexit),
            "::",
            stringify!(_next)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_atexit>()))._ind as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_atexit),
            "::",
            stringify!(_ind)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_atexit>()))._fns as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_atexit),
            "::",
            stringify!(_fns)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_atexit>()))._on_exit_args as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_atexit),
            "::",
            stringify!(_on_exit_args)
        )
    );
}
#[repr(C)]
pub struct __sbuf {
    pub _base: *mut super::c_uchar,
    pub _size: super::c_int,
}
#[test]
fn bindgen_test_layout___sbuf() {
    assert_eq!(
        ::core::mem::size_of::<__sbuf>(),
        8usize,
        concat!("Size of: ", stringify!(__sbuf))
    );
    assert_eq!(
        ::core::mem::align_of::<__sbuf>(),
        4usize,
        concat!("Alignment of ", stringify!(__sbuf))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__sbuf>()))._base as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sbuf),
            "::",
            stringify!(_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__sbuf>()))._size as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__sbuf),
            "::",
            stringify!(_size)
        )
    );
}
#[repr(C)]
pub struct __sFILE {
    pub _p: *mut super::c_uchar,
    pub _r: super::c_int,
    pub _w: super::c_int,
    pub _flags: super::c_short,
    pub _file: super::c_short,
    pub _bf: __sbuf,
    pub _lbfsize: super::c_int,
    pub _cookie: *mut super::c_void,
    pub _read: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _reent,
            arg2: *mut super::c_void,
            arg3: *mut super::c_char,
            arg4: super::c_int,
        ) -> super::c_int,
    >,
    pub _write: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _reent,
            arg2: *mut super::c_void,
            arg3: *const super::c_char,
            arg4: super::c_int,
        ) -> super::c_int,
    >,
    pub _seek: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _reent,
            arg2: *mut super::c_void,
            arg3: _fpos_t,
            arg4: super::c_int,
        ) -> _fpos_t,
    >,
    pub _close: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut _reent, arg2: *mut super::c_void) -> super::c_int,
    >,
    pub _ub: __sbuf,
    pub _up: *mut super::c_uchar,
    pub _ur: super::c_int,
    pub _ubuf: [super::c_uchar; 3usize],
    pub _nbuf: [super::c_uchar; 1usize],
    pub _lb: __sbuf,
    pub _blksize: super::c_int,
    pub _offset: _off_t,
    pub _data: *mut _reent,
    pub _lock: _flock_t,
    pub _mbstate: _mbstate_t,
    pub _flags2: super::c_int,
}
#[test]
fn bindgen_test_layout___sFILE() {
    assert_eq!(
        ::core::mem::size_of::<__sFILE>(),
        104usize,
        concat!("Size of: ", stringify!(__sFILE))
    );
    assert_eq!(
        ::core::mem::align_of::<__sFILE>(),
        4usize,
        concat!("Alignment of ", stringify!(__sFILE))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__sFILE>()))._p as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_p)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__sFILE>()))._r as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_r)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__sFILE>()))._w as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_w)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__sFILE>()))._flags as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__sFILE>()))._file as *const _ as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_file)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__sFILE>()))._bf as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_bf)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__sFILE>()))._lbfsize as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_lbfsize)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__sFILE>()))._cookie as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_cookie)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__sFILE>()))._read as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_read)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__sFILE>()))._write as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_write)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__sFILE>()))._seek as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_seek)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__sFILE>()))._close as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_close)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__sFILE>()))._ub as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_ub)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__sFILE>()))._up as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_up)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__sFILE>()))._ur as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_ur)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__sFILE>()))._ubuf as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_ubuf)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__sFILE>()))._nbuf as *const _ as usize },
        67usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_nbuf)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__sFILE>()))._lb as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_lb)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__sFILE>()))._blksize as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_blksize)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__sFILE>()))._offset as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__sFILE>()))._data as *const _ as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__sFILE>()))._lock as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__sFILE>()))._mbstate as *const _ as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_mbstate)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__sFILE>()))._flags2 as *const _ as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_flags2)
        )
    );
}
pub type __FILE = __sFILE;
#[repr(C)]
pub struct _glue {
    pub _next: *mut _glue,
    pub _niobs: super::c_int,
    pub _iobs: *mut __FILE,
}
#[test]
fn bindgen_test_layout__glue() {
    assert_eq!(
        ::core::mem::size_of::<_glue>(),
        12usize,
        concat!("Size of: ", stringify!(_glue))
    );
    assert_eq!(
        ::core::mem::align_of::<_glue>(),
        4usize,
        concat!("Alignment of ", stringify!(_glue))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_glue>()))._next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_glue),
            "::",
            stringify!(_next)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_glue>()))._niobs as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_glue),
            "::",
            stringify!(_niobs)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_glue>()))._iobs as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_glue),
            "::",
            stringify!(_iobs)
        )
    );
}
#[repr(C)]
pub struct _rand48 {
    pub _seed: [super::c_ushort; 3usize],
    pub _mult: [super::c_ushort; 3usize],
    pub _add: super::c_ushort,
}
#[test]
fn bindgen_test_layout__rand48() {
    assert_eq!(
        ::core::mem::size_of::<_rand48>(),
        14usize,
        concat!("Size of: ", stringify!(_rand48))
    );
    assert_eq!(
        ::core::mem::align_of::<_rand48>(),
        2usize,
        concat!("Alignment of ", stringify!(_rand48))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_rand48>()))._seed as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_rand48),
            "::",
            stringify!(_seed)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_rand48>()))._mult as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(_rand48),
            "::",
            stringify!(_mult)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_rand48>()))._add as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_rand48),
            "::",
            stringify!(_add)
        )
    );
}
#[repr(C)]
pub struct _reent {
    pub _errno: super::c_int,
    pub _stdin: *mut __FILE,
    pub _stdout: *mut __FILE,
    pub _stderr: *mut __FILE,
    pub _inc: super::c_int,
    pub _emergency: [super::c_char; 25usize],
    pub _unspecified_locale_info: super::c_int,
    pub _locale: *mut __locale_t,
    pub __sdidinit: super::c_int,
    pub __cleanup: ::core::option::Option<unsafe extern "C" fn(arg1: *mut _reent)>,
    pub _result: *mut _Bigint,
    pub _result_k: super::c_int,
    pub _p5s: *mut _Bigint,
    pub _freelist: *mut *mut _Bigint,
    pub _cvtlen: super::c_int,
    pub _cvtbuf: *mut super::c_char,
    pub _new: _reent__bindgen_ty_1,
    pub _atexit: *mut _atexit,
    pub _atexit0: _atexit,
    pub _sig_func: *mut ::core::option::Option<unsafe extern "C" fn(arg1: super::c_int)>,
    pub __sglue: _glue,
    pub __sf: [__FILE; 3usize],
}
#[repr(C)]
pub struct _reent__bindgen_ty_1 {
    pub _reent: __BindgenUnionField<_reent__bindgen_ty_1__bindgen_ty_1>,
    pub _unused: __BindgenUnionField<_reent__bindgen_ty_1__bindgen_ty_2>,
    pub bindgen_union_field: [u64; 30usize],
}
#[repr(C)]
pub struct _reent__bindgen_ty_1__bindgen_ty_1 {
    pub _unused_rand: super::c_uint,
    pub _strtok_last: *mut super::c_char,
    pub _asctime_buf: [super::c_char; 26usize],
    pub _localtime_buf: __tm,
    pub _gamma_signgam: super::c_int,
    pub _rand_next: super::c_ulonglong,
    pub _r48: _rand48,
    pub _mblen_state: _mbstate_t,
    pub _mbtowc_state: _mbstate_t,
    pub _wctomb_state: _mbstate_t,
    pub _l64a_buf: [super::c_char; 8usize],
    pub _signal_buf: [super::c_char; 24usize],
    pub _getdate_err: super::c_int,
    pub _mbrlen_state: _mbstate_t,
    pub _mbrtowc_state: _mbstate_t,
    pub _mbsrtowcs_state: _mbstate_t,
    pub _wcrtomb_state: _mbstate_t,
    pub _wcsrtombs_state: _mbstate_t,
    pub _h_errno: super::c_int,
}
#[test]
fn bindgen_test_layout__reent__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<_reent__bindgen_ty_1__bindgen_ty_1>(),
        208usize,
        concat!("Size of: ", stringify!(_reent__bindgen_ty_1__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<_reent__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_reent__bindgen_ty_1__bindgen_ty_1>()))._unused_rand as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_unused_rand)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_reent__bindgen_ty_1__bindgen_ty_1>()))._strtok_last as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_strtok_last)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_reent__bindgen_ty_1__bindgen_ty_1>()))._asctime_buf as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_asctime_buf)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_reent__bindgen_ty_1__bindgen_ty_1>()))._localtime_buf
                as *const _ as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_localtime_buf)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_reent__bindgen_ty_1__bindgen_ty_1>()))._gamma_signgam
                as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_gamma_signgam)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_reent__bindgen_ty_1__bindgen_ty_1>()))._rand_next as *const _
                as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_rand_next)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_reent__bindgen_ty_1__bindgen_ty_1>()))._r48 as *const _
                as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_r48)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_reent__bindgen_ty_1__bindgen_ty_1>()))._mblen_state as *const _
                as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_mblen_state)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_reent__bindgen_ty_1__bindgen_ty_1>()))._mbtowc_state
                as *const _ as usize
        },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_mbtowc_state)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_reent__bindgen_ty_1__bindgen_ty_1>()))._wctomb_state
                as *const _ as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_wctomb_state)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_reent__bindgen_ty_1__bindgen_ty_1>()))._l64a_buf as *const _
                as usize
        },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_l64a_buf)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_reent__bindgen_ty_1__bindgen_ty_1>()))._signal_buf as *const _
                as usize
        },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_signal_buf)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_reent__bindgen_ty_1__bindgen_ty_1>()))._getdate_err as *const _
                as usize
        },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_getdate_err)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_reent__bindgen_ty_1__bindgen_ty_1>()))._mbrlen_state
                as *const _ as usize
        },
        164usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_mbrlen_state)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_reent__bindgen_ty_1__bindgen_ty_1>()))._mbrtowc_state
                as *const _ as usize
        },
        172usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_mbrtowc_state)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_reent__bindgen_ty_1__bindgen_ty_1>()))._mbsrtowcs_state
                as *const _ as usize
        },
        180usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_mbsrtowcs_state)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_reent__bindgen_ty_1__bindgen_ty_1>()))._wcrtomb_state
                as *const _ as usize
        },
        188usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_wcrtomb_state)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_reent__bindgen_ty_1__bindgen_ty_1>()))._wcsrtombs_state
                as *const _ as usize
        },
        196usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_wcsrtombs_state)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_reent__bindgen_ty_1__bindgen_ty_1>()))._h_errno as *const _
                as usize
        },
        204usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_h_errno)
        )
    );
}
#[repr(C)]
pub struct _reent__bindgen_ty_1__bindgen_ty_2 {
    pub _nextf: [*mut super::c_uchar; 30usize],
    pub _nmalloc: [super::c_uint; 30usize],
}
#[test]
fn bindgen_test_layout__reent__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<_reent__bindgen_ty_1__bindgen_ty_2>(),
        240usize,
        concat!("Size of: ", stringify!(_reent__bindgen_ty_1__bindgen_ty_2))
    );
    assert_eq!(
        ::core::mem::align_of::<_reent__bindgen_ty_1__bindgen_ty_2>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_reent__bindgen_ty_1__bindgen_ty_2>()))._nextf as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(_nextf)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_reent__bindgen_ty_1__bindgen_ty_2>()))._nmalloc as *const _
                as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(_nmalloc)
        )
    );
}
#[test]
fn bindgen_test_layout__reent__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<_reent__bindgen_ty_1>(),
        240usize,
        concat!("Size of: ", stringify!(_reent__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<_reent__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(_reent__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_reent__bindgen_ty_1>()))._reent as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1),
            "::",
            stringify!(_reent)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_reent__bindgen_ty_1>()))._unused as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1),
            "::",
            stringify!(_unused)
        )
    );
}
#[test]
fn bindgen_test_layout__reent() {
    assert_eq!(
        ::core::mem::size_of::<_reent>(),
        1064usize,
        concat!("Size of: ", stringify!(_reent))
    );
    assert_eq!(
        ::core::mem::align_of::<_reent>(),
        8usize,
        concat!("Alignment of ", stringify!(_reent))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_reent>()))._errno as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_errno)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_reent>()))._stdin as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_stdin)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_reent>()))._stdout as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_stdout)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_reent>()))._stderr as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_stderr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_reent>()))._inc as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_inc)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_reent>()))._emergency as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_emergency)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_reent>()))._unspecified_locale_info as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_unspecified_locale_info)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_reent>()))._locale as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_locale)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_reent>())).__sdidinit as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(__sdidinit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_reent>())).__cleanup as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(__cleanup)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_reent>()))._result as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_result)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_reent>()))._result_k as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_result_k)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_reent>()))._p5s as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_p5s)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_reent>()))._freelist as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_freelist)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_reent>()))._cvtlen as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_cvtlen)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_reent>()))._cvtbuf as *const _ as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_cvtbuf)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_reent>()))._new as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_new)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_reent>()))._atexit as *const _ as usize },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_atexit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_reent>()))._atexit0 as *const _ as usize },
        332usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_atexit0)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_reent>()))._sig_func as *const _ as usize },
        732usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_sig_func)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_reent>())).__sglue as *const _ as usize },
        736usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(__sglue)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_reent>())).__sf as *const _ as usize },
        748usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(__sf)
        )
    );
}
extern "C" {
    pub static mut _impure_ptr: *mut _reent;
}
extern "C" {
    pub static _global_impure_ptr: *mut _reent;
}
extern "C" {
    pub fn _reclaim_reent(arg1: *mut _reent);
}
#[repr(C)]
pub struct div_t {
    pub quot: super::c_int,
    pub rem: super::c_int,
}
#[test]
fn bindgen_test_layout_div_t() {
    assert_eq!(
        ::core::mem::size_of::<div_t>(),
        8usize,
        concat!("Size of: ", stringify!(div_t))
    );
    assert_eq!(
        ::core::mem::align_of::<div_t>(),
        4usize,
        concat!("Alignment of ", stringify!(div_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<div_t>())).quot as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(div_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<div_t>())).rem as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(div_t),
            "::",
            stringify!(rem)
        )
    );
}
#[repr(C)]
pub struct ldiv_t {
    pub quot: super::c_long,
    pub rem: super::c_long,
}
#[test]
fn bindgen_test_layout_ldiv_t() {
    assert_eq!(
        ::core::mem::size_of::<ldiv_t>(),
        8usize,
        concat!("Size of: ", stringify!(ldiv_t))
    );
    assert_eq!(
        ::core::mem::align_of::<ldiv_t>(),
        4usize,
        concat!("Alignment of ", stringify!(ldiv_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ldiv_t>())).quot as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ldiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ldiv_t>())).rem as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ldiv_t),
            "::",
            stringify!(rem)
        )
    );
}
#[repr(C)]
pub struct lldiv_t {
    pub quot: super::c_longlong,
    pub rem: super::c_longlong,
}
#[test]
fn bindgen_test_layout_lldiv_t() {
    assert_eq!(
        ::core::mem::size_of::<lldiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(lldiv_t))
    );
    assert_eq!(
        ::core::mem::align_of::<lldiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(lldiv_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<lldiv_t>())).quot as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lldiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<lldiv_t>())).rem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lldiv_t),
            "::",
            stringify!(rem)
        )
    );
}
pub type __compar_fn_t = ::core::option::Option<
    unsafe extern "C" fn(arg1: *const super::c_void, arg2: *const super::c_void) -> super::c_int,
>;
extern "C" {
    pub fn __locale_mb_cur_max() -> super::c_int;
}
extern "C" {
    pub fn abort();
}
extern "C" {
    pub fn abs(arg1: super::c_int) -> super::c_int;
}
extern "C" {
    pub fn arc4random() -> __uint32_t;
}
extern "C" {
    pub fn arc4random_uniform(arg1: __uint32_t) -> __uint32_t;
}
extern "C" {
    pub fn arc4random_buf(arg1: *mut super::c_void, arg2: size_t);
}
extern "C" {
    pub fn atexit(__func: ::core::option::Option<unsafe extern "C" fn()>) -> super::c_int;
}
extern "C" {
    pub fn atof(__nptr: *const super::c_char) -> f64;
}
extern "C" {
    pub fn atoff(__nptr: *const super::c_char) -> f32;
}
extern "C" {
    pub fn atoi(__nptr: *const super::c_char) -> super::c_int;
}
extern "C" {
    pub fn _atoi_r(arg1: *mut _reent, __nptr: *const super::c_char) -> super::c_int;
}
extern "C" {
    pub fn atol(__nptr: *const super::c_char) -> super::c_long;
}
extern "C" {
    pub fn _atol_r(arg1: *mut _reent, __nptr: *const super::c_char) -> super::c_long;
}
extern "C" {
    pub fn bsearch(
        __key: *const super::c_void,
        __base: *const super::c_void,
        __nmemb: size_t,
        __size: size_t,
        _compar: __compar_fn_t,
    ) -> *mut super::c_void;
}
extern "C" {
    pub fn calloc(__nmemb: size_t, __size: size_t) -> *mut super::c_void;
}
extern "C" {
    pub fn div(__numer: super::c_int, __denom: super::c_int) -> div_t;
}
extern "C" {
    pub fn exit(__status: super::c_int);
}
extern "C" {
    pub fn free(arg1: *mut super::c_void);
}
extern "C" {
    pub fn getenv(__string: *const super::c_char) -> *mut super::c_char;
}
extern "C" {
    pub fn _getenv_r(arg1: *mut _reent, __string: *const super::c_char) -> *mut super::c_char;
}
extern "C" {
    pub fn _findenv(arg1: *const super::c_char, arg2: *mut super::c_int) -> *mut super::c_char;
}
extern "C" {
    pub fn _findenv_r(
        arg1: *mut _reent,
        arg2: *const super::c_char,
        arg3: *mut super::c_int,
    ) -> *mut super::c_char;
}
extern "C" {
    pub static mut suboptarg: *mut super::c_char;
}
extern "C" {
    pub fn getsubopt(
        arg1: *mut *mut super::c_char,
        arg2: *const *mut super::c_char,
        arg3: *mut *mut super::c_char,
    ) -> super::c_int;
}
extern "C" {
    pub fn labs(arg1: super::c_long) -> super::c_long;
}
extern "C" {
    pub fn ldiv(__numer: super::c_long, __denom: super::c_long) -> ldiv_t;
}
extern "C" {
    pub fn malloc(__size: size_t) -> *mut super::c_void;
}
extern "C" {
    pub fn mblen(arg1: *const super::c_char, arg2: size_t) -> super::c_int;
}
extern "C" {
    pub fn _mblen_r(
        arg1: *mut _reent,
        arg2: *const super::c_char,
        arg3: size_t,
        arg4: *mut _mbstate_t,
    ) -> super::c_int;
}
extern "C" {
    pub fn mbtowc(arg1: *mut u32, arg2: *const super::c_char, arg3: size_t) -> super::c_int;
}
extern "C" {
    pub fn _mbtowc_r(
        arg1: *mut _reent,
        arg2: *mut u32,
        arg3: *const super::c_char,
        arg4: size_t,
        arg5: *mut _mbstate_t,
    ) -> super::c_int;
}
extern "C" {
    pub fn wctomb(arg1: *mut super::c_char, arg2: u32) -> super::c_int;
}
extern "C" {
    pub fn _wctomb_r(
        arg1: *mut _reent,
        arg2: *mut super::c_char,
        arg3: u32,
        arg4: *mut _mbstate_t,
    ) -> super::c_int;
}
extern "C" {
    pub fn mbstowcs(arg1: *mut u32, arg2: *const super::c_char, arg3: size_t) -> size_t;
}
extern "C" {
    pub fn _mbstowcs_r(
        arg1: *mut _reent,
        arg2: *mut u32,
        arg3: *const super::c_char,
        arg4: size_t,
        arg5: *mut _mbstate_t,
    ) -> size_t;
}
extern "C" {
    pub fn wcstombs(arg1: *mut super::c_char, arg2: *const u32, arg3: size_t) -> size_t;
}
extern "C" {
    pub fn _wcstombs_r(
        arg1: *mut _reent,
        arg2: *mut super::c_char,
        arg3: *const u32,
        arg4: size_t,
        arg5: *mut _mbstate_t,
    ) -> size_t;
}
extern "C" {
    pub fn mkdtemp(arg1: *mut super::c_char) -> *mut super::c_char;
}
extern "C" {
    pub fn mkstemp(arg1: *mut super::c_char) -> super::c_int;
}
extern "C" {
    pub fn mkstemps(arg1: *mut super::c_char, arg2: super::c_int) -> super::c_int;
}
extern "C" {
    pub fn mktemp(arg1: *mut super::c_char) -> *mut super::c_char;
}
extern "C" {
    pub fn _mkdtemp_r(arg1: *mut _reent, arg2: *mut super::c_char) -> *mut super::c_char;
}
extern "C" {
    pub fn _mkostemp_r(
        arg1: *mut _reent,
        arg2: *mut super::c_char,
        arg3: super::c_int,
    ) -> super::c_int;
}
extern "C" {
    pub fn _mkostemps_r(
        arg1: *mut _reent,
        arg2: *mut super::c_char,
        arg3: super::c_int,
        arg4: super::c_int,
    ) -> super::c_int;
}
extern "C" {
    pub fn _mkstemp_r(arg1: *mut _reent, arg2: *mut super::c_char) -> super::c_int;
}
extern "C" {
    pub fn _mkstemps_r(
        arg1: *mut _reent,
        arg2: *mut super::c_char,
        arg3: super::c_int,
    ) -> super::c_int;
}
extern "C" {
    pub fn _mktemp_r(arg1: *mut _reent, arg2: *mut super::c_char) -> *mut super::c_char;
}
extern "C" {
    pub fn qsort(
        __base: *mut super::c_void,
        __nmemb: size_t,
        __size: size_t,
        _compar: __compar_fn_t,
    );
}
extern "C" {
    pub fn rand() -> super::c_int;
}
extern "C" {
    pub fn realloc(__r: *mut super::c_void, __size: size_t) -> *mut super::c_void;
}
extern "C" {
    #[must_use]
    pub fn reallocarray(arg1: *mut super::c_void, arg2: size_t, arg3: size_t)
        -> *mut super::c_void;
}
extern "C" {
    pub fn reallocf(__r: *mut super::c_void, __size: size_t) -> *mut super::c_void;
}
extern "C" {
    pub fn realpath(
        path: *const super::c_char,
        resolved_path: *mut super::c_char,
    ) -> *mut super::c_char;
}
extern "C" {
    pub fn rpmatch(response: *const super::c_char) -> super::c_int;
}
extern "C" {
    pub fn srand(__seed: super::c_uint);
}
extern "C" {
    pub fn strtod(__n: *const super::c_char, __end_PTR: *mut *mut super::c_char) -> f64;
}
extern "C" {
    pub fn _strtod_r(
        arg1: *mut _reent,
        __n: *const super::c_char,
        __end_PTR: *mut *mut super::c_char,
    ) -> f64;
}
extern "C" {
    pub fn strtof(__n: *const super::c_char, __end_PTR: *mut *mut super::c_char) -> f32;
}
extern "C" {
    pub fn strtol(
        __n: *const super::c_char,
        __end_PTR: *mut *mut super::c_char,
        __base: super::c_int,
    ) -> super::c_long;
}
extern "C" {
    pub fn _strtol_r(
        arg1: *mut _reent,
        __n: *const super::c_char,
        __end_PTR: *mut *mut super::c_char,
        __base: super::c_int,
    ) -> super::c_long;
}
extern "C" {
    pub fn strtoul(
        __n: *const super::c_char,
        __end_PTR: *mut *mut super::c_char,
        __base: super::c_int,
    ) -> super::c_ulong;
}
extern "C" {
    pub fn _strtoul_r(
        arg1: *mut _reent,
        __n: *const super::c_char,
        __end_PTR: *mut *mut super::c_char,
        __base: super::c_int,
    ) -> super::c_ulong;
}
extern "C" {
    pub fn system(__string: *const super::c_char) -> super::c_int;
}
extern "C" {
    pub fn a64l(__input: *const super::c_char) -> super::c_long;
}
extern "C" {
    pub fn l64a(__input: super::c_long) -> *mut super::c_char;
}
extern "C" {
    pub fn _l64a_r(arg1: *mut _reent, __input: super::c_long) -> *mut super::c_char;
}
extern "C" {
    pub fn on_exit(
        __func: ::core::option::Option<
            unsafe extern "C" fn(arg1: super::c_int, arg2: *mut super::c_void),
        >,
        __arg: *mut super::c_void,
    ) -> super::c_int;
}
extern "C" {
    pub fn _Exit(__status: super::c_int);
}
extern "C" {
    pub fn putenv(__string: *mut super::c_char) -> super::c_int;
}
extern "C" {
    pub fn _putenv_r(arg1: *mut _reent, __string: *mut super::c_char) -> super::c_int;
}
extern "C" {
    pub fn _reallocf_r(
        arg1: *mut _reent,
        arg2: *mut super::c_void,
        arg3: size_t,
    ) -> *mut super::c_void;
}
extern "C" {
    pub fn setenv(
        __string: *const super::c_char,
        __value: *const super::c_char,
        __overwrite: super::c_int,
    ) -> super::c_int;
}
extern "C" {
    pub fn _setenv_r(
        arg1: *mut _reent,
        __string: *const super::c_char,
        __value: *const super::c_char,
        __overwrite: super::c_int,
    ) -> super::c_int;
}
extern "C" {
    pub fn __itoa(
        arg1: super::c_int,
        arg2: *mut super::c_char,
        arg3: super::c_int,
    ) -> *mut super::c_char;
}
extern "C" {
    pub fn __utoa(
        arg1: super::c_uint,
        arg2: *mut super::c_char,
        arg3: super::c_int,
    ) -> *mut super::c_char;
}
extern "C" {
    pub fn itoa(
        arg1: super::c_int,
        arg2: *mut super::c_char,
        arg3: super::c_int,
    ) -> *mut super::c_char;
}
extern "C" {
    pub fn utoa(
        arg1: super::c_uint,
        arg2: *mut super::c_char,
        arg3: super::c_int,
    ) -> *mut super::c_char;
}
extern "C" {
    pub fn rand_r(__seed: *mut super::c_uint) -> super::c_int;
}
extern "C" {
    pub fn drand48() -> f64;
}
extern "C" {
    pub fn _drand48_r(arg1: *mut _reent) -> f64;
}
extern "C" {
    pub fn erand48(arg1: *mut super::c_ushort) -> f64;
}
extern "C" {
    pub fn _erand48_r(arg1: *mut _reent, arg2: *mut super::c_ushort) -> f64;
}
extern "C" {
    pub fn jrand48(arg1: *mut super::c_ushort) -> super::c_long;
}
extern "C" {
    pub fn _jrand48_r(arg1: *mut _reent, arg2: *mut super::c_ushort) -> super::c_long;
}
extern "C" {
    pub fn lcong48(arg1: *mut super::c_ushort);
}
extern "C" {
    pub fn _lcong48_r(arg1: *mut _reent, arg2: *mut super::c_ushort);
}
extern "C" {
    pub fn lrand48() -> super::c_long;
}
extern "C" {
    pub fn _lrand48_r(arg1: *mut _reent) -> super::c_long;
}
extern "C" {
    pub fn mrand48() -> super::c_long;
}
extern "C" {
    pub fn _mrand48_r(arg1: *mut _reent) -> super::c_long;
}
extern "C" {
    pub fn nrand48(arg1: *mut super::c_ushort) -> super::c_long;
}
extern "C" {
    pub fn _nrand48_r(arg1: *mut _reent, arg2: *mut super::c_ushort) -> super::c_long;
}
extern "C" {
    pub fn seed48(arg1: *mut super::c_ushort) -> *mut super::c_ushort;
}
extern "C" {
    pub fn _seed48_r(arg1: *mut _reent, arg2: *mut super::c_ushort) -> *mut super::c_ushort;
}
extern "C" {
    pub fn srand48(arg1: super::c_long);
}
extern "C" {
    pub fn _srand48_r(arg1: *mut _reent, arg2: super::c_long);
}
extern "C" {
    pub fn initstate(
        arg1: super::c_uint,
        arg2: *mut super::c_char,
        arg3: size_t,
    ) -> *mut super::c_char;
}
extern "C" {
    pub fn setstate(arg1: *mut super::c_char) -> *mut super::c_char;
}
extern "C" {
    pub fn srandom(arg1: super::c_uint);
}
extern "C" {
    pub fn atoll(__nptr: *const super::c_char) -> super::c_longlong;
}
extern "C" {
    pub fn _atoll_r(arg1: *mut _reent, __nptr: *const super::c_char) -> super::c_longlong;
}
extern "C" {
    pub fn llabs(arg1: super::c_longlong) -> super::c_longlong;
}
extern "C" {
    pub fn lldiv(__numer: super::c_longlong, __denom: super::c_longlong) -> lldiv_t;
}
extern "C" {
    pub fn strtoll(
        __n: *const super::c_char,
        __end_PTR: *mut *mut super::c_char,
        __base: super::c_int,
    ) -> super::c_longlong;
}
extern "C" {
    pub fn _strtoll_r(
        arg1: *mut _reent,
        __n: *const super::c_char,
        __end_PTR: *mut *mut super::c_char,
        __base: super::c_int,
    ) -> super::c_longlong;
}
extern "C" {
    pub fn strtoull(
        __n: *const super::c_char,
        __end_PTR: *mut *mut super::c_char,
        __base: super::c_int,
    ) -> super::c_ulonglong;
}
extern "C" {
    pub fn _strtoull_r(
        arg1: *mut _reent,
        __n: *const super::c_char,
        __end_PTR: *mut *mut super::c_char,
        __base: super::c_int,
    ) -> super::c_ulonglong;
}
extern "C" {
    pub fn cfree(arg1: *mut super::c_void);
}
extern "C" {
    pub fn unsetenv(__string: *const super::c_char) -> super::c_int;
}
extern "C" {
    pub fn _unsetenv_r(arg1: *mut _reent, __string: *const super::c_char) -> super::c_int;
}
extern "C" {
    pub fn posix_memalign(
        arg1: *mut *mut super::c_void,
        arg2: size_t,
        arg3: size_t,
    ) -> super::c_int;
}
extern "C" {
    pub fn _dtoa_r(
        arg1: *mut _reent,
        arg2: f64,
        arg3: super::c_int,
        arg4: super::c_int,
        arg5: *mut super::c_int,
        arg6: *mut super::c_int,
        arg7: *mut *mut super::c_char,
    ) -> *mut super::c_char;
}
extern "C" {
    pub fn _malloc_r(arg1: *mut _reent, arg2: size_t) -> *mut super::c_void;
}
extern "C" {
    pub fn _calloc_r(arg1: *mut _reent, arg2: size_t, arg3: size_t) -> *mut super::c_void;
}
extern "C" {
    pub fn _free_r(arg1: *mut _reent, arg2: *mut super::c_void);
}
extern "C" {
    pub fn _realloc_r(
        arg1: *mut _reent,
        arg2: *mut super::c_void,
        arg3: size_t,
    ) -> *mut super::c_void;
}
extern "C" {
    pub fn _mstats_r(arg1: *mut _reent, arg2: *mut super::c_char);
}
extern "C" {
    pub fn _system_r(arg1: *mut _reent, arg2: *const super::c_char) -> super::c_int;
}
extern "C" {
    #[link_name = "\u{1}__bsd_qsort_r"]
    pub fn qsort_r(
        __base: *mut super::c_void,
        __nmemb: size_t,
        __size: size_t,
        __thunk: *mut super::c_void,
        _compar: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut super::c_void,
                arg2: *const super::c_void,
                arg3: *const super::c_void,
            ) -> super::c_int,
        >,
    );
}
extern "C" {
    pub fn _strtold_r(
        arg1: *mut _reent,
        arg2: *const super::c_char,
        arg3: *mut *mut super::c_char,
    ) -> f64;
}
extern "C" {
    pub fn strtold(arg1: *const super::c_char, arg2: *mut *mut super::c_char) -> f64;
}
extern "C" {
    pub fn aligned_alloc(arg1: size_t, arg2: size_t) -> *mut super::c_void;
}
extern "C" {
    pub fn at_quick_exit(arg1: ::core::option::Option<unsafe extern "C" fn()>) -> super::c_int;
}
extern "C" {
    pub fn quick_exit(arg1: super::c_int);
}
pub type u_int8_t = __uint8_t;
pub type u_int16_t = __uint16_t;
pub type u_int32_t = __uint32_t;
pub type u_int64_t = __uint64_t;
pub type register_t = super::c_int;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
pub type __sigset_t = super::c_ulong;
pub type suseconds_t = __suseconds_t;
pub type time_t = __int_least64_t;
#[repr(C)]
pub struct timeval {
    pub tv_sec: time_t,
    pub tv_usec: suseconds_t,
}
#[test]
fn bindgen_test_layout_timeval() {
    assert_eq!(
        ::core::mem::size_of::<timeval>(),
        16usize,
        concat!("Size of: ", stringify!(timeval))
    );
    assert_eq!(
        ::core::mem::align_of::<timeval>(),
        8usize,
        concat!("Alignment of ", stringify!(timeval))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<timeval>())).tv_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<timeval>())).tv_usec as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_usec)
        )
    );
}
#[repr(C)]
pub struct timespec {
    pub tv_sec: time_t,
    pub tv_nsec: super::c_long,
}
#[test]
fn bindgen_test_layout_timespec() {
    assert_eq!(
        ::core::mem::size_of::<timespec>(),
        16usize,
        concat!("Size of: ", stringify!(timespec))
    );
    assert_eq!(
        ::core::mem::align_of::<timespec>(),
        8usize,
        concat!("Alignment of ", stringify!(timespec))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<timespec>())).tv_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<timespec>())).tv_nsec as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_nsec)
        )
    );
}
#[repr(C)]
pub struct itimerspec {
    pub it_interval: timespec,
    pub it_value: timespec,
}
#[test]
fn bindgen_test_layout_itimerspec() {
    assert_eq!(
        ::core::mem::size_of::<itimerspec>(),
        32usize,
        concat!("Size of: ", stringify!(itimerspec))
    );
    assert_eq!(
        ::core::mem::align_of::<itimerspec>(),
        8usize,
        concat!("Alignment of ", stringify!(itimerspec))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<itimerspec>())).it_interval as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(itimerspec),
            "::",
            stringify!(it_interval)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<itimerspec>())).it_value as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(itimerspec),
            "::",
            stringify!(it_value)
        )
    );
}
pub type sigset_t = __sigset_t;
pub type fd_mask = super::c_ulong;
#[repr(C)]
pub struct _types_fd_set {
    pub fds_bits: [fd_mask; 2usize],
}
#[test]
fn bindgen_test_layout__types_fd_set() {
    assert_eq!(
        ::core::mem::size_of::<_types_fd_set>(),
        8usize,
        concat!("Size of: ", stringify!(_types_fd_set))
    );
    assert_eq!(
        ::core::mem::align_of::<_types_fd_set>(),
        4usize,
        concat!("Alignment of ", stringify!(_types_fd_set))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_types_fd_set>())).fds_bits as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_types_fd_set),
            "::",
            stringify!(fds_bits)
        )
    );
}
extern "C" {
    pub fn select(
        __n: super::c_int,
        __readfds: *mut _types_fd_set,
        __writefds: *mut _types_fd_set,
        __exceptfds: *mut _types_fd_set,
        __timeout: *mut timeval,
    ) -> super::c_int;
}
extern "C" {
    pub fn pselect(
        __n: super::c_int,
        __readfds: *mut _types_fd_set,
        __writefds: *mut _types_fd_set,
        __exceptfds: *mut _types_fd_set,
        __timeout: *const timespec,
        __set: *const sigset_t,
    ) -> super::c_int;
}
pub type in_addr_t = __uint32_t;
pub type in_port_t = __uint16_t;
pub type u_char = super::c_uchar;
pub type u_short = super::c_ushort;
pub type u_int = super::c_uint;
pub type u_long = super::c_ulong;
pub type ushort = super::c_ushort;
pub type uint = super::c_uint;
pub type ulong = super::c_ulong;
pub type blkcnt_t = __blkcnt_t;
pub type blksize_t = __blksize_t;
pub type clock_t = super::c_ulong;
pub type daddr_t = super::c_long;
pub type caddr_t = *mut super::c_char;
pub type fsblkcnt_t = __fsblkcnt_t;
pub type fsfilcnt_t = __fsfilcnt_t;
pub type id_t = __id_t;
pub type ino_t = __ino_t;
pub type off_t = __off_t;
pub type dev_t = __dev_t;
pub type uid_t = __uid_t;
pub type gid_t = __gid_t;
pub type pid_t = __pid_t;
pub type key_t = __key_t;
pub type ssize_t = _ssize_t;
pub type mode_t = __mode_t;
pub type nlink_t = __nlink_t;
pub type clockid_t = __clockid_t;
pub type timer_t = __timer_t;
pub type useconds_t = __useconds_t;
pub type sbintime_t = __int64_t;
#[repr(C)]
pub struct sched_param {
    pub sched_priority: super::c_int,
}
#[test]
fn bindgen_test_layout_sched_param() {
    assert_eq!(
        ::core::mem::size_of::<sched_param>(),
        4usize,
        concat!("Size of: ", stringify!(sched_param))
    );
    assert_eq!(
        ::core::mem::align_of::<sched_param>(),
        4usize,
        concat!("Alignment of ", stringify!(sched_param))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sched_param>())).sched_priority as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_param),
            "::",
            stringify!(sched_priority)
        )
    );
}
pub type pthread_t = __uint32_t;
#[repr(C)]
pub struct pthread_attr_t {
    pub is_initialized: super::c_int,
    pub stackaddr: *mut super::c_void,
    pub stacksize: super::c_int,
    pub contentionscope: super::c_int,
    pub inheritsched: super::c_int,
    pub schedpolicy: super::c_int,
    pub schedparam: sched_param,
    pub detachstate: super::c_int,
}
#[test]
fn bindgen_test_layout_pthread_attr_t() {
    assert_eq!(
        ::core::mem::size_of::<pthread_attr_t>(),
        32usize,
        concat!("Size of: ", stringify!(pthread_attr_t))
    );
    assert_eq!(
        ::core::mem::align_of::<pthread_attr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_attr_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pthread_attr_t>())).is_initialized as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(is_initialized)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pthread_attr_t>())).stackaddr as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(stackaddr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pthread_attr_t>())).stacksize as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(stacksize)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pthread_attr_t>())).contentionscope as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(contentionscope)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pthread_attr_t>())).inheritsched as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(inheritsched)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pthread_attr_t>())).schedpolicy as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(schedpolicy)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pthread_attr_t>())).schedparam as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(schedparam)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pthread_attr_t>())).detachstate as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(detachstate)
        )
    );
}
pub type pthread_mutex_t = __uint32_t;
#[repr(C)]
pub struct pthread_mutexattr_t {
    pub is_initialized: super::c_int,
    pub recursive: super::c_int,
}
#[test]
fn bindgen_test_layout_pthread_mutexattr_t() {
    assert_eq!(
        ::core::mem::size_of::<pthread_mutexattr_t>(),
        8usize,
        concat!("Size of: ", stringify!(pthread_mutexattr_t))
    );
    assert_eq!(
        ::core::mem::align_of::<pthread_mutexattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_mutexattr_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<pthread_mutexattr_t>())).is_initialized as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutexattr_t),
            "::",
            stringify!(is_initialized)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pthread_mutexattr_t>())).recursive as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutexattr_t),
            "::",
            stringify!(recursive)
        )
    );
}
pub type pthread_cond_t = __uint32_t;
#[repr(C)]
pub struct pthread_condattr_t {
    pub is_initialized: super::c_int,
    pub clock: clock_t,
}
#[test]
fn bindgen_test_layout_pthread_condattr_t() {
    assert_eq!(
        ::core::mem::size_of::<pthread_condattr_t>(),
        8usize,
        concat!("Size of: ", stringify!(pthread_condattr_t))
    );
    assert_eq!(
        ::core::mem::align_of::<pthread_condattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_condattr_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<pthread_condattr_t>())).is_initialized as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_condattr_t),
            "::",
            stringify!(is_initialized)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pthread_condattr_t>())).clock as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_condattr_t),
            "::",
            stringify!(clock)
        )
    );
}
pub type pthread_key_t = __uint32_t;
#[repr(C)]
pub struct pthread_once_t {
    pub is_initialized: super::c_int,
    pub init_executed: super::c_int,
}
#[test]
fn bindgen_test_layout_pthread_once_t() {
    assert_eq!(
        ::core::mem::size_of::<pthread_once_t>(),
        8usize,
        concat!("Size of: ", stringify!(pthread_once_t))
    );
    assert_eq!(
        ::core::mem::align_of::<pthread_once_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_once_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pthread_once_t>())).is_initialized as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_once_t),
            "::",
            stringify!(is_initialized)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pthread_once_t>())).init_executed as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_once_t),
            "::",
            stringify!(init_executed)
        )
    );
}
pub type FILE = __FILE;
pub type fpos_t = _fpos_t;
extern "C" {
    pub fn ctermid(arg1: *mut super::c_char) -> *mut super::c_char;
}
extern "C" {
    pub fn tmpfile() -> *mut FILE;
}
extern "C" {
    pub fn tmpnam(arg1: *mut super::c_char) -> *mut super::c_char;
}
extern "C" {
    pub fn tempnam(arg1: *const super::c_char, arg2: *const super::c_char) -> *mut super::c_char;
}
extern "C" {
    pub fn fclose(arg1: *mut FILE) -> super::c_int;
}
extern "C" {
    pub fn fflush(arg1: *mut FILE) -> super::c_int;
}
extern "C" {
    pub fn freopen(
        arg1: *const super::c_char,
        arg2: *const super::c_char,
        arg3: *mut FILE,
    ) -> *mut FILE;
}
extern "C" {
    pub fn setbuf(arg1: *mut FILE, arg2: *mut super::c_char);
}
extern "C" {
    pub fn setvbuf(
        arg1: *mut FILE,
        arg2: *mut super::c_char,
        arg3: super::c_int,
        arg4: size_t,
    ) -> super::c_int;
}
extern "C" {
    pub fn fgetc(arg1: *mut FILE) -> super::c_int;
}
extern "C" {
    pub fn fgets(
        arg1: *mut super::c_char,
        arg2: super::c_int,
        arg3: *mut FILE,
    ) -> *mut super::c_char;
}
extern "C" {
    pub fn fputc(arg1: super::c_int, arg2: *mut FILE) -> super::c_int;
}
extern "C" {
    pub fn fputs(arg1: *const super::c_char, arg2: *mut FILE) -> super::c_int;
}
extern "C" {
    pub fn getc(arg1: *mut FILE) -> super::c_int;
}
extern "C" {
    pub fn getchar() -> super::c_int;
}
extern "C" {
    pub fn gets(arg1: *mut super::c_char) -> *mut super::c_char;
}
extern "C" {
    pub fn putc(arg1: super::c_int, arg2: *mut FILE) -> super::c_int;
}
extern "C" {
    pub fn putchar(arg1: super::c_int) -> super::c_int;
}
extern "C" {
    pub fn puts(arg1: *const super::c_char) -> super::c_int;
}
extern "C" {
    pub fn ungetc(arg1: super::c_int, arg2: *mut FILE) -> super::c_int;
}
extern "C" {
    pub fn fread(arg1: *mut super::c_void, _size: size_t, _n: size_t, arg2: *mut FILE) -> size_t;
}
extern "C" {
    pub fn fwrite(arg1: *const super::c_void, _size: size_t, _n: size_t, arg2: *mut FILE)
        -> size_t;
}
extern "C" {
    pub fn fgetpos(arg1: *mut FILE, arg2: *mut fpos_t) -> super::c_int;
}
extern "C" {
    pub fn fseek(arg1: *mut FILE, arg2: super::c_long, arg3: super::c_int) -> super::c_int;
}
extern "C" {
    pub fn fsetpos(arg1: *mut FILE, arg2: *const fpos_t) -> super::c_int;
}
extern "C" {
    pub fn ftell(arg1: *mut FILE) -> super::c_long;
}
extern "C" {
    pub fn rewind(arg1: *mut FILE);
}
extern "C" {
    pub fn clearerr(arg1: *mut FILE);
}
extern "C" {
    pub fn feof(arg1: *mut FILE) -> super::c_int;
}
extern "C" {
    pub fn ferror(arg1: *mut FILE) -> super::c_int;
}
extern "C" {
    pub fn perror(arg1: *const super::c_char);
}
extern "C" {
    pub fn fopen(_name: *const super::c_char, _type: *const super::c_char) -> *mut FILE;
}
extern "C" {
    pub fn remove(arg1: *const super::c_char) -> super::c_int;
}
extern "C" {
    pub fn rename(arg1: *const super::c_char, arg2: *const super::c_char) -> super::c_int;
}
extern "C" {
    pub fn fseeko(arg1: *mut FILE, arg2: off_t, arg3: super::c_int) -> super::c_int;
}
extern "C" {
    pub fn ftello(arg1: *mut FILE) -> off_t;
}
extern "C" {
    pub fn fdopen(arg1: super::c_int, arg2: *const super::c_char) -> *mut FILE;
}
extern "C" {
    pub fn fileno(arg1: *mut FILE) -> super::c_int;
}
extern "C" {
    pub fn pclose(arg1: *mut FILE) -> super::c_int;
}
extern "C" {
    pub fn popen(arg1: *const super::c_char, arg2: *const super::c_char) -> *mut FILE;
}
extern "C" {
    pub fn setbuffer(arg1: *mut FILE, arg2: *mut super::c_char, arg3: super::c_int);
}
extern "C" {
    pub fn setlinebuf(arg1: *mut FILE) -> super::c_int;
}
extern "C" {
    pub fn getw(arg1: *mut FILE) -> super::c_int;
}
extern "C" {
    pub fn putw(arg1: super::c_int, arg2: *mut FILE) -> super::c_int;
}
extern "C" {
    pub fn getc_unlocked(arg1: *mut FILE) -> super::c_int;
}
extern "C" {
    pub fn getchar_unlocked() -> super::c_int;
}
extern "C" {
    pub fn flockfile(arg1: *mut FILE);
}
extern "C" {
    pub fn ftrylockfile(arg1: *mut FILE) -> super::c_int;
}
extern "C" {
    pub fn funlockfile(arg1: *mut FILE);
}
extern "C" {
    pub fn putc_unlocked(arg1: super::c_int, arg2: *mut FILE) -> super::c_int;
}
extern "C" {
    pub fn putchar_unlocked(arg1: super::c_int) -> super::c_int;
}
extern "C" {
    pub fn fmemopen(
        arg1: *mut super::c_void,
        arg2: size_t,
        arg3: *const super::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn open_memstream(arg1: *mut *mut super::c_char, arg2: *mut size_t) -> *mut FILE;
}
extern "C" {
    pub fn renameat(
        arg1: super::c_int,
        arg2: *const super::c_char,
        arg3: super::c_int,
        arg4: *const super::c_char,
    ) -> super::c_int;
}
extern "C" {
    pub fn _fclose_r(arg1: *mut _reent, arg2: *mut FILE) -> super::c_int;
}
extern "C" {
    pub fn _fcloseall_r(arg1: *mut _reent) -> super::c_int;
}
extern "C" {
    pub fn _fdopen_r(
        arg1: *mut _reent,
        arg2: super::c_int,
        arg3: *const super::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn _fflush_r(arg1: *mut _reent, arg2: *mut FILE) -> super::c_int;
}
extern "C" {
    pub fn _fgetc_r(arg1: *mut _reent, arg2: *mut FILE) -> super::c_int;
}
extern "C" {
    pub fn _fgetc_unlocked_r(arg1: *mut _reent, arg2: *mut FILE) -> super::c_int;
}
extern "C" {
    pub fn _fgets_r(
        arg1: *mut _reent,
        arg2: *mut super::c_char,
        arg3: super::c_int,
        arg4: *mut FILE,
    ) -> *mut super::c_char;
}
extern "C" {
    pub fn _fgets_unlocked_r(
        arg1: *mut _reent,
        arg2: *mut super::c_char,
        arg3: super::c_int,
        arg4: *mut FILE,
    ) -> *mut super::c_char;
}
extern "C" {
    pub fn _fgetpos_r(arg1: *mut _reent, arg2: *mut FILE, arg3: *mut fpos_t) -> super::c_int;
}
extern "C" {
    pub fn _fsetpos_r(arg1: *mut _reent, arg2: *mut FILE, arg3: *const fpos_t) -> super::c_int;
}
extern "C" {
    pub fn _fmemopen_r(
        arg1: *mut _reent,
        arg2: *mut super::c_void,
        arg3: size_t,
        arg4: *const super::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn _fopen_r(
        arg1: *mut _reent,
        arg2: *const super::c_char,
        arg3: *const super::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn _freopen_r(
        arg1: *mut _reent,
        arg2: *const super::c_char,
        arg3: *const super::c_char,
        arg4: *mut FILE,
    ) -> *mut FILE;
}
extern "C" {
    pub fn _fpurge_r(arg1: *mut _reent, arg2: *mut FILE) -> super::c_int;
}
extern "C" {
    pub fn _fputc_r(arg1: *mut _reent, arg2: super::c_int, arg3: *mut FILE) -> super::c_int;
}
extern "C" {
    pub fn _fputc_unlocked_r(
        arg1: *mut _reent,
        arg2: super::c_int,
        arg3: *mut FILE,
    ) -> super::c_int;
}
extern "C" {
    pub fn _fputs_r(arg1: *mut _reent, arg2: *const super::c_char, arg3: *mut FILE)
        -> super::c_int;
}
extern "C" {
    pub fn _fputs_unlocked_r(
        arg1: *mut _reent,
        arg2: *const super::c_char,
        arg3: *mut FILE,
    ) -> super::c_int;
}
extern "C" {
    pub fn _fread_r(
        arg1: *mut _reent,
        arg2: *mut super::c_void,
        _size: size_t,
        _n: size_t,
        arg3: *mut FILE,
    ) -> size_t;
}
extern "C" {
    pub fn _fread_unlocked_r(
        arg1: *mut _reent,
        arg2: *mut super::c_void,
        _size: size_t,
        _n: size_t,
        arg3: *mut FILE,
    ) -> size_t;
}
extern "C" {
    pub fn _fseek_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: super::c_long,
        arg4: super::c_int,
    ) -> super::c_int;
}
extern "C" {
    pub fn _fseeko_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: _off_t,
        arg4: super::c_int,
    ) -> super::c_int;
}
extern "C" {
    pub fn _ftell_r(arg1: *mut _reent, arg2: *mut FILE) -> super::c_long;
}
extern "C" {
    pub fn _ftello_r(arg1: *mut _reent, arg2: *mut FILE) -> _off_t;
}
extern "C" {
    pub fn _rewind_r(arg1: *mut _reent, arg2: *mut FILE);
}
extern "C" {
    pub fn _fwrite_r(
        arg1: *mut _reent,
        arg2: *const super::c_void,
        _size: size_t,
        _n: size_t,
        arg3: *mut FILE,
    ) -> size_t;
}
extern "C" {
    pub fn _fwrite_unlocked_r(
        arg1: *mut _reent,
        arg2: *const super::c_void,
        _size: size_t,
        _n: size_t,
        arg3: *mut FILE,
    ) -> size_t;
}
extern "C" {
    pub fn _getc_r(arg1: *mut _reent, arg2: *mut FILE) -> super::c_int;
}
extern "C" {
    pub fn _getc_unlocked_r(arg1: *mut _reent, arg2: *mut FILE) -> super::c_int;
}
extern "C" {
    pub fn _getchar_r(arg1: *mut _reent) -> super::c_int;
}
extern "C" {
    pub fn _getchar_unlocked_r(arg1: *mut _reent) -> super::c_int;
}
extern "C" {
    pub fn _gets_r(arg1: *mut _reent, arg2: *mut super::c_char) -> *mut super::c_char;
}
extern "C" {
    pub fn _open_memstream_r(
        arg1: *mut _reent,
        arg2: *mut *mut super::c_char,
        arg3: *mut size_t,
    ) -> *mut FILE;
}
extern "C" {
    pub fn _perror_r(arg1: *mut _reent, arg2: *const super::c_char);
}
extern "C" {
    pub fn _putc_r(arg1: *mut _reent, arg2: super::c_int, arg3: *mut FILE) -> super::c_int;
}
extern "C" {
    pub fn _putc_unlocked_r(arg1: *mut _reent, arg2: super::c_int, arg3: *mut FILE)
        -> super::c_int;
}
extern "C" {
    pub fn _putchar_unlocked_r(arg1: *mut _reent, arg2: super::c_int) -> super::c_int;
}
extern "C" {
    pub fn _putchar_r(arg1: *mut _reent, arg2: super::c_int) -> super::c_int;
}
extern "C" {
    pub fn _puts_r(arg1: *mut _reent, arg2: *const super::c_char) -> super::c_int;
}
extern "C" {
    pub fn _remove_r(arg1: *mut _reent, arg2: *const super::c_char) -> super::c_int;
}
extern "C" {
    pub fn _rename_r(
        arg1: *mut _reent,
        _old: *const super::c_char,
        _new: *const super::c_char,
    ) -> super::c_int;
}
extern "C" {
    pub fn _tempnam_r(
        arg1: *mut _reent,
        arg2: *const super::c_char,
        arg3: *const super::c_char,
    ) -> *mut super::c_char;
}
extern "C" {
    pub fn _tmpfile_r(arg1: *mut _reent) -> *mut FILE;
}
extern "C" {
    pub fn _tmpnam_r(arg1: *mut _reent, arg2: *mut super::c_char) -> *mut super::c_char;
}
extern "C" {
    pub fn _ungetc_r(arg1: *mut _reent, arg2: super::c_int, arg3: *mut FILE) -> super::c_int;
}
extern "C" {
    pub fn fpurge(arg1: *mut FILE) -> super::c_int;
}
extern "C" {
    pub fn __getdelim(
        arg1: *mut *mut super::c_char,
        arg2: *mut size_t,
        arg3: super::c_int,
        arg4: *mut FILE,
    ) -> ssize_t;
}
extern "C" {
    pub fn __getline(arg1: *mut *mut super::c_char, arg2: *mut size_t, arg3: *mut FILE) -> ssize_t;
}
extern "C" {
    pub fn clearerr_unlocked(arg1: *mut FILE);
}
extern "C" {
    pub fn feof_unlocked(arg1: *mut FILE) -> super::c_int;
}
extern "C" {
    pub fn ferror_unlocked(arg1: *mut FILE) -> super::c_int;
}
extern "C" {
    pub fn fileno_unlocked(arg1: *mut FILE) -> super::c_int;
}
extern "C" {
    pub fn fflush_unlocked(arg1: *mut FILE) -> super::c_int;
}
extern "C" {
    pub fn fgetc_unlocked(arg1: *mut FILE) -> super::c_int;
}
extern "C" {
    pub fn fputc_unlocked(arg1: super::c_int, arg2: *mut FILE) -> super::c_int;
}
extern "C" {
    pub fn fread_unlocked(
        arg1: *mut super::c_void,
        _size: size_t,
        _n: size_t,
        arg2: *mut FILE,
    ) -> size_t;
}
extern "C" {
    pub fn fwrite_unlocked(
        arg1: *const super::c_void,
        _size: size_t,
        _n: size_t,
        arg2: *mut FILE,
    ) -> size_t;
}
extern "C" {
    pub fn __srget_r(arg1: *mut _reent, arg2: *mut FILE) -> super::c_int;
}
extern "C" {
    pub fn __swbuf_r(arg1: *mut _reent, arg2: super::c_int, arg3: *mut FILE) -> super::c_int;
}
extern "C" {
    pub fn funopen(
        __cookie: *const super::c_void,
        __readfn: ::core::option::Option<
            unsafe extern "C" fn(
                __cookie: *mut super::c_void,
                __buf: *mut super::c_char,
                __n: super::c_int,
            ) -> super::c_int,
        >,
        __writefn: ::core::option::Option<
            unsafe extern "C" fn(
                __cookie: *mut super::c_void,
                __buf: *const super::c_char,
                __n: super::c_int,
            ) -> super::c_int,
        >,
        __seekfn: ::core::option::Option<
            unsafe extern "C" fn(
                __cookie: *mut super::c_void,
                __off: fpos_t,
                __whence: super::c_int,
            ) -> fpos_t,
        >,
        __closefn: ::core::option::Option<
            unsafe extern "C" fn(__cookie: *mut super::c_void) -> super::c_int,
        >,
    ) -> *mut FILE;
}
extern "C" {
    pub fn _funopen_r(
        arg1: *mut _reent,
        __cookie: *const super::c_void,
        __readfn: ::core::option::Option<
            unsafe extern "C" fn(
                __cookie: *mut super::c_void,
                __buf: *mut super::c_char,
                __n: super::c_int,
            ) -> super::c_int,
        >,
        __writefn: ::core::option::Option<
            unsafe extern "C" fn(
                __cookie: *mut super::c_void,
                __buf: *const super::c_char,
                __n: super::c_int,
            ) -> super::c_int,
        >,
        __seekfn: ::core::option::Option<
            unsafe extern "C" fn(
                __cookie: *mut super::c_void,
                __off: fpos_t,
                __whence: super::c_int,
            ) -> fpos_t,
        >,
        __closefn: ::core::option::Option<
            unsafe extern "C" fn(__cookie: *mut super::c_void) -> super::c_int,
        >,
    ) -> *mut FILE;
}
pub type locale_t = *mut __locale_t;
extern "C" {
    pub fn bcmp(
        arg1: *const super::c_void,
        arg2: *const super::c_void,
        arg3: size_t,
    ) -> super::c_int;
}
extern "C" {
    pub fn bcopy(arg1: *const super::c_void, arg2: *mut super::c_void, arg3: size_t);
}
extern "C" {
    pub fn bzero(arg1: *mut super::c_void, arg2: size_t);
}
extern "C" {
    pub fn explicit_bzero(arg1: *mut super::c_void, arg2: size_t);
}
extern "C" {
    pub fn ffs(arg1: super::c_int) -> super::c_int;
}
extern "C" {
    pub fn ffsl(arg1: super::c_long) -> super::c_int;
}
extern "C" {
    pub fn ffsll(arg1: super::c_longlong) -> super::c_int;
}
extern "C" {
    pub fn fls(arg1: super::c_int) -> super::c_int;
}
extern "C" {
    pub fn flsl(arg1: super::c_long) -> super::c_int;
}
extern "C" {
    pub fn flsll(arg1: super::c_longlong) -> super::c_int;
}
extern "C" {
    pub fn index(arg1: *const super::c_char, arg2: super::c_int) -> *mut super::c_char;
}
extern "C" {
    pub fn rindex(arg1: *const super::c_char, arg2: super::c_int) -> *mut super::c_char;
}
extern "C" {
    pub fn strcasecmp(arg1: *const super::c_char, arg2: *const super::c_char) -> super::c_int;
}
extern "C" {
    pub fn strncasecmp(
        arg1: *const super::c_char,
        arg2: *const super::c_char,
        arg3: size_t,
    ) -> super::c_int;
}
extern "C" {
    pub fn strcasecmp_l(
        arg1: *const super::c_char,
        arg2: *const super::c_char,
        arg3: locale_t,
    ) -> super::c_int;
}
extern "C" {
    pub fn strncasecmp_l(
        arg1: *const super::c_char,
        arg2: *const super::c_char,
        arg3: size_t,
        arg4: locale_t,
    ) -> super::c_int;
}
extern "C" {
    pub fn memchr(
        arg1: *const super::c_void,
        arg2: super::c_int,
        arg3: size_t,
    ) -> *mut super::c_void;
}
extern "C" {
    pub fn memcmp(
        arg1: *const super::c_void,
        arg2: *const super::c_void,
        arg3: size_t,
    ) -> super::c_int;
}
extern "C" {
    pub fn memcpy(
        arg1: *mut super::c_void,
        arg2: *const super::c_void,
        arg3: size_t,
    ) -> *mut super::c_void;
}
extern "C" {
    pub fn memmove(
        arg1: *mut super::c_void,
        arg2: *const super::c_void,
        arg3: size_t,
    ) -> *mut super::c_void;
}
extern "C" {
    pub fn memset(arg1: *mut super::c_void, arg2: super::c_int, arg3: size_t)
        -> *mut super::c_void;
}
extern "C" {
    pub fn strcat(arg1: *mut super::c_char, arg2: *const super::c_char) -> *mut super::c_char;
}
extern "C" {
    pub fn strchr(arg1: *const super::c_char, arg2: super::c_int) -> *mut super::c_char;
}
extern "C" {
    pub fn strcmp(arg1: *const super::c_char, arg2: *const super::c_char) -> super::c_int;
}
extern "C" {
    pub fn strcoll(arg1: *const super::c_char, arg2: *const super::c_char) -> super::c_int;
}
extern "C" {
    pub fn strcpy(arg1: *mut super::c_char, arg2: *const super::c_char) -> *mut super::c_char;
}
extern "C" {
    pub fn strcspn(arg1: *const super::c_char, arg2: *const super::c_char) -> size_t;
}
extern "C" {
    pub fn strerror(arg1: super::c_int) -> *mut super::c_char;
}
extern "C" {
    pub fn strlen(arg1: *const super::c_char) -> size_t;
}
extern "C" {
    pub fn strncat(
        arg1: *mut super::c_char,
        arg2: *const super::c_char,
        arg3: size_t,
    ) -> *mut super::c_char;
}
extern "C" {
    pub fn strncmp(
        arg1: *const super::c_char,
        arg2: *const super::c_char,
        arg3: size_t,
    ) -> super::c_int;
}
extern "C" {
    pub fn strncpy(
        arg1: *mut super::c_char,
        arg2: *const super::c_char,
        arg3: size_t,
    ) -> *mut super::c_char;
}
extern "C" {
    pub fn strpbrk(arg1: *const super::c_char, arg2: *const super::c_char) -> *mut super::c_char;
}
extern "C" {
    pub fn strrchr(arg1: *const super::c_char, arg2: super::c_int) -> *mut super::c_char;
}
extern "C" {
    pub fn strspn(arg1: *const super::c_char, arg2: *const super::c_char) -> size_t;
}
extern "C" {
    pub fn strstr(arg1: *const super::c_char, arg2: *const super::c_char) -> *mut super::c_char;
}
extern "C" {
    pub fn strtok(arg1: *mut super::c_char, arg2: *const super::c_char) -> *mut super::c_char;
}
extern "C" {
    pub fn strxfrm(arg1: *mut super::c_char, arg2: *const super::c_char, arg3: size_t) -> size_t;
}
extern "C" {
    pub fn strcoll_l(
        arg1: *const super::c_char,
        arg2: *const super::c_char,
        arg3: locale_t,
    ) -> super::c_int;
}
extern "C" {
    pub fn strerror_l(arg1: super::c_int, arg2: locale_t) -> *mut super::c_char;
}
extern "C" {
    pub fn strxfrm_l(
        arg1: *mut super::c_char,
        arg2: *const super::c_char,
        arg3: size_t,
        arg4: locale_t,
    ) -> size_t;
}
extern "C" {
    pub fn strtok_r(
        arg1: *mut super::c_char,
        arg2: *const super::c_char,
        arg3: *mut *mut super::c_char,
    ) -> *mut super::c_char;
}
extern "C" {
    pub fn timingsafe_bcmp(
        arg1: *const super::c_void,
        arg2: *const super::c_void,
        arg3: size_t,
    ) -> super::c_int;
}
extern "C" {
    pub fn timingsafe_memcmp(
        arg1: *const super::c_void,
        arg2: *const super::c_void,
        arg3: size_t,
    ) -> super::c_int;
}
extern "C" {
    pub fn memccpy(
        arg1: *mut super::c_void,
        arg2: *const super::c_void,
        arg3: super::c_int,
        arg4: size_t,
    ) -> *mut super::c_void;
}
extern "C" {
    pub fn stpcpy(arg1: *mut super::c_char, arg2: *const super::c_char) -> *mut super::c_char;
}
extern "C" {
    pub fn stpncpy(
        arg1: *mut super::c_char,
        arg2: *const super::c_char,
        arg3: size_t,
    ) -> *mut super::c_char;
}
extern "C" {
    pub fn strdup(arg1: *const super::c_char) -> *mut super::c_char;
}
extern "C" {
    pub fn _strdup_r(arg1: *mut _reent, arg2: *const super::c_char) -> *mut super::c_char;
}
extern "C" {
    pub fn strndup(arg1: *const super::c_char, arg2: size_t) -> *mut super::c_char;
}
extern "C" {
    pub fn _strndup_r(
        arg1: *mut _reent,
        arg2: *const super::c_char,
        arg3: size_t,
    ) -> *mut super::c_char;
}
extern "C" {
    #[link_name = "\u{1}__xpg_strerror_r"]
    pub fn strerror_r(arg1: super::c_int, arg2: *mut super::c_char, arg3: size_t) -> super::c_int;
}
extern "C" {
    pub fn _strerror_r(
        arg1: *mut _reent,
        arg2: super::c_int,
        arg3: super::c_int,
        arg4: *mut super::c_int,
    ) -> *mut super::c_char;
}
extern "C" {
    pub fn strlcat(arg1: *mut super::c_char, arg2: *const super::c_char, arg3: size_t) -> size_t;
}
extern "C" {
    pub fn strlcpy(arg1: *mut super::c_char, arg2: *const super::c_char, arg3: size_t) -> size_t;
}
extern "C" {
    pub fn strnlen(arg1: *const super::c_char, arg2: size_t) -> size_t;
}
extern "C" {
    pub fn strsep(arg1: *mut *mut super::c_char, arg2: *const super::c_char) -> *mut super::c_char;
}
extern "C" {
    pub fn strnstr(
        arg1: *const super::c_char,
        arg2: *const super::c_char,
        arg3: size_t,
    ) -> *mut super::c_char;
}
extern "C" {
    pub fn strlwr(arg1: *mut super::c_char) -> *mut super::c_char;
}
extern "C" {
    pub fn strupr(arg1: *mut super::c_char) -> *mut super::c_char;
}
extern "C" {
    pub fn strsignal(__signo: super::c_int) -> *mut super::c_char;
}
extern "C" {
    pub fn isalnum(__c: super::c_int) -> super::c_int;
}
extern "C" {
    pub fn isalpha(__c: super::c_int) -> super::c_int;
}
extern "C" {
    pub fn iscntrl(__c: super::c_int) -> super::c_int;
}
extern "C" {
    pub fn isdigit(__c: super::c_int) -> super::c_int;
}
extern "C" {
    pub fn isgraph(__c: super::c_int) -> super::c_int;
}
extern "C" {
    pub fn islower(__c: super::c_int) -> super::c_int;
}
extern "C" {
    pub fn isprint(__c: super::c_int) -> super::c_int;
}
extern "C" {
    pub fn ispunct(__c: super::c_int) -> super::c_int;
}
extern "C" {
    pub fn isspace(__c: super::c_int) -> super::c_int;
}
extern "C" {
    pub fn isupper(__c: super::c_int) -> super::c_int;
}
extern "C" {
    pub fn isxdigit(__c: super::c_int) -> super::c_int;
}
extern "C" {
    pub fn tolower(__c: super::c_int) -> super::c_int;
}
extern "C" {
    pub fn toupper(__c: super::c_int) -> super::c_int;
}
extern "C" {
    pub fn isblank(__c: super::c_int) -> super::c_int;
}
extern "C" {
    pub fn isascii(__c: super::c_int) -> super::c_int;
}
extern "C" {
    pub fn toascii(__c: super::c_int) -> super::c_int;
}
extern "C" {
    pub fn isalnum_l(__c: super::c_int, __l: locale_t) -> super::c_int;
}
extern "C" {
    pub fn isalpha_l(__c: super::c_int, __l: locale_t) -> super::c_int;
}
extern "C" {
    pub fn isblank_l(__c: super::c_int, __l: locale_t) -> super::c_int;
}
extern "C" {
    pub fn iscntrl_l(__c: super::c_int, __l: locale_t) -> super::c_int;
}
extern "C" {
    pub fn isdigit_l(__c: super::c_int, __l: locale_t) -> super::c_int;
}
extern "C" {
    pub fn isgraph_l(__c: super::c_int, __l: locale_t) -> super::c_int;
}
extern "C" {
    pub fn islower_l(__c: super::c_int, __l: locale_t) -> super::c_int;
}
extern "C" {
    pub fn isprint_l(__c: super::c_int, __l: locale_t) -> super::c_int;
}
extern "C" {
    pub fn ispunct_l(__c: super::c_int, __l: locale_t) -> super::c_int;
}
extern "C" {
    pub fn isspace_l(__c: super::c_int, __l: locale_t) -> super::c_int;
}
extern "C" {
    pub fn isupper_l(__c: super::c_int, __l: locale_t) -> super::c_int;
}
extern "C" {
    pub fn isxdigit_l(__c: super::c_int, __l: locale_t) -> super::c_int;
}
extern "C" {
    pub fn tolower_l(__c: super::c_int, __l: locale_t) -> super::c_int;
}
extern "C" {
    pub fn toupper_l(__c: super::c_int, __l: locale_t) -> super::c_int;
}
extern "C" {
    pub fn isascii_l(__c: super::c_int, __l: locale_t) -> super::c_int;
}
extern "C" {
    pub fn toascii_l(__c: super::c_int, __l: locale_t) -> super::c_int;
}
extern "C" {
    pub fn __locale_ctype_ptr() -> *const super::c_char;
}
extern "C" {
    pub static mut _ctype_: [super::c_char; 0usize];
}
pub type int_least8_t = __int_least8_t;
pub type uint_least8_t = __uint_least8_t;
pub type int_least16_t = __int_least16_t;
pub type uint_least16_t = __uint_least16_t;
pub type int_least32_t = __int_least32_t;
pub type uint_least32_t = __uint_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = super::c_schar;
pub type uint_fast8_t = super::c_uchar;
pub type int_fast16_t = super::c_short;
pub type uint_fast16_t = super::c_ushort;
pub type int_fast32_t = super::c_int;
pub type uint_fast32_t = super::c_uint;
pub type int_fast64_t = super::c_longlong;
pub type uint_fast64_t = super::c_ulonglong;
#[repr(C)]
pub struct imaxdiv_t {
    pub quot: intmax_t,
    pub rem: intmax_t,
}
#[test]
fn bindgen_test_layout_imaxdiv_t() {
    assert_eq!(
        ::core::mem::size_of::<imaxdiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(imaxdiv_t))
    );
    assert_eq!(
        ::core::mem::align_of::<imaxdiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(imaxdiv_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<imaxdiv_t>())).quot as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(imaxdiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<imaxdiv_t>())).rem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(imaxdiv_t),
            "::",
            stringify!(rem)
        )
    );
}
extern "C" {
    pub fn imaxabs(j: intmax_t) -> intmax_t;
}
extern "C" {
    pub fn imaxdiv(numer: intmax_t, denomer: intmax_t) -> imaxdiv_t;
}
extern "C" {
    pub fn strtoimax(
        arg1: *const super::c_char,
        arg2: *mut *mut super::c_char,
        arg3: super::c_int,
    ) -> intmax_t;
}
extern "C" {
    pub fn _strtoimax_r(
        arg1: *mut _reent,
        arg2: *const super::c_char,
        arg3: *mut *mut super::c_char,
        arg4: super::c_int,
    ) -> intmax_t;
}
extern "C" {
    pub fn strtoumax(
        arg1: *const super::c_char,
        arg2: *mut *mut super::c_char,
        arg3: super::c_int,
    ) -> uintmax_t;
}
extern "C" {
    pub fn _strtoumax_r(
        arg1: *mut _reent,
        arg2: *const super::c_char,
        arg3: *mut *mut super::c_char,
        arg4: super::c_int,
    ) -> uintmax_t;
}
extern "C" {
    pub fn wcstoimax(arg1: *const u32, arg2: *mut *mut u32, arg3: super::c_int) -> intmax_t;
}
extern "C" {
    pub fn _wcstoimax_r(
        arg1: *mut _reent,
        arg2: *const u32,
        arg3: *mut *mut u32,
        arg4: super::c_int,
    ) -> intmax_t;
}
extern "C" {
    pub fn wcstoumax(arg1: *const u32, arg2: *mut *mut u32, arg3: super::c_int) -> uintmax_t;
}
extern "C" {
    pub fn _wcstoumax_r(
        arg1: *mut _reent,
        arg2: *const u32,
        arg3: *mut *mut u32,
        arg4: super::c_int,
    ) -> uintmax_t;
}
extern "C" {
    pub fn strtoimax_l(
        arg1: *const super::c_char,
        _restrict: *mut *mut super::c_char,
        arg2: super::c_int,
        arg3: locale_t,
    ) -> intmax_t;
}
extern "C" {
    pub fn strtoumax_l(
        arg1: *const super::c_char,
        _restrict: *mut *mut super::c_char,
        arg2: super::c_int,
        arg3: locale_t,
    ) -> uintmax_t;
}
extern "C" {
    pub fn wcstoimax_l(
        arg1: *const u32,
        _restrict: *mut *mut u32,
        arg2: super::c_int,
        arg3: locale_t,
    ) -> intmax_t;
}
extern "C" {
    pub fn wcstoumax_l(
        arg1: *const u32,
        _restrict: *mut *mut u32,
        arg2: super::c_int,
        arg3: locale_t,
    ) -> uintmax_t;
}
pub type prog_void = super::c_void;
pub type prog_char = super::c_char;
pub type prog_uchar = super::c_uchar;
pub type prog_int8_t = i8;
pub type prog_uint8_t = u8;
pub type prog_int16_t = i16;
pub type prog_uint16_t = u16;
pub type prog_int32_t = i32;
pub type prog_uint32_t = u32;
#[repr(C)]
pub struct __FlashStringHelper {
    _unused: [u8; 0],
}
#[repr(C)]
pub struct String {
    pub buffer: *mut super::c_char,
    pub capacity: super::c_uint,
    pub len: super::c_uint,
}
pub type String_StringIfHelperType = ::core::option::Option<unsafe extern "C" fn()>;
#[test]
fn bindgen_test_layout_String() {
    assert_eq!(
        ::core::mem::size_of::<String>(),
        12usize,
        concat!("Size of: ", stringify!(String))
    );
    assert_eq!(
        ::core::mem::align_of::<String>(),
        4usize,
        concat!("Alignment of ", stringify!(String))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<String>())).buffer as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(String),
            "::",
            stringify!(buffer)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<String>())).capacity as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(String),
            "::",
            stringify!(capacity)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<String>())).len as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(String),
            "::",
            stringify!(len)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN6String7reserveEj"]
    pub fn String_reserve(this: *mut String, size: super::c_uint) -> super::c_uchar;
}
extern "C" {
    #[link_name = "\u{1}_ZN6String6concatERKS_"]
    pub fn String_concat(this: *mut String, str: *const String) -> super::c_uchar;
}
extern "C" {
    #[link_name = "\u{1}_ZN6String6concatEPKc"]
    pub fn String_concat1(this: *mut String, cstr: *const super::c_char) -> super::c_uchar;
}
extern "C" {
    #[link_name = "\u{1}_ZN6String6concatEc"]
    pub fn String_concat2(this: *mut String, c: super::c_char) -> super::c_uchar;
}
extern "C" {
    #[link_name = "\u{1}_ZN6String6concatEh"]
    pub fn String_concat3(this: *mut String, c: super::c_uchar) -> super::c_uchar;
}
extern "C" {
    #[link_name = "\u{1}_ZN6String6concatEi"]
    pub fn String_concat4(this: *mut String, num: super::c_int) -> super::c_uchar;
}
extern "C" {
    #[link_name = "\u{1}_ZN6String6concatEj"]
    pub fn String_concat5(this: *mut String, num: super::c_uint) -> super::c_uchar;
}
extern "C" {
    #[link_name = "\u{1}_ZN6String6concatEl"]
    pub fn String_concat6(this: *mut String, num: super::c_long) -> super::c_uchar;
}
extern "C" {
    #[link_name = "\u{1}_ZN6String6concatEm"]
    pub fn String_concat7(this: *mut String, num: super::c_ulong) -> super::c_uchar;
}
extern "C" {
    #[link_name = "\u{1}_ZN6String6concatEf"]
    pub fn String_concat8(this: *mut String, num: f32) -> super::c_uchar;
}
extern "C" {
    #[link_name = "\u{1}_ZN6String6concatEd"]
    pub fn String_concat9(this: *mut String, num: f64) -> super::c_uchar;
}
extern "C" {
    #[link_name = "\u{1}_ZN6String6concatEPK19__FlashStringHelper"]
    pub fn String_concat10(this: *mut String, str: *const __FlashStringHelper) -> super::c_uchar;
}
extern "C" {
    #[link_name = "\u{1}_ZNK6String9compareToERKS_"]
    pub fn String_compareTo(this: *const String, s: *const String) -> super::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZNK6String6equalsERKS_"]
    pub fn String_equals(this: *const String, s: *const String) -> super::c_uchar;
}
extern "C" {
    #[link_name = "\u{1}_ZNK6String6equalsEPKc"]
    pub fn String_equals1(this: *const String, cstr: *const super::c_char) -> super::c_uchar;
}
extern "C" {
    #[link_name = "\u{1}_ZNK6String16equalsIgnoreCaseERKS_"]
    pub fn String_equalsIgnoreCase(this: *const String, s: *const String) -> super::c_uchar;
}
extern "C" {
    #[link_name = "\u{1}_ZNK6String10startsWithERKS_"]
    pub fn String_startsWith(this: *const String, prefix: *const String) -> super::c_uchar;
}
extern "C" {
    #[link_name = "\u{1}_ZNK6String10startsWithERKS_j"]
    pub fn String_startsWith1(
        this: *const String,
        prefix: *const String,
        offset: super::c_uint,
    ) -> super::c_uchar;
}
extern "C" {
    #[link_name = "\u{1}_ZNK6String8endsWithERKS_"]
    pub fn String_endsWith(this: *const String, suffix: *const String) -> super::c_uchar;
}
extern "C" {
    #[link_name = "\u{1}_ZNK6String6charAtEj"]
    pub fn String_charAt(this: *const String, index: super::c_uint) -> super::c_char;
}
extern "C" {
    #[link_name = "\u{1}_ZN6String9setCharAtEjc"]
    pub fn String_setCharAt(this: *mut String, index: super::c_uint, c: super::c_char);
}
extern "C" {
    #[link_name = "\u{1}_ZNK6String8getBytesEPhjj"]
    pub fn String_getBytes(
        this: *const String,
        buf: *mut super::c_uchar,
        bufsize: super::c_uint,
        index: super::c_uint,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK6String7indexOfEc"]
    pub fn String_indexOf(this: *const String, ch: super::c_char) -> super::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZNK6String7indexOfEcj"]
    pub fn String_indexOf1(
        this: *const String,
        ch: super::c_char,
        fromIndex: super::c_uint,
    ) -> super::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZNK6String7indexOfERKS_"]
    pub fn String_indexOf2(this: *const String, str: *const String) -> super::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZNK6String7indexOfERKS_j"]
    pub fn String_indexOf3(
        this: *const String,
        str: *const String,
        fromIndex: super::c_uint,
    ) -> super::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZNK6String11lastIndexOfEc"]
    pub fn String_lastIndexOf(this: *const String, ch: super::c_char) -> super::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZNK6String11lastIndexOfEcj"]
    pub fn String_lastIndexOf1(
        this: *const String,
        ch: super::c_char,
        fromIndex: super::c_uint,
    ) -> super::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZNK6String11lastIndexOfERKS_"]
    pub fn String_lastIndexOf2(this: *const String, str: *const String) -> super::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZNK6String11lastIndexOfERKS_j"]
    pub fn String_lastIndexOf3(
        this: *const String,
        str: *const String,
        fromIndex: super::c_uint,
    ) -> super::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZNK6String9substringEjj"]
    pub fn String_substring(
        this: *const String,
        beginIndex: super::c_uint,
        endIndex: super::c_uint,
    ) -> String;
}
extern "C" {
    #[link_name = "\u{1}_ZN6String7replaceEcc"]
    pub fn String_replace(this: *mut String, find: super::c_char, replace: super::c_char);
}
extern "C" {
    #[link_name = "\u{1}_ZN6String7replaceERKS_S1_"]
    pub fn String_replace1(this: *mut String, find: *const String, replace: *const String);
}
extern "C" {
    #[link_name = "\u{1}_ZN6String6removeEj"]
    pub fn String_remove(this: *mut String, index: super::c_uint);
}
extern "C" {
    #[link_name = "\u{1}_ZN6String6removeEjj"]
    pub fn String_remove1(this: *mut String, index: super::c_uint, count: super::c_uint);
}
extern "C" {
    #[link_name = "\u{1}_ZN6String11toLowerCaseEv"]
    pub fn String_toLowerCase(this: *mut String);
}
extern "C" {
    #[link_name = "\u{1}_ZN6String11toUpperCaseEv"]
    pub fn String_toUpperCase(this: *mut String);
}
extern "C" {
    #[link_name = "\u{1}_ZN6String4trimEv"]
    pub fn String_trim(this: *mut String);
}
extern "C" {
    #[link_name = "\u{1}_ZNK6String5toIntEv"]
    pub fn String_toInt(this: *const String) -> super::c_long;
}
extern "C" {
    #[link_name = "\u{1}_ZNK6String7toFloatEv"]
    pub fn String_toFloat(this: *const String) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_ZN6String4initEv"]
    pub fn String_init(this: *mut String);
}
extern "C" {
    #[link_name = "\u{1}_ZN6String10invalidateEv"]
    pub fn String_invalidate(this: *mut String);
}
extern "C" {
    #[link_name = "\u{1}_ZN6String12changeBufferEj"]
    pub fn String_changeBuffer(this: *mut String, maxStrLen: super::c_uint) -> super::c_uchar;
}
extern "C" {
    #[link_name = "\u{1}_ZN6String6concatEPKcj"]
    pub fn String_concat11(
        this: *mut String,
        cstr: *const super::c_char,
        length: super::c_uint,
    ) -> super::c_uchar;
}
extern "C" {
    #[link_name = "\u{1}_ZN6String4copyEPKcj"]
    pub fn String_copy(
        this: *mut String,
        cstr: *const super::c_char,
        length: super::c_uint,
    ) -> *mut String;
}
extern "C" {
    #[link_name = "\u{1}_ZN6String4copyEPK19__FlashStringHelperj"]
    pub fn String_copy1(
        this: *mut String,
        pstr: *const __FlashStringHelper,
        length: super::c_uint,
    ) -> *mut String;
}
extern "C" {
    #[link_name = "\u{1}_ZN6String4moveERS_"]
    pub fn String_move(this: *mut String, rhs: *mut String);
}
extern "C" {
    #[link_name = "\u{1}_ZN6StringC1EPKc"]
    pub fn String_String(this: *mut String, cstr: *const super::c_char);
}
extern "C" {
    #[link_name = "\u{1}_ZN6StringC1ERKS_"]
    pub fn String_String1(this: *mut String, str: *const String);
}
extern "C" {
    #[link_name = "\u{1}_ZN6StringC1EPK19__FlashStringHelper"]
    pub fn String_String2(this: *mut String, str: *const __FlashStringHelper);
}
extern "C" {
    #[link_name = "\u{1}_ZN6StringC1EOS_"]
    pub fn String_String3(this: *mut String, rval: *mut String);
}
extern "C" {
    #[link_name = "\u{1}_ZN6StringC1EO15StringSumHelper"]
    pub fn String_String4(this: *mut String, rval: *mut StringSumHelper);
}
extern "C" {
    #[link_name = "\u{1}_ZN6StringC1Ec"]
    pub fn String_String5(this: *mut String, c: super::c_char);
}
extern "C" {
    #[link_name = "\u{1}_ZN6StringC1Ehh"]
    pub fn String_String6(this: *mut String, arg1: super::c_uchar, base: super::c_uchar);
}
extern "C" {
    #[link_name = "\u{1}_ZN6StringC1Eih"]
    pub fn String_String7(this: *mut String, arg1: super::c_int, base: super::c_uchar);
}
extern "C" {
    #[link_name = "\u{1}_ZN6StringC1Ejh"]
    pub fn String_String8(this: *mut String, arg1: super::c_uint, base: super::c_uchar);
}
extern "C" {
    #[link_name = "\u{1}_ZN6StringC1Elh"]
    pub fn String_String9(this: *mut String, arg1: super::c_long, base: super::c_uchar);
}
extern "C" {
    #[link_name = "\u{1}_ZN6StringC1Emh"]
    pub fn String_String10(this: *mut String, arg1: super::c_ulong, base: super::c_uchar);
}
extern "C" {
    #[link_name = "\u{1}_ZN6StringC1Efh"]
    pub fn String_String11(this: *mut String, arg1: f32, decimalPlaces: super::c_uchar);
}
extern "C" {
    #[link_name = "\u{1}_ZN6StringC1Edh"]
    pub fn String_String12(this: *mut String, arg1: f64, decimalPlaces: super::c_uchar);
}
extern "C" {
    #[link_name = "\u{1}_ZN6StringD1Ev"]
    pub fn String_String_destructor(this: *mut String);
}
impl String {
    #[inline]
    pub unsafe fn reserve(&mut self, size: super::c_uint) -> super::c_uchar {
        String_reserve(self, size)
    }
    #[inline]
    pub unsafe fn concat(&mut self, str: *const String) -> super::c_uchar {
        String_concat(self, str)
    }
    #[inline]
    pub unsafe fn concat1(&mut self, cstr: *const super::c_char) -> super::c_uchar {
        String_concat1(self, cstr)
    }
    #[inline]
    pub unsafe fn concat2(&mut self, c: super::c_char) -> super::c_uchar {
        String_concat2(self, c)
    }
    #[inline]
    pub unsafe fn concat3(&mut self, c: super::c_uchar) -> super::c_uchar {
        String_concat3(self, c)
    }
    #[inline]
    pub unsafe fn concat4(&mut self, num: super::c_int) -> super::c_uchar {
        String_concat4(self, num)
    }
    #[inline]
    pub unsafe fn concat5(&mut self, num: super::c_uint) -> super::c_uchar {
        String_concat5(self, num)
    }
    #[inline]
    pub unsafe fn concat6(&mut self, num: super::c_long) -> super::c_uchar {
        String_concat6(self, num)
    }
    #[inline]
    pub unsafe fn concat7(&mut self, num: super::c_ulong) -> super::c_uchar {
        String_concat7(self, num)
    }
    #[inline]
    pub unsafe fn concat8(&mut self, num: f32) -> super::c_uchar {
        String_concat8(self, num)
    }
    #[inline]
    pub unsafe fn concat9(&mut self, num: f64) -> super::c_uchar {
        String_concat9(self, num)
    }
    #[inline]
    pub unsafe fn concat10(&mut self, str: *const __FlashStringHelper) -> super::c_uchar {
        String_concat10(self, str)
    }
    #[inline]
    pub unsafe fn compareTo(&self, s: *const String) -> super::c_int {
        String_compareTo(self, s)
    }
    #[inline]
    pub unsafe fn equals(&self, s: *const String) -> super::c_uchar {
        String_equals(self, s)
    }
    #[inline]
    pub unsafe fn equals1(&self, cstr: *const super::c_char) -> super::c_uchar {
        String_equals1(self, cstr)
    }
    #[inline]
    pub unsafe fn equalsIgnoreCase(&self, s: *const String) -> super::c_uchar {
        String_equalsIgnoreCase(self, s)
    }
    #[inline]
    pub unsafe fn startsWith(&self, prefix: *const String) -> super::c_uchar {
        String_startsWith(self, prefix)
    }
    #[inline]
    pub unsafe fn startsWith1(
        &self,
        prefix: *const String,
        offset: super::c_uint,
    ) -> super::c_uchar {
        String_startsWith1(self, prefix, offset)
    }
    #[inline]
    pub unsafe fn endsWith(&self, suffix: *const String) -> super::c_uchar {
        String_endsWith(self, suffix)
    }
    #[inline]
    pub unsafe fn charAt(&self, index: super::c_uint) -> super::c_char {
        String_charAt(self, index)
    }
    #[inline]
    pub unsafe fn setCharAt(&mut self, index: super::c_uint, c: super::c_char) {
        String_setCharAt(self, index, c)
    }
    #[inline]
    pub unsafe fn getBytes(
        &self,
        buf: *mut super::c_uchar,
        bufsize: super::c_uint,
        index: super::c_uint,
    ) {
        String_getBytes(self, buf, bufsize, index)
    }
    #[inline]
    pub unsafe fn indexOf(&self, ch: super::c_char) -> super::c_int {
        String_indexOf(self, ch)
    }
    #[inline]
    pub unsafe fn indexOf1(&self, ch: super::c_char, fromIndex: super::c_uint) -> super::c_int {
        String_indexOf1(self, ch, fromIndex)
    }
    #[inline]
    pub unsafe fn indexOf2(&self, str: *const String) -> super::c_int {
        String_indexOf2(self, str)
    }
    #[inline]
    pub unsafe fn indexOf3(&self, str: *const String, fromIndex: super::c_uint) -> super::c_int {
        String_indexOf3(self, str, fromIndex)
    }
    #[inline]
    pub unsafe fn lastIndexOf(&self, ch: super::c_char) -> super::c_int {
        String_lastIndexOf(self, ch)
    }
    #[inline]
    pub unsafe fn lastIndexOf1(&self, ch: super::c_char, fromIndex: super::c_uint) -> super::c_int {
        String_lastIndexOf1(self, ch, fromIndex)
    }
    #[inline]
    pub unsafe fn lastIndexOf2(&self, str: *const String) -> super::c_int {
        String_lastIndexOf2(self, str)
    }
    #[inline]
    pub unsafe fn lastIndexOf3(
        &self,
        str: *const String,
        fromIndex: super::c_uint,
    ) -> super::c_int {
        String_lastIndexOf3(self, str, fromIndex)
    }
    #[inline]
    pub unsafe fn substring(&self, beginIndex: super::c_uint, endIndex: super::c_uint) -> String {
        String_substring(self, beginIndex, endIndex)
    }
    #[inline]
    pub unsafe fn replace(&mut self, find: super::c_char, replace: super::c_char) {
        String_replace(self, find, replace)
    }
    #[inline]
    pub unsafe fn replace1(&mut self, find: *const String, replace: *const String) {
        String_replace1(self, find, replace)
    }
    #[inline]
    pub unsafe fn remove(&mut self, index: super::c_uint) {
        String_remove(self, index)
    }
    #[inline]
    pub unsafe fn remove1(&mut self, index: super::c_uint, count: super::c_uint) {
        String_remove1(self, index, count)
    }
    #[inline]
    pub unsafe fn toLowerCase(&mut self) {
        String_toLowerCase(self)
    }
    #[inline]
    pub unsafe fn toUpperCase(&mut self) {
        String_toUpperCase(self)
    }
    #[inline]
    pub unsafe fn trim(&mut self) {
        String_trim(self)
    }
    #[inline]
    pub unsafe fn toInt(&self) -> super::c_long {
        String_toInt(self)
    }
    #[inline]
    pub unsafe fn toFloat(&self) -> f32 {
        String_toFloat(self)
    }
    #[inline]
    pub unsafe fn init(&mut self) {
        String_init(self)
    }
    #[inline]
    pub unsafe fn invalidate(&mut self) {
        String_invalidate(self)
    }
    #[inline]
    pub unsafe fn changeBuffer(&mut self, maxStrLen: super::c_uint) -> super::c_uchar {
        String_changeBuffer(self, maxStrLen)
    }
    #[inline]
    pub unsafe fn concat11(
        &mut self,
        cstr: *const super::c_char,
        length: super::c_uint,
    ) -> super::c_uchar {
        String_concat11(self, cstr, length)
    }
    #[inline]
    pub unsafe fn copy(
        &mut self,
        cstr: *const super::c_char,
        length: super::c_uint,
    ) -> *mut String {
        String_copy(self, cstr, length)
    }
    #[inline]
    pub unsafe fn copy1(
        &mut self,
        pstr: *const __FlashStringHelper,
        length: super::c_uint,
    ) -> *mut String {
        String_copy1(self, pstr, length)
    }
    #[inline]
    pub unsafe fn move_(&mut self, rhs: *mut String) {
        String_move(self, rhs)
    }
    #[inline]
    pub unsafe fn new(cstr: *const super::c_char) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        String_String(__bindgen_tmp.as_mut_ptr(), cstr);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(str: *const String) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        String_String1(__bindgen_tmp.as_mut_ptr(), str);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new2(str: *const __FlashStringHelper) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        String_String2(__bindgen_tmp.as_mut_ptr(), str);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new3(rval: *mut String) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        String_String3(__bindgen_tmp.as_mut_ptr(), rval);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new4(rval: *mut StringSumHelper) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        String_String4(__bindgen_tmp.as_mut_ptr(), rval);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new5(c: super::c_char) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        String_String5(__bindgen_tmp.as_mut_ptr(), c);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new6(arg1: super::c_uchar, base: super::c_uchar) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        String_String6(__bindgen_tmp.as_mut_ptr(), arg1, base);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new7(arg1: super::c_int, base: super::c_uchar) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        String_String7(__bindgen_tmp.as_mut_ptr(), arg1, base);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new8(arg1: super::c_uint, base: super::c_uchar) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        String_String8(__bindgen_tmp.as_mut_ptr(), arg1, base);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new9(arg1: super::c_long, base: super::c_uchar) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        String_String9(__bindgen_tmp.as_mut_ptr(), arg1, base);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new10(arg1: super::c_ulong, base: super::c_uchar) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        String_String10(__bindgen_tmp.as_mut_ptr(), arg1, base);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new11(arg1: f32, decimalPlaces: super::c_uchar) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        String_String11(__bindgen_tmp.as_mut_ptr(), arg1, decimalPlaces);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new12(arg1: f64, decimalPlaces: super::c_uchar) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        String_String12(__bindgen_tmp.as_mut_ptr(), arg1, decimalPlaces);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        String_String_destructor(self)
    }
}
#[repr(C)]
pub struct StringSumHelper {
    pub _base: String,
}
#[test]
fn bindgen_test_layout_StringSumHelper() {
    assert_eq!(
        ::core::mem::size_of::<StringSumHelper>(),
        12usize,
        concat!("Size of: ", stringify!(StringSumHelper))
    );
    assert_eq!(
        ::core::mem::align_of::<StringSumHelper>(),
        4usize,
        concat!("Alignment of ", stringify!(StringSumHelper))
    );
}
extern "C" {
    pub fn dtostrf(
        val: f64,
        width: super::c_schar,
        prec: super::c_uchar,
        sout: *mut super::c_char,
    ) -> *mut super::c_char;
}
pub type uint8 = super::c_uchar;
pub type uint16 = super::c_ushort;
pub type uint32 = u32;
pub type uint64 = super::c_ulonglong;
pub type int8 = super::c_schar;
pub type int16 = super::c_short;
pub type int32 = super::c_int;
pub type int64 = super::c_longlong;
pub type voidFuncPtr = ::core::option::Option<unsafe extern "C" fn()>;
pub type voidArgumentFuncPtr =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut super::c_void)>;
#[doc = " EXTI register map type"]
#[repr(C)]
pub struct exti_reg_map {
    #[doc = "< Interrupt mask register"]
    pub IMR: uint32,
    #[doc = "< Event mask register"]
    pub EMR: uint32,
    #[doc = "< Rising trigger selection register"]
    pub RTSR: uint32,
    #[doc = "< Falling trigger selection register"]
    pub FTSR: uint32,
    #[doc = "< Software interrupt event register"]
    pub SWIER: uint32,
    #[doc = "< Pending register"]
    pub PR: uint32,
}
#[test]
fn bindgen_test_layout_exti_reg_map() {
    assert_eq!(
        ::core::mem::size_of::<exti_reg_map>(),
        24usize,
        concat!("Size of: ", stringify!(exti_reg_map))
    );
    assert_eq!(
        ::core::mem::align_of::<exti_reg_map>(),
        4usize,
        concat!("Alignment of ", stringify!(exti_reg_map))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<exti_reg_map>())).IMR as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(exti_reg_map),
            "::",
            stringify!(IMR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<exti_reg_map>())).EMR as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(exti_reg_map),
            "::",
            stringify!(EMR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<exti_reg_map>())).RTSR as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(exti_reg_map),
            "::",
            stringify!(RTSR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<exti_reg_map>())).FTSR as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(exti_reg_map),
            "::",
            stringify!(FTSR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<exti_reg_map>())).SWIER as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(exti_reg_map),
            "::",
            stringify!(SWIER)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<exti_reg_map>())).PR as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(exti_reg_map),
            "::",
            stringify!(PR)
        )
    );
}
#[doc = "< EXTI line 0"]
pub const exti_num_EXTI0: exti_num = 0;
#[doc = "< EXTI line 1"]
pub const exti_num_EXTI1: exti_num = 1;
#[doc = "< EXTI line 2"]
pub const exti_num_EXTI2: exti_num = 2;
#[doc = "< EXTI line 3"]
pub const exti_num_EXTI3: exti_num = 3;
#[doc = "< EXTI line 4"]
pub const exti_num_EXTI4: exti_num = 4;
#[doc = "< EXTI line 5"]
pub const exti_num_EXTI5: exti_num = 5;
#[doc = "< EXTI line 6"]
pub const exti_num_EXTI6: exti_num = 6;
#[doc = "< EXTI line 7"]
pub const exti_num_EXTI7: exti_num = 7;
#[doc = "< EXTI line 8"]
pub const exti_num_EXTI8: exti_num = 8;
#[doc = "< EXTI line 9"]
pub const exti_num_EXTI9: exti_num = 9;
#[doc = "< EXTI line 10"]
pub const exti_num_EXTI10: exti_num = 10;
#[doc = "< EXTI line 11"]
pub const exti_num_EXTI11: exti_num = 11;
#[doc = "< EXTI line 12"]
pub const exti_num_EXTI12: exti_num = 12;
#[doc = "< EXTI line 13"]
pub const exti_num_EXTI13: exti_num = 13;
#[doc = "< EXTI line 14"]
pub const exti_num_EXTI14: exti_num = 14;
#[doc = "< EXTI line 15"]
pub const exti_num_EXTI15: exti_num = 15;
#[doc = " EXTI line."]
pub type exti_num = u32;
#[doc = "< Use PAx pin"]
pub const exti_cfg_EXTI_PA: exti_cfg = 0;
#[doc = "< Use PBx pin"]
pub const exti_cfg_EXTI_PB: exti_cfg = 1;
#[doc = "< Use PCx pin"]
pub const exti_cfg_EXTI_PC: exti_cfg = 2;
#[doc = "< Use PDx pin"]
pub const exti_cfg_EXTI_PD: exti_cfg = 3;
#[doc = "< Use PEx pin"]
pub const exti_cfg_EXTI_PE: exti_cfg = 4;
#[doc = "< Use PFx pin"]
pub const exti_cfg_EXTI_PF: exti_cfg = 5;
#[doc = "< Use PGx pin"]
pub const exti_cfg_EXTI_PG: exti_cfg = 6;
#[doc = "< Use PHx pin"]
pub const exti_cfg_EXTI_PH: exti_cfg = 7;
#[doc = "< Use PIx pin"]
pub const exti_cfg_EXTI_PI: exti_cfg = 8;
#[doc = " @brief EXTI port configuration"]
#[doc = ""]
#[doc = " These specify which GPIO port an external interrupt line should be"]
#[doc = " connected to."]
pub type exti_cfg = u32;
#[doc = "< Trigger on the rising edge"]
pub const exti_trigger_mode_EXTI_RISING: exti_trigger_mode = 0;
#[doc = "< Trigger on the falling edge"]
pub const exti_trigger_mode_EXTI_FALLING: exti_trigger_mode = 1;
#[doc = "< Trigger on both the rising and falling edges"]
pub const exti_trigger_mode_EXTI_RISING_FALLING: exti_trigger_mode = 2;
#[doc = " External interrupt trigger mode"]
pub type exti_trigger_mode = u32;
extern "C" {
    pub fn exti_attach_interrupt(
        num: exti_num,
        port: exti_cfg,
        handler: voidFuncPtr,
        mode: exti_trigger_mode,
    );
}
extern "C" {
    pub fn exti_attach_callback(
        num: exti_num,
        port: exti_cfg,
        handler: voidArgumentFuncPtr,
        arg: *mut super::c_void,
        mode: exti_trigger_mode,
    );
}
extern "C" {
    pub fn exti_detach_interrupt(num: exti_num);
}
extern "C" {
    #[doc = " @brief Set the GPIO port for an EXTI line."]
    #[doc = ""]
    #[doc = " This is a low-level routine that most users will not"]
    #[doc = " need. exti_attach_interrupt() handles calling this function"]
    #[doc = " appropriately."]
    #[doc = ""]
    #[doc = " @param num EXTI line"]
    #[doc = " @param port EXTI configuration for GPIO port to connect to num."]
    #[doc = " @see exti_num"]
    #[doc = " @see exti_cfg"]
    pub fn exti_select(num: exti_num, port: exti_cfg);
}
#[doc = " GPIO register map type"]
#[repr(C)]
pub struct gpio_reg_map {
    #[doc = "< Port configuration register low"]
    pub CRL: uint32,
    #[doc = "< Port configuration register high"]
    pub CRH: uint32,
    #[doc = "< Port input data register"]
    pub IDR: uint32,
    #[doc = "< Port output data register"]
    pub ODR: uint32,
    #[doc = "< Port bit set/reset register"]
    pub BSRR: uint32,
    #[doc = "< Port bit reset register"]
    pub BRR: uint32,
    #[doc = "< Port configuration lock register"]
    pub LCKR: uint32,
}
#[test]
fn bindgen_test_layout_gpio_reg_map() {
    assert_eq!(
        ::core::mem::size_of::<gpio_reg_map>(),
        28usize,
        concat!("Size of: ", stringify!(gpio_reg_map))
    );
    assert_eq!(
        ::core::mem::align_of::<gpio_reg_map>(),
        4usize,
        concat!("Alignment of ", stringify!(gpio_reg_map))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<gpio_reg_map>())).CRL as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(gpio_reg_map),
            "::",
            stringify!(CRL)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<gpio_reg_map>())).CRH as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(gpio_reg_map),
            "::",
            stringify!(CRH)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<gpio_reg_map>())).IDR as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(gpio_reg_map),
            "::",
            stringify!(IDR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<gpio_reg_map>())).ODR as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(gpio_reg_map),
            "::",
            stringify!(ODR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<gpio_reg_map>())).BSRR as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(gpio_reg_map),
            "::",
            stringify!(BSRR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<gpio_reg_map>())).BRR as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(gpio_reg_map),
            "::",
            stringify!(BRR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<gpio_reg_map>())).LCKR as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(gpio_reg_map),
            "::",
            stringify!(LCKR)
        )
    );
}
#[doc = " GPIO device type"]
#[repr(C)]
pub struct gpio_dev {
    #[doc = "< Register map"]
    pub regs: *mut gpio_reg_map,
    #[doc = "< RCC clock information"]
    pub clk_id: rcc_clk_id,
    #[doc = " @brief (Deprecated) External interrupt port."]
    #[doc = " Instead of dev->exti_port, use gpio_exti_port(dev)."]
    pub exti_port: exti_cfg,
}
#[test]
fn bindgen_test_layout_gpio_dev() {
    assert_eq!(
        ::core::mem::size_of::<gpio_dev>(),
        12usize,
        concat!("Size of: ", stringify!(gpio_dev))
    );
    assert_eq!(
        ::core::mem::align_of::<gpio_dev>(),
        4usize,
        concat!("Alignment of ", stringify!(gpio_dev))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<gpio_dev>())).regs as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(gpio_dev),
            "::",
            stringify!(regs)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<gpio_dev>())).clk_id as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(gpio_dev),
            "::",
            stringify!(clk_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<gpio_dev>())).exti_port as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(gpio_dev),
            "::",
            stringify!(exti_port)
        )
    );
}
extern "C" {
    pub static mut gpioa: gpio_dev;
}
extern "C" {
    pub static GPIOA: *mut gpio_dev;
}
extern "C" {
    pub static mut gpiob: gpio_dev;
}
extern "C" {
    pub static GPIOB: *mut gpio_dev;
}
extern "C" {
    pub static mut gpioc: gpio_dev;
}
extern "C" {
    pub static GPIOC: *mut gpio_dev;
}
extern "C" {
    pub static mut gpiod: gpio_dev;
}
extern "C" {
    pub static GPIOD: *mut gpio_dev;
}
#[doc = " Output push-pull."]
pub const gpio_pin_mode_GPIO_OUTPUT_PP: gpio_pin_mode = 3;
#[doc = " Output open-drain."]
pub const gpio_pin_mode_GPIO_OUTPUT_OD: gpio_pin_mode = 7;
#[doc = " Alternate function output push-pull."]
pub const gpio_pin_mode_GPIO_AF_OUTPUT_PP: gpio_pin_mode = 11;
#[doc = " Alternate function output open drain."]
pub const gpio_pin_mode_GPIO_AF_OUTPUT_OD: gpio_pin_mode = 15;
#[doc = " Analog input."]
pub const gpio_pin_mode_GPIO_INPUT_ANALOG: gpio_pin_mode = 0;
#[doc = " Input floating."]
pub const gpio_pin_mode_GPIO_INPUT_FLOATING: gpio_pin_mode = 4;
#[doc = " Input pull-down."]
pub const gpio_pin_mode_GPIO_INPUT_PD: gpio_pin_mode = 8;
#[doc = " Input pull-up."]
pub const gpio_pin_mode_GPIO_INPUT_PU: gpio_pin_mode = 9;
#[doc = " @brief GPIO pin modes."]
#[doc = ""]
#[doc = " These only allow for 50MHZ max output speeds; if you want slower,"]
#[doc = " use direct register access."]
pub type gpio_pin_mode = u32;
#[doc = " AFIO register map"]
#[repr(C)]
pub struct afio_reg_map {
    #[doc = "< Event control register."]
    pub EVCR: uint32,
    #[doc = "< AF remap and debug I/O configuration register."]
    pub MAPR: uint32,
    #[doc = "< External interrupt configuration register 1."]
    pub EXTICR1: uint32,
    #[doc = "< External interrupt configuration register 2."]
    pub EXTICR2: uint32,
    #[doc = "< External interrupt configuration register 3."]
    pub EXTICR3: uint32,
    #[doc = "< External interrupt configuration register 4."]
    pub EXTICR4: uint32,
    #[doc = "<"]
    #[doc = " AF remap and debug I/O configuration register 2."]
    pub MAPR2: uint32,
}
#[test]
fn bindgen_test_layout_afio_reg_map() {
    assert_eq!(
        ::core::mem::size_of::<afio_reg_map>(),
        28usize,
        concat!("Size of: ", stringify!(afio_reg_map))
    );
    assert_eq!(
        ::core::mem::align_of::<afio_reg_map>(),
        4usize,
        concat!("Alignment of ", stringify!(afio_reg_map))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<afio_reg_map>())).EVCR as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(afio_reg_map),
            "::",
            stringify!(EVCR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<afio_reg_map>())).MAPR as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(afio_reg_map),
            "::",
            stringify!(MAPR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<afio_reg_map>())).EXTICR1 as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(afio_reg_map),
            "::",
            stringify!(EXTICR1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<afio_reg_map>())).EXTICR2 as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(afio_reg_map),
            "::",
            stringify!(EXTICR2)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<afio_reg_map>())).EXTICR3 as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(afio_reg_map),
            "::",
            stringify!(EXTICR3)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<afio_reg_map>())).EXTICR4 as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(afio_reg_map),
            "::",
            stringify!(EXTICR4)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<afio_reg_map>())).MAPR2 as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(afio_reg_map),
            "::",
            stringify!(MAPR2)
        )
    );
}
extern "C" {
    pub fn afio_init();
}
#[doc = " ADC 2 external trigger regular conversion remapping"]
pub const afio_remap_peripheral_AFIO_REMAP_ADC2_ETRGREG: afio_remap_peripheral = 1048576;
#[doc = " ADC 2 external trigger injected conversion remapping"]
pub const afio_remap_peripheral_AFIO_REMAP_ADC2_ETRGINJ: afio_remap_peripheral = 524288;
#[doc = " ADC 1 external trigger regular conversion remapping"]
pub const afio_remap_peripheral_AFIO_REMAP_ADC1_ETRGREG: afio_remap_peripheral = 262144;
#[doc = " ADC 1 external trigger injected conversion remapping"]
pub const afio_remap_peripheral_AFIO_REMAP_ADC1_ETRGINJ: afio_remap_peripheral = 131072;
#[doc = " Timer 5 channel 4 internal remapping"]
pub const afio_remap_peripheral_AFIO_REMAP_TIM5CH4_I: afio_remap_peripheral = 65536;
#[doc = " Port D0/Port D1 mapping on OSC_IN/OSC_OUT"]
pub const afio_remap_peripheral_AFIO_REMAP_PD01: afio_remap_peripheral = 32768;
#[doc = " CAN alternate function remapping 1 (RX on PB8, TX on PB9)"]
pub const afio_remap_peripheral_AFIO_REMAP_CAN_1: afio_remap_peripheral = 16384;
#[doc = " CAN alternate function remapping 2 (RX on PD0, TX on PD1)"]
pub const afio_remap_peripheral_AFIO_REMAP_CAN_2: afio_remap_peripheral = 24576;
#[doc = " Timer 4 remapping"]
pub const afio_remap_peripheral_AFIO_REMAP_TIM4: afio_remap_peripheral = 4096;
#[doc = " Timer 3 partial remapping"]
pub const afio_remap_peripheral_AFIO_REMAP_TIM3_PARTIAL: afio_remap_peripheral = 2048;
#[doc = " Timer 3 full remapping"]
pub const afio_remap_peripheral_AFIO_REMAP_TIM3_FULL: afio_remap_peripheral = 3072;
#[doc = " Timer 2 partial remapping 1 (CH1 and ETR on PA15, CH2 on PB3,"]
#[doc = " CH3 on                                      PA2, CH4 on PA3)"]
pub const afio_remap_peripheral_AFIO_REMAP_TIM2_PARTIAL_1: afio_remap_peripheral = 256;
#[doc = " Timer 2 partial remapping 2 (CH1 and ETR on PA0, CH2 on PA1,"]
#[doc = " CH3 on                                      PB10, CH4 on PB11)"]
pub const afio_remap_peripheral_AFIO_REMAP_TIM2_PARTIAL_2: afio_remap_peripheral = 512;
#[doc = " Timer 2 full remapping"]
pub const afio_remap_peripheral_AFIO_REMAP_TIM2_FULL: afio_remap_peripheral = 768;
#[doc = " USART 3 part remapping"]
pub const afio_remap_peripheral_AFIO_REMAP_USART3_PARTIAL: afio_remap_peripheral = 16;
#[doc = " USART 2 remapping"]
pub const afio_remap_peripheral_AFIO_REMAP_USART2: afio_remap_peripheral = 8;
#[doc = " USART 1 remapping"]
pub const afio_remap_peripheral_AFIO_REMAP_USART1: afio_remap_peripheral = 4;
#[doc = " I2C 1 remapping"]
pub const afio_remap_peripheral_AFIO_REMAP_I2C1: afio_remap_peripheral = 2;
#[doc = " SPI 1 remapping"]
pub const afio_remap_peripheral_AFIO_REMAP_SPI1: afio_remap_peripheral = 1;
#[doc = " NADV signal not connected"]
pub const afio_remap_peripheral_AFIO_REMAP_FSMC_NADV: afio_remap_peripheral = 2147484672;
#[doc = " Timer 14 remapping"]
pub const afio_remap_peripheral_AFIO_REMAP_TIM14: afio_remap_peripheral = 2147484160;
#[doc = " Timer 13 remapping"]
pub const afio_remap_peripheral_AFIO_REMAP_TIM13: afio_remap_peripheral = 2147483904;
#[doc = " Timer 11 remapping"]
pub const afio_remap_peripheral_AFIO_REMAP_TIM11: afio_remap_peripheral = 2147483776;
#[doc = " Timer 10 remapping"]
pub const afio_remap_peripheral_AFIO_REMAP_TIM10: afio_remap_peripheral = 2147483712;
#[doc = " Timer 9 remapping"]
pub const afio_remap_peripheral_AFIO_REMAP_TIM9: afio_remap_peripheral = 2147483680;
#[doc = " @brief Available peripheral remaps."]
#[doc = " @see afio_remap()"]
pub type afio_remap_peripheral = u32;
extern "C" {
    pub fn afio_remap(p: afio_remap_peripheral);
}
#[doc = " Full Serial Wire and JTAG debug"]
pub const afio_debug_cfg_AFIO_DEBUG_FULL_SWJ: afio_debug_cfg = 0;
#[doc = " Full Serial Wire and JTAG, but no NJTRST."]
pub const afio_debug_cfg_AFIO_DEBUG_FULL_SWJ_NO_NJRST: afio_debug_cfg = 16777216;
#[doc = " Serial Wire debug only (JTAG-DP disabled, SW-DP enabled)"]
pub const afio_debug_cfg_AFIO_DEBUG_SW_ONLY: afio_debug_cfg = 33554432;
#[doc = " No debug; all JTAG and SW pins are free for use as GPIOs."]
pub const afio_debug_cfg_AFIO_DEBUG_NONE: afio_debug_cfg = 67108864;
#[doc = " @brief Debug port configuration"]
#[doc = ""]
#[doc = " Used to configure the behavior of JTAG and Serial Wire (SW) debug"]
#[doc = " ports and their associated GPIO pins."]
#[doc = ""]
#[doc = " @see afio_cfg_debug_ports()"]
pub type afio_debug_cfg = u32;
#[doc = " @brief Deprecated. Use exti_cfg instead."]
#[doc = ""]
#[doc = " In previous versions of libmaple, exti_attach_interrupt() took an"]
#[doc = " afio_exti_port argument; afio_exti_port was also a member of struct"]
#[doc = " gpio_dev. This isn't portable, so we now use exti_cfg"]
#[doc = " instead. This typedef (and the macros AFIO_EXTI_PA, ...,"]
#[doc = " AFIO_EXTI_PG) exist to preserve backwards compatibility."]
pub use self::exti_cfg as afio_exti_port;
#[doc = " @brief Deprecated. Use exti_num instead."]
#[doc = ""]
#[doc = " In previous versions of libmaple, exti_attach_interrupt() took an"]
#[doc = " afio_exti_num argument. This isn't portable, so we use exti_num"]
#[doc = " instead. This typedef (and the macros AFIO_EXTI_0, ...,"]
#[doc = " AFIO_EXTI_15) exist to preserve backwards compatibility."]
pub use self::exti_num as afio_exti_num;
pub const rcc_sysclk_src_RCC_CLKSRC_HSI: rcc_sysclk_src = 0;
pub const rcc_sysclk_src_RCC_CLKSRC_HSE: rcc_sysclk_src = 1;
pub const rcc_sysclk_src_RCC_CLKSRC_PLL: rcc_sysclk_src = 2;
#[doc = " @brief SYSCLK sources"]
#[doc = " @see rcc_switch_sysclk()"]
pub type rcc_sysclk_src = u32;
#[doc = " STM32F1 RCC register map type"]
#[repr(C)]
pub struct rcc_reg_map {
    #[doc = "< Clock control register"]
    pub CR: uint32,
    #[doc = "< Clock configuration register"]
    pub CFGR: uint32,
    #[doc = "< Clock interrupt register"]
    pub CIR: uint32,
    #[doc = "< APB2 peripheral reset register"]
    pub APB2RSTR: uint32,
    #[doc = "< APB1 peripheral reset register"]
    pub APB1RSTR: uint32,
    #[doc = "< AHB peripheral clock enable register"]
    pub AHBENR: uint32,
    #[doc = "< APB2 peripheral clock enable register"]
    pub APB2ENR: uint32,
    #[doc = "< APB1 peripheral clock enable register"]
    pub APB1ENR: uint32,
    #[doc = "< Backup domain control register"]
    pub BDCR: uint32,
    #[doc = "< Control/status register"]
    pub CSR: uint32,
}
#[test]
fn bindgen_test_layout_rcc_reg_map() {
    assert_eq!(
        ::core::mem::size_of::<rcc_reg_map>(),
        40usize,
        concat!("Size of: ", stringify!(rcc_reg_map))
    );
    assert_eq!(
        ::core::mem::align_of::<rcc_reg_map>(),
        4usize,
        concat!("Alignment of ", stringify!(rcc_reg_map))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rcc_reg_map>())).CR as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rcc_reg_map),
            "::",
            stringify!(CR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rcc_reg_map>())).CFGR as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rcc_reg_map),
            "::",
            stringify!(CFGR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rcc_reg_map>())).CIR as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rcc_reg_map),
            "::",
            stringify!(CIR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rcc_reg_map>())).APB2RSTR as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(rcc_reg_map),
            "::",
            stringify!(APB2RSTR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rcc_reg_map>())).APB1RSTR as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rcc_reg_map),
            "::",
            stringify!(APB1RSTR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rcc_reg_map>())).AHBENR as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(rcc_reg_map),
            "::",
            stringify!(AHBENR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rcc_reg_map>())).APB2ENR as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rcc_reg_map),
            "::",
            stringify!(APB2ENR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rcc_reg_map>())).APB1ENR as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(rcc_reg_map),
            "::",
            stringify!(APB1ENR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rcc_reg_map>())).BDCR as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rcc_reg_map),
            "::",
            stringify!(BDCR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rcc_reg_map>())).CSR as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(rcc_reg_map),
            "::",
            stringify!(CSR)
        )
    );
}
pub const rcc_clk_id_RCC_ADC1: rcc_clk_id = 0;
pub const rcc_clk_id_RCC_ADC2: rcc_clk_id = 1;
pub const rcc_clk_id_RCC_ADC3: rcc_clk_id = 2;
pub const rcc_clk_id_RCC_AFIO: rcc_clk_id = 3;
pub const rcc_clk_id_RCC_BKP: rcc_clk_id = 4;
pub const rcc_clk_id_RCC_CRC: rcc_clk_id = 5;
pub const rcc_clk_id_RCC_DAC: rcc_clk_id = 6;
pub const rcc_clk_id_RCC_DMA1: rcc_clk_id = 7;
pub const rcc_clk_id_RCC_DMA2: rcc_clk_id = 8;
pub const rcc_clk_id_RCC_FLITF: rcc_clk_id = 9;
pub const rcc_clk_id_RCC_FSMC: rcc_clk_id = 10;
pub const rcc_clk_id_RCC_GPIOA: rcc_clk_id = 11;
pub const rcc_clk_id_RCC_GPIOB: rcc_clk_id = 12;
pub const rcc_clk_id_RCC_GPIOC: rcc_clk_id = 13;
pub const rcc_clk_id_RCC_GPIOD: rcc_clk_id = 14;
pub const rcc_clk_id_RCC_GPIOE: rcc_clk_id = 15;
pub const rcc_clk_id_RCC_GPIOF: rcc_clk_id = 16;
pub const rcc_clk_id_RCC_GPIOG: rcc_clk_id = 17;
pub const rcc_clk_id_RCC_I2C1: rcc_clk_id = 18;
pub const rcc_clk_id_RCC_I2C2: rcc_clk_id = 19;
pub const rcc_clk_id_RCC_PWR: rcc_clk_id = 20;
pub const rcc_clk_id_RCC_SDIO: rcc_clk_id = 21;
pub const rcc_clk_id_RCC_SPI1: rcc_clk_id = 22;
pub const rcc_clk_id_RCC_SPI2: rcc_clk_id = 23;
pub const rcc_clk_id_RCC_SPI3: rcc_clk_id = 24;
pub const rcc_clk_id_RCC_SRAM: rcc_clk_id = 25;
pub const rcc_clk_id_RCC_TIMER1: rcc_clk_id = 26;
pub const rcc_clk_id_RCC_TIMER2: rcc_clk_id = 27;
pub const rcc_clk_id_RCC_TIMER3: rcc_clk_id = 28;
pub const rcc_clk_id_RCC_TIMER4: rcc_clk_id = 29;
pub const rcc_clk_id_RCC_TIMER5: rcc_clk_id = 30;
pub const rcc_clk_id_RCC_TIMER6: rcc_clk_id = 31;
pub const rcc_clk_id_RCC_TIMER7: rcc_clk_id = 32;
pub const rcc_clk_id_RCC_TIMER8: rcc_clk_id = 33;
pub const rcc_clk_id_RCC_TIMER9: rcc_clk_id = 34;
pub const rcc_clk_id_RCC_TIMER10: rcc_clk_id = 35;
pub const rcc_clk_id_RCC_TIMER11: rcc_clk_id = 36;
pub const rcc_clk_id_RCC_TIMER12: rcc_clk_id = 37;
pub const rcc_clk_id_RCC_TIMER13: rcc_clk_id = 38;
pub const rcc_clk_id_RCC_TIMER14: rcc_clk_id = 39;
pub const rcc_clk_id_RCC_USART1: rcc_clk_id = 40;
pub const rcc_clk_id_RCC_USART2: rcc_clk_id = 41;
pub const rcc_clk_id_RCC_USART3: rcc_clk_id = 42;
pub const rcc_clk_id_RCC_UART4: rcc_clk_id = 43;
pub const rcc_clk_id_RCC_UART5: rcc_clk_id = 44;
pub const rcc_clk_id_RCC_USB: rcc_clk_id = 45;
#[doc = " @brief STM32F1 rcc_clk_id."]
pub type rcc_clk_id = u32;
pub const rcc_pllsrc_RCC_PLLSRC_HSE: rcc_pllsrc = 65536;
pub const rcc_pllsrc_RCC_PLLSRC_HSI_DIV_2: rcc_pllsrc = 0;
#[doc = " @brief STM32F1 PLL clock sources."]
#[doc = " @see rcc_configure_pll()"]
pub type rcc_pllsrc = u32;
pub const rcc_clk_domain_RCC_APB1: rcc_clk_domain = 0;
pub const rcc_clk_domain_RCC_APB2: rcc_clk_domain = 1;
pub const rcc_clk_domain_RCC_AHB: rcc_clk_domain = 2;
#[doc = " @brief STM32F1 clock domains."]
#[doc = " @see rcc_dev_clk()"]
pub type rcc_clk_domain = u32;
pub const rcc_prescaler_RCC_PRESCALER_AHB: rcc_prescaler = 0;
pub const rcc_prescaler_RCC_PRESCALER_APB1: rcc_prescaler = 1;
pub const rcc_prescaler_RCC_PRESCALER_APB2: rcc_prescaler = 2;
pub const rcc_prescaler_RCC_PRESCALER_USB: rcc_prescaler = 3;
pub const rcc_prescaler_RCC_PRESCALER_ADC: rcc_prescaler = 4;
#[doc = " @brief STM32F1 Prescaler identifiers"]
#[doc = " @see rcc_set_prescaler()"]
pub type rcc_prescaler = u32;
pub const rcc_adc_divider_RCC_ADCPRE_PCLK_DIV_2: rcc_adc_divider = 0;
pub const rcc_adc_divider_RCC_ADCPRE_PCLK_DIV_4: rcc_adc_divider = 16384;
pub const rcc_adc_divider_RCC_ADCPRE_PCLK_DIV_6: rcc_adc_divider = 32768;
pub const rcc_adc_divider_RCC_ADCPRE_PCLK_DIV_8: rcc_adc_divider = 49152;
#[doc = " @brief STM32F1 ADC prescaler dividers"]
#[doc = " @see rcc_set_prescaler()"]
pub type rcc_adc_divider = u32;
pub const rcc_apb1_divider_RCC_APB1_HCLK_DIV_1: rcc_apb1_divider = 0;
pub const rcc_apb1_divider_RCC_APB1_HCLK_DIV_2: rcc_apb1_divider = 1024;
pub const rcc_apb1_divider_RCC_APB1_HCLK_DIV_4: rcc_apb1_divider = 1280;
pub const rcc_apb1_divider_RCC_APB1_HCLK_DIV_8: rcc_apb1_divider = 1536;
pub const rcc_apb1_divider_RCC_APB1_HCLK_DIV_16: rcc_apb1_divider = 1792;
#[doc = " @brief STM32F1 APB1 prescaler dividers"]
#[doc = " @see rcc_set_prescaler()"]
pub type rcc_apb1_divider = u32;
pub const rcc_apb2_divider_RCC_APB2_HCLK_DIV_1: rcc_apb2_divider = 0;
pub const rcc_apb2_divider_RCC_APB2_HCLK_DIV_2: rcc_apb2_divider = 8192;
pub const rcc_apb2_divider_RCC_APB2_HCLK_DIV_4: rcc_apb2_divider = 10240;
pub const rcc_apb2_divider_RCC_APB2_HCLK_DIV_8: rcc_apb2_divider = 12288;
pub const rcc_apb2_divider_RCC_APB2_HCLK_DIV_16: rcc_apb2_divider = 14336;
#[doc = " @brief STM32F1 APB2 prescaler dividers"]
#[doc = " @see rcc_set_prescaler()"]
pub type rcc_apb2_divider = u32;
pub const rcc_ahb_divider_RCC_AHB_SYSCLK_DIV_1: rcc_ahb_divider = 0;
pub const rcc_ahb_divider_RCC_AHB_SYSCLK_DIV_2: rcc_ahb_divider = 128;
pub const rcc_ahb_divider_RCC_AHB_SYSCLK_DIV_4: rcc_ahb_divider = 144;
pub const rcc_ahb_divider_RCC_AHB_SYSCLK_DIV_8: rcc_ahb_divider = 160;
pub const rcc_ahb_divider_RCC_AHB_SYSCLK_DIV_16: rcc_ahb_divider = 176;
pub const rcc_ahb_divider_RCC_AHB_SYSCLK_DIV_32: rcc_ahb_divider = 192;
pub const rcc_ahb_divider_RCC_AHB_SYSCLK_DIV_64: rcc_ahb_divider = 208;
pub const rcc_ahb_divider_RCC_AHB_SYSCLK_DIV_128: rcc_ahb_divider = 208;
pub const rcc_ahb_divider_RCC_AHB_SYSCLK_DIV_256: rcc_ahb_divider = 224;
pub const rcc_ahb_divider_RCC_AHB_SYSCLK_DIV_512: rcc_ahb_divider = 240;
#[doc = " @brief STM32F1 AHB prescaler dividers"]
#[doc = " @see rcc_set_prescaler()"]
pub type rcc_ahb_divider = u32;
pub const rcc_usb_divider_RCC_USB_SYSCLK_DIV_1: rcc_usb_divider = 4194304;
pub const rcc_usb_divider_RCC_USB_SYSCLK_DIV_1_5: rcc_usb_divider = 0;
pub const rcc_usb_divider_RCC_USB_SYSCLK_DIV_2: rcc_usb_divider = 12582912;
pub const rcc_usb_divider_RCC_USB_SYSCLK_DIV_2_5: rcc_usb_divider = 8388608;
#[doc = " @brief STM32F1 USB prescaler dividers"]
#[doc = " @see rcc_set_prescaler()"]
pub type rcc_usb_divider = u32;
pub const rcc_clk_RCC_CLK_PLL: rcc_clk = 24;
pub const rcc_clk_RCC_CLK_HSE: rcc_clk = 16;
pub const rcc_clk_RCC_CLK_HSI: rcc_clk = 0;
pub const rcc_clk_RCC_CLK_LSE: rcc_clk = 8192;
pub const rcc_clk_RCC_CLK_LSI: rcc_clk = 9216;
#[doc = " @brief STM32F1 clock sources."]
pub type rcc_clk = u32;
pub const rcc_pll_multiplier_RCC_PLLMUL_2: rcc_pll_multiplier = 0;
pub const rcc_pll_multiplier_RCC_PLLMUL_3: rcc_pll_multiplier = 262144;
pub const rcc_pll_multiplier_RCC_PLLMUL_4: rcc_pll_multiplier = 524288;
pub const rcc_pll_multiplier_RCC_PLLMUL_5: rcc_pll_multiplier = 786432;
pub const rcc_pll_multiplier_RCC_PLLMUL_6: rcc_pll_multiplier = 1048576;
pub const rcc_pll_multiplier_RCC_PLLMUL_7: rcc_pll_multiplier = 1310720;
pub const rcc_pll_multiplier_RCC_PLLMUL_8: rcc_pll_multiplier = 1572864;
pub const rcc_pll_multiplier_RCC_PLLMUL_9: rcc_pll_multiplier = 1835008;
pub const rcc_pll_multiplier_RCC_PLLMUL_10: rcc_pll_multiplier = 2097152;
pub const rcc_pll_multiplier_RCC_PLLMUL_11: rcc_pll_multiplier = 2359296;
pub const rcc_pll_multiplier_RCC_PLLMUL_12: rcc_pll_multiplier = 2621440;
pub const rcc_pll_multiplier_RCC_PLLMUL_13: rcc_pll_multiplier = 2883584;
pub const rcc_pll_multiplier_RCC_PLLMUL_14: rcc_pll_multiplier = 3145728;
pub const rcc_pll_multiplier_RCC_PLLMUL_15: rcc_pll_multiplier = 3407872;
pub const rcc_pll_multiplier_RCC_PLLMUL_16: rcc_pll_multiplier = 3670016;
#[doc = " @brief STM32F1 PLL multipliers."]
pub type rcc_pll_multiplier = u32;
#[doc = " @brief STM32F1 PLL configuration values."]
#[doc = " Point to one of these with the \"data\" field in a struct rcc_pll_cfg."]
#[doc = " @see struct rcc_pll_cfg."]
#[repr(C)]
pub struct stm32f1_rcc_pll_data {
    #[doc = "< PLL multiplication factor."]
    pub pll_mul: rcc_pll_multiplier,
}
#[test]
fn bindgen_test_layout_stm32f1_rcc_pll_data() {
    assert_eq!(
        ::core::mem::size_of::<stm32f1_rcc_pll_data>(),
        4usize,
        concat!("Size of: ", stringify!(stm32f1_rcc_pll_data))
    );
    assert_eq!(
        ::core::mem::align_of::<stm32f1_rcc_pll_data>(),
        4usize,
        concat!("Alignment of ", stringify!(stm32f1_rcc_pll_data))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<stm32f1_rcc_pll_data>())).pll_mul as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(stm32f1_rcc_pll_data),
            "::",
            stringify!(pll_mul)
        )
    );
}
extern "C" {
    #[doc = " @brief Deprecated; STM32F1 only."]
    #[doc = ""]
    #[doc = " Initialize the clock control system. Initializes the system"]
    #[doc = " clock source to use the PLL driven by an external oscillator."]
    #[doc = ""]
    #[doc = " @param sysclk_src system clock source, must be PLL"]
    #[doc = " @param pll_src pll clock source, must be HSE"]
    #[doc = " @param pll_mul pll multiplier"]
    pub fn rcc_clk_init(
        sysclk_src: rcc_sysclk_src,
        pll_src: rcc_pllsrc,
        pll_mul: rcc_pll_multiplier,
    );
}
extern "C" {
    #[doc = " @brief Set the divider on a peripheral prescaler"]
    #[doc = " @param prescaler prescaler to set"]
    #[doc = " @param divider prescaler divider"]
    pub fn rcc_set_prescaler(prescaler: rcc_prescaler, divider: uint32);
}
extern "C" {
    pub fn rcc_switch_sysclk(sysclk_src: rcc_sysclk_src);
}
#[doc = " @brief Specifies a configuration for the main PLL."]
#[repr(C)]
pub struct rcc_pll_cfg {
    #[doc = "< PLL source"]
    pub pllsrc: rcc_pllsrc,
    #[doc = " Series-specific configuration data."]
    pub data: *mut super::c_void,
}
#[test]
fn bindgen_test_layout_rcc_pll_cfg() {
    assert_eq!(
        ::core::mem::size_of::<rcc_pll_cfg>(),
        8usize,
        concat!("Size of: ", stringify!(rcc_pll_cfg))
    );
    assert_eq!(
        ::core::mem::align_of::<rcc_pll_cfg>(),
        4usize,
        concat!("Alignment of ", stringify!(rcc_pll_cfg))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rcc_pll_cfg>())).pllsrc as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rcc_pll_cfg),
            "::",
            stringify!(pllsrc)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rcc_pll_cfg>())).data as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rcc_pll_cfg),
            "::",
            stringify!(data)
        )
    );
}
extern "C" {
    #[doc = " @brief Configure the main PLL."]
    #[doc = ""]
    #[doc = " You may only call this function while the PLL is disabled."]
    #[doc = ""]
    #[doc = " @param pll_cfg Desired PLL configuration. The contents of this"]
    #[doc = "                struct depend entirely on the target."]
    pub fn rcc_configure_pll(pll_cfg: *mut rcc_pll_cfg);
}
extern "C" {
    pub fn rcc_turn_on_clk(clock: rcc_clk);
}
extern "C" {
    pub fn rcc_turn_off_clk(clock: rcc_clk);
}
extern "C" {
    pub fn rcc_is_clk_on(clock: rcc_clk) -> super::c_int;
}
extern "C" {
    pub fn rcc_is_clk_ready(clock: rcc_clk) -> super::c_int;
}
extern "C" {
    #[doc = " @brief Turn on the clock line on a peripheral"]
    #[doc = " @param id Clock ID of the peripheral to turn on."]
    pub fn rcc_clk_enable(id: rcc_clk_id);
}
extern "C" {
    #[doc = " @brief Reset a peripheral."]
    #[doc = ""]
    #[doc = " Caution: not all rcc_clk_id values refer to a peripheral which can"]
    #[doc = " be reset. (Only rcc_clk_ids for peripherals with bits in an RCC"]
    #[doc = " reset register can be used here.)"]
    #[doc = ""]
    #[doc = " @param id Clock ID of the peripheral to reset."]
    pub fn rcc_reset_dev(id: rcc_clk_id);
}
extern "C" {
    pub fn rcc_dev_clk(id: rcc_clk_id) -> rcc_clk_domain;
}
extern "C" {
    #[doc = " @brief Turn off the clock line on a peripheral"]
    #[doc = " @param id Clock ID of the peripheral to turn on."]
    pub fn rcc_clk_disable(id: rcc_clk_id);
}
extern "C" {
    pub fn gpio_init(dev: *mut gpio_dev);
}
extern "C" {
    pub fn gpio_init_all();
}
extern "C" {
    pub fn gpio_set_mode(dev: *mut gpio_dev, pin: uint8, mode: gpio_pin_mode);
}
extern "C" {
    pub fn gpio_get_mode(dev: *mut gpio_dev, pin: uint8) -> gpio_pin_mode;
}
#[doc = " STM32F1 general purpose timer register map type"]
#[repr(C)]
pub struct timer_gen_reg_map {
    #[doc = "< Control register 1"]
    pub CR1: uint32,
    #[doc = "< Control register 2"]
    pub CR2: uint32,
    #[doc = "< Slave mode control register"]
    pub SMCR: uint32,
    #[doc = "< DMA/Interrupt enable register"]
    pub DIER: uint32,
    #[doc = "< Status register"]
    pub SR: uint32,
    #[doc = "< Event generation register"]
    pub EGR: uint32,
    #[doc = "< Capture/compare mode register 1"]
    pub CCMR1: uint32,
    #[doc = "< Capture/compare mode register 2"]
    pub CCMR2: uint32,
    #[doc = "< Capture/compare enable register"]
    pub CCER: uint32,
    #[doc = "< Counter"]
    pub CNT: uint32,
    #[doc = "< Prescaler"]
    pub PSC: uint32,
    #[doc = "< Auto-reload register"]
    pub ARR: uint32,
    #[doc = "< Reserved"]
    pub RESERVED1: uint32,
    #[doc = "< Capture/compare register 1"]
    pub CCR1: uint32,
    #[doc = "< Capture/compare register 2"]
    pub CCR2: uint32,
    #[doc = "< Capture/compare register 3"]
    pub CCR3: uint32,
    #[doc = "< Capture/compare register 4"]
    pub CCR4: uint32,
    #[doc = "< Reserved"]
    pub RESERVED2: uint32,
    #[doc = "< DMA control register"]
    pub DCR: uint32,
    #[doc = "< DMA address for full transfer"]
    pub DMAR: uint32,
}
#[test]
fn bindgen_test_layout_timer_gen_reg_map() {
    assert_eq!(
        ::core::mem::size_of::<timer_gen_reg_map>(),
        80usize,
        concat!("Size of: ", stringify!(timer_gen_reg_map))
    );
    assert_eq!(
        ::core::mem::align_of::<timer_gen_reg_map>(),
        4usize,
        concat!("Alignment of ", stringify!(timer_gen_reg_map))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<timer_gen_reg_map>())).CR1 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timer_gen_reg_map),
            "::",
            stringify!(CR1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<timer_gen_reg_map>())).CR2 as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(timer_gen_reg_map),
            "::",
            stringify!(CR2)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<timer_gen_reg_map>())).SMCR as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timer_gen_reg_map),
            "::",
            stringify!(SMCR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<timer_gen_reg_map>())).DIER as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(timer_gen_reg_map),
            "::",
            stringify!(DIER)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<timer_gen_reg_map>())).SR as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(timer_gen_reg_map),
            "::",
            stringify!(SR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<timer_gen_reg_map>())).EGR as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(timer_gen_reg_map),
            "::",
            stringify!(EGR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<timer_gen_reg_map>())).CCMR1 as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(timer_gen_reg_map),
            "::",
            stringify!(CCMR1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<timer_gen_reg_map>())).CCMR2 as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(timer_gen_reg_map),
            "::",
            stringify!(CCMR2)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<timer_gen_reg_map>())).CCER as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(timer_gen_reg_map),
            "::",
            stringify!(CCER)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<timer_gen_reg_map>())).CNT as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(timer_gen_reg_map),
            "::",
            stringify!(CNT)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<timer_gen_reg_map>())).PSC as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(timer_gen_reg_map),
            "::",
            stringify!(PSC)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<timer_gen_reg_map>())).ARR as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(timer_gen_reg_map),
            "::",
            stringify!(ARR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<timer_gen_reg_map>())).RESERVED1 as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(timer_gen_reg_map),
            "::",
            stringify!(RESERVED1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<timer_gen_reg_map>())).CCR1 as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(timer_gen_reg_map),
            "::",
            stringify!(CCR1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<timer_gen_reg_map>())).CCR2 as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(timer_gen_reg_map),
            "::",
            stringify!(CCR2)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<timer_gen_reg_map>())).CCR3 as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(timer_gen_reg_map),
            "::",
            stringify!(CCR3)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<timer_gen_reg_map>())).CCR4 as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(timer_gen_reg_map),
            "::",
            stringify!(CCR4)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<timer_gen_reg_map>())).RESERVED2 as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(timer_gen_reg_map),
            "::",
            stringify!(RESERVED2)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<timer_gen_reg_map>())).DCR as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(timer_gen_reg_map),
            "::",
            stringify!(DCR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<timer_gen_reg_map>())).DMAR as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(timer_gen_reg_map),
            "::",
            stringify!(DMAR)
        )
    );
}
extern "C" {
    pub static TIMER1: *mut timer_dev;
}
extern "C" {
    pub static TIMER2: *mut timer_dev;
}
extern "C" {
    pub static TIMER3: *mut timer_dev;
}
extern "C" {
    pub static TIMER4: *mut timer_dev;
}
extern "C" {
    pub fn __error();
}
extern "C" {
    pub fn _fail(arg1: *const super::c_char, arg2: super::c_int, arg3: *const super::c_char);
}
extern "C" {
    pub fn throb();
}
#[doc = " NVIC register map type."]
#[repr(C)]
pub struct nvic_reg_map {
    #[doc = "< Interrupt Set Enable Registers"]
    pub ISER: [uint32; 8usize],
    #[doc = " Reserved"]
    pub RESERVED0: [uint32; 24usize],
    #[doc = "< Interrupt Clear Enable Registers"]
    pub ICER: [uint32; 8usize],
    #[doc = " Reserved"]
    pub RESERVED1: [uint32; 24usize],
    #[doc = "< Interrupt Set Pending Registers"]
    pub ISPR: [uint32; 8usize],
    #[doc = " Reserved"]
    pub RESERVED2: [uint32; 24usize],
    #[doc = "< Interrupt Clear Pending Registers"]
    pub ICPR: [uint32; 8usize],
    #[doc = " Reserved"]
    pub RESERVED3: [uint32; 24usize],
    #[doc = "< Interrupt Active bit Registers"]
    pub IABR: [uint32; 8usize],
    #[doc = " Reserved"]
    pub RESERVED4: [uint32; 56usize],
    #[doc = "< Interrupt Priority Registers"]
    pub IP: [uint8; 240usize],
    #[doc = " Reserved"]
    pub RESERVED5: [uint32; 644usize],
    #[doc = "< Software Trigger Interrupt Registers"]
    pub STIR: uint32,
}
#[test]
fn bindgen_test_layout_nvic_reg_map() {
    assert_eq!(
        ::core::mem::size_of::<nvic_reg_map>(),
        3588usize,
        concat!("Size of: ", stringify!(nvic_reg_map))
    );
    assert_eq!(
        ::core::mem::align_of::<nvic_reg_map>(),
        4usize,
        concat!("Alignment of ", stringify!(nvic_reg_map))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nvic_reg_map>())).ISER as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nvic_reg_map),
            "::",
            stringify!(ISER)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nvic_reg_map>())).RESERVED0 as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(nvic_reg_map),
            "::",
            stringify!(RESERVED0)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nvic_reg_map>())).ICER as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(nvic_reg_map),
            "::",
            stringify!(ICER)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nvic_reg_map>())).RESERVED1 as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(nvic_reg_map),
            "::",
            stringify!(RESERVED1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nvic_reg_map>())).ISPR as *const _ as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(nvic_reg_map),
            "::",
            stringify!(ISPR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nvic_reg_map>())).RESERVED2 as *const _ as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(nvic_reg_map),
            "::",
            stringify!(RESERVED2)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nvic_reg_map>())).ICPR as *const _ as usize },
        384usize,
        concat!(
            "Offset of field: ",
            stringify!(nvic_reg_map),
            "::",
            stringify!(ICPR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nvic_reg_map>())).RESERVED3 as *const _ as usize },
        416usize,
        concat!(
            "Offset of field: ",
            stringify!(nvic_reg_map),
            "::",
            stringify!(RESERVED3)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nvic_reg_map>())).IABR as *const _ as usize },
        512usize,
        concat!(
            "Offset of field: ",
            stringify!(nvic_reg_map),
            "::",
            stringify!(IABR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nvic_reg_map>())).RESERVED4 as *const _ as usize },
        544usize,
        concat!(
            "Offset of field: ",
            stringify!(nvic_reg_map),
            "::",
            stringify!(RESERVED4)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nvic_reg_map>())).IP as *const _ as usize },
        768usize,
        concat!(
            "Offset of field: ",
            stringify!(nvic_reg_map),
            "::",
            stringify!(IP)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nvic_reg_map>())).RESERVED5 as *const _ as usize },
        1008usize,
        concat!(
            "Offset of field: ",
            stringify!(nvic_reg_map),
            "::",
            stringify!(RESERVED5)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nvic_reg_map>())).STIR as *const _ as usize },
        3584usize,
        concat!(
            "Offset of field: ",
            stringify!(nvic_reg_map),
            "::",
            stringify!(STIR)
        )
    );
}
#[doc = "< Non-maskable interrupt"]
pub const nvic_irq_num_NVIC_NMI: nvic_irq_num = -14;
#[doc = "< Hard fault (all class of fault)"]
pub const nvic_irq_num_NVIC_HARDFAULT: nvic_irq_num = -13;
#[doc = "< Memory management"]
pub const nvic_irq_num_NVIC_MEM_MANAGE: nvic_irq_num = -12;
#[doc = "< Bus fault: prefetch fault, memory"]
#[doc = "access fault."]
pub const nvic_irq_num_NVIC_BUS_FAULT: nvic_irq_num = -11;
#[doc = "< Usage fault: Undefined instruction or"]
#[doc = "illegal state."]
pub const nvic_irq_num_NVIC_USAGE_FAULT: nvic_irq_num = -10;
#[doc = "< System service call via SWI insruction"]
pub const nvic_irq_num_NVIC_SVC: nvic_irq_num = -5;
#[doc = "< Debug monitor"]
pub const nvic_irq_num_NVIC_DEBUG_MON: nvic_irq_num = -4;
#[doc = "< Pendable request for system service"]
pub const nvic_irq_num_NVIC_PEND_SVC: nvic_irq_num = -2;
#[doc = "< System tick timer"]
pub const nvic_irq_num_NVIC_SYSTICK: nvic_irq_num = -1;
#[doc = "< Window watchdog interrupt"]
pub const nvic_irq_num_NVIC_WWDG: nvic_irq_num = 0;
#[doc = "< PVD through EXTI line detection"]
pub const nvic_irq_num_NVIC_PVD: nvic_irq_num = 1;
#[doc = "< Tamper"]
pub const nvic_irq_num_NVIC_TAMPER: nvic_irq_num = 2;
#[doc = "< Real-time clock"]
pub const nvic_irq_num_NVIC_RTC: nvic_irq_num = 3;
#[doc = "< Flash"]
pub const nvic_irq_num_NVIC_FLASH: nvic_irq_num = 4;
#[doc = "< Reset and clock control"]
pub const nvic_irq_num_NVIC_RCC: nvic_irq_num = 5;
#[doc = "< EXTI line 0"]
pub const nvic_irq_num_NVIC_EXTI0: nvic_irq_num = 6;
#[doc = "< EXTI line 1"]
pub const nvic_irq_num_NVIC_EXTI1: nvic_irq_num = 7;
#[doc = "< EXTI line 2"]
pub const nvic_irq_num_NVIC_EXTI2: nvic_irq_num = 8;
#[doc = "< EXTI line 3"]
pub const nvic_irq_num_NVIC_EXTI3: nvic_irq_num = 9;
#[doc = "< EXTI line 4"]
pub const nvic_irq_num_NVIC_EXTI4: nvic_irq_num = 10;
#[doc = "< DMA1 channel 1"]
pub const nvic_irq_num_NVIC_DMA_CH1: nvic_irq_num = 11;
#[doc = "< DMA1 channel 2"]
pub const nvic_irq_num_NVIC_DMA_CH2: nvic_irq_num = 12;
#[doc = "< DMA1 channel 3"]
pub const nvic_irq_num_NVIC_DMA_CH3: nvic_irq_num = 13;
#[doc = "< DMA1 channel 4"]
pub const nvic_irq_num_NVIC_DMA_CH4: nvic_irq_num = 14;
#[doc = "< DMA1 channel 5"]
pub const nvic_irq_num_NVIC_DMA_CH5: nvic_irq_num = 15;
#[doc = "< DMA1 channel 6"]
pub const nvic_irq_num_NVIC_DMA_CH6: nvic_irq_num = 16;
#[doc = "< DMA1 channel 7"]
pub const nvic_irq_num_NVIC_DMA_CH7: nvic_irq_num = 17;
#[doc = "< ADC1 and ADC2"]
pub const nvic_irq_num_NVIC_ADC_1_2: nvic_irq_num = 18;
#[doc = "< USB high priority or CAN TX"]
pub const nvic_irq_num_NVIC_USB_HP_CAN_TX: nvic_irq_num = 19;
#[doc = "< USB low priority or CAN RX0"]
pub const nvic_irq_num_NVIC_USB_LP_CAN_RX0: nvic_irq_num = 20;
#[doc = "< CAN RX1"]
pub const nvic_irq_num_NVIC_CAN_RX1: nvic_irq_num = 21;
#[doc = "< CAN SCE"]
pub const nvic_irq_num_NVIC_CAN_SCE: nvic_irq_num = 22;
#[doc = "< EXTI line [9:5]"]
pub const nvic_irq_num_NVIC_EXTI_9_5: nvic_irq_num = 23;
#[doc = "< Timer 1 break, Timer 9."]
pub const nvic_irq_num_NVIC_TIMER1_BRK_TIMER9: nvic_irq_num = 24;
#[doc = "< Timer 1 update, Timer 10."]
pub const nvic_irq_num_NVIC_TIMER1_UP_TIMER10: nvic_irq_num = 25;
#[doc = "<"]
#[doc = " Timer 1 trigger and commutation,"]
#[doc = " Timer 11."]
pub const nvic_irq_num_NVIC_TIMER1_TRG_COM_TIMER11: nvic_irq_num = 26;
#[doc = "< Timer 1 capture/compare"]
pub const nvic_irq_num_NVIC_TIMER1_CC: nvic_irq_num = 27;
#[doc = "< Timer 2"]
pub const nvic_irq_num_NVIC_TIMER2: nvic_irq_num = 28;
#[doc = "< Timer 3"]
pub const nvic_irq_num_NVIC_TIMER3: nvic_irq_num = 29;
#[doc = "< Timer 4"]
pub const nvic_irq_num_NVIC_TIMER4: nvic_irq_num = 30;
#[doc = "< I2C1 event"]
pub const nvic_irq_num_NVIC_I2C1_EV: nvic_irq_num = 31;
#[doc = "< I2C1 error"]
pub const nvic_irq_num_NVIC_I2C1_ER: nvic_irq_num = 32;
#[doc = "< I2C2 event"]
pub const nvic_irq_num_NVIC_I2C2_EV: nvic_irq_num = 33;
#[doc = "< I2C2 error"]
pub const nvic_irq_num_NVIC_I2C2_ER: nvic_irq_num = 34;
#[doc = "< SPI1"]
pub const nvic_irq_num_NVIC_SPI1: nvic_irq_num = 35;
#[doc = "< SPI2"]
pub const nvic_irq_num_NVIC_SPI2: nvic_irq_num = 36;
#[doc = "< USART1"]
pub const nvic_irq_num_NVIC_USART1: nvic_irq_num = 37;
#[doc = "< USART2"]
pub const nvic_irq_num_NVIC_USART2: nvic_irq_num = 38;
#[doc = "< USART3"]
pub const nvic_irq_num_NVIC_USART3: nvic_irq_num = 39;
#[doc = "< EXTI line [15:10]"]
pub const nvic_irq_num_NVIC_EXTI_15_10: nvic_irq_num = 40;
#[doc = "< RTC alarm through EXTI line"]
pub const nvic_irq_num_NVIC_RTCALARM: nvic_irq_num = 41;
#[doc = "< USB wakeup from suspend through"]
#[doc = "EXTI line"]
pub const nvic_irq_num_NVIC_USBWAKEUP: nvic_irq_num = 42;
#[doc = "< Timer 8 break, timer 12"]
pub const nvic_irq_num_NVIC_TIMER8_BRK_TIMER12: nvic_irq_num = 43;
#[doc = "< Timer 8 update, timer 13"]
pub const nvic_irq_num_NVIC_TIMER8_UP_TIMER13: nvic_irq_num = 44;
#[doc = "<"]
#[doc = " Timer 8 trigger and commutation,"]
#[doc = " Timer 14."]
pub const nvic_irq_num_NVIC_TIMER8_TRG_COM_TIMER14: nvic_irq_num = 45;
#[doc = "< Timer 8 capture/compare"]
pub const nvic_irq_num_NVIC_TIMER8_CC: nvic_irq_num = 46;
#[doc = "< ADC3"]
pub const nvic_irq_num_NVIC_ADC3: nvic_irq_num = 47;
#[doc = "< FSMC"]
pub const nvic_irq_num_NVIC_FSMC: nvic_irq_num = 48;
#[doc = "< SDIO"]
pub const nvic_irq_num_NVIC_SDIO: nvic_irq_num = 49;
#[doc = "< Timer 5"]
pub const nvic_irq_num_NVIC_TIMER5: nvic_irq_num = 50;
#[doc = "< SPI3"]
pub const nvic_irq_num_NVIC_SPI3: nvic_irq_num = 51;
#[doc = "< UART4"]
pub const nvic_irq_num_NVIC_UART4: nvic_irq_num = 52;
#[doc = "< UART5"]
pub const nvic_irq_num_NVIC_UART5: nvic_irq_num = 53;
#[doc = "< Timer 6"]
pub const nvic_irq_num_NVIC_TIMER6: nvic_irq_num = 54;
#[doc = "< Timer 7"]
pub const nvic_irq_num_NVIC_TIMER7: nvic_irq_num = 55;
#[doc = "< DMA2 channel 1"]
pub const nvic_irq_num_NVIC_DMA2_CH1: nvic_irq_num = 56;
#[doc = "< DMA2 channel 2"]
pub const nvic_irq_num_NVIC_DMA2_CH2: nvic_irq_num = 57;
#[doc = "< DMA2 channel 3"]
pub const nvic_irq_num_NVIC_DMA2_CH3: nvic_irq_num = 58;
#[doc = "< DMA2 channels 4 and 5"]
pub const nvic_irq_num_NVIC_DMA2_CH_4_5: nvic_irq_num = 59;
pub const nvic_irq_num_NVIC_TIMER1_BRK: nvic_irq_num = 24;
pub const nvic_irq_num_NVIC_TIMER1_UP: nvic_irq_num = 25;
pub const nvic_irq_num_NVIC_TIMER1_TRG_COM: nvic_irq_num = 26;
pub const nvic_irq_num_NVIC_TIMER8_BRK: nvic_irq_num = 43;
pub const nvic_irq_num_NVIC_TIMER8_UP: nvic_irq_num = 44;
pub const nvic_irq_num_NVIC_TIMER8_TRG_COM: nvic_irq_num = 45;
#[doc = " @brief STM32F1 interrupt vector table interrupt numbers."]
#[doc = " @see <libmaple/scb.h>"]
pub type nvic_irq_num = i32;
extern "C" {
    pub fn nvic_init(address: uint32, offset: uint32);
}
extern "C" {
    pub fn nvic_set_vector_table(address: uint32, offset: uint32);
}
extern "C" {
    pub fn nvic_irq_set_priority(irqn: nvic_irq_num, priority: uint8);
}
extern "C" {
    pub fn nvic_sys_reset();
}
#[doc = " Advanced control timer register map type"]
#[repr(C)]
pub struct timer_adv_reg_map {
    #[doc = "< Control register 1"]
    pub CR1: uint32,
    #[doc = "< Control register 2"]
    pub CR2: uint32,
    #[doc = "< Slave mode control register"]
    pub SMCR: uint32,
    #[doc = "< DMA/interrupt enable register"]
    pub DIER: uint32,
    #[doc = "< Status register"]
    pub SR: uint32,
    #[doc = "< Event generation register"]
    pub EGR: uint32,
    #[doc = "< Capture/compare mode register 1"]
    pub CCMR1: uint32,
    #[doc = "< Capture/compare mode register 2"]
    pub CCMR2: uint32,
    #[doc = "< Capture/compare enable register"]
    pub CCER: uint32,
    #[doc = "< Counter"]
    pub CNT: uint32,
    #[doc = "< Prescaler"]
    pub PSC: uint32,
    #[doc = "< Auto-reload register"]
    pub ARR: uint32,
    #[doc = "< Repetition counter register"]
    pub RCR: uint32,
    #[doc = "< Capture/compare register 1"]
    pub CCR1: uint32,
    #[doc = "< Capture/compare register 2"]
    pub CCR2: uint32,
    #[doc = "< Capture/compare register 3"]
    pub CCR3: uint32,
    #[doc = "< Capture/compare register 4"]
    pub CCR4: uint32,
    #[doc = "< Break and dead-time register"]
    pub BDTR: uint32,
    #[doc = "< DMA control register"]
    pub DCR: uint32,
    #[doc = "< DMA address for full transfer"]
    pub DMAR: uint32,
}
#[test]
fn bindgen_test_layout_timer_adv_reg_map() {
    assert_eq!(
        ::core::mem::size_of::<timer_adv_reg_map>(),
        80usize,
        concat!("Size of: ", stringify!(timer_adv_reg_map))
    );
    assert_eq!(
        ::core::mem::align_of::<timer_adv_reg_map>(),
        4usize,
        concat!("Alignment of ", stringify!(timer_adv_reg_map))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<timer_adv_reg_map>())).CR1 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timer_adv_reg_map),
            "::",
            stringify!(CR1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<timer_adv_reg_map>())).CR2 as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(timer_adv_reg_map),
            "::",
            stringify!(CR2)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<timer_adv_reg_map>())).SMCR as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timer_adv_reg_map),
            "::",
            stringify!(SMCR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<timer_adv_reg_map>())).DIER as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(timer_adv_reg_map),
            "::",
            stringify!(DIER)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<timer_adv_reg_map>())).SR as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(timer_adv_reg_map),
            "::",
            stringify!(SR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<timer_adv_reg_map>())).EGR as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(timer_adv_reg_map),
            "::",
            stringify!(EGR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<timer_adv_reg_map>())).CCMR1 as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(timer_adv_reg_map),
            "::",
            stringify!(CCMR1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<timer_adv_reg_map>())).CCMR2 as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(timer_adv_reg_map),
            "::",
            stringify!(CCMR2)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<timer_adv_reg_map>())).CCER as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(timer_adv_reg_map),
            "::",
            stringify!(CCER)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<timer_adv_reg_map>())).CNT as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(timer_adv_reg_map),
            "::",
            stringify!(CNT)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<timer_adv_reg_map>())).PSC as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(timer_adv_reg_map),
            "::",
            stringify!(PSC)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<timer_adv_reg_map>())).ARR as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(timer_adv_reg_map),
            "::",
            stringify!(ARR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<timer_adv_reg_map>())).RCR as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(timer_adv_reg_map),
            "::",
            stringify!(RCR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<timer_adv_reg_map>())).CCR1 as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(timer_adv_reg_map),
            "::",
            stringify!(CCR1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<timer_adv_reg_map>())).CCR2 as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(timer_adv_reg_map),
            "::",
            stringify!(CCR2)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<timer_adv_reg_map>())).CCR3 as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(timer_adv_reg_map),
            "::",
            stringify!(CCR3)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<timer_adv_reg_map>())).CCR4 as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(timer_adv_reg_map),
            "::",
            stringify!(CCR4)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<timer_adv_reg_map>())).BDTR as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(timer_adv_reg_map),
            "::",
            stringify!(BDTR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<timer_adv_reg_map>())).DCR as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(timer_adv_reg_map),
            "::",
            stringify!(DCR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<timer_adv_reg_map>())).DMAR as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(timer_adv_reg_map),
            "::",
            stringify!(DMAR)
        )
    );
}
#[doc = " Basic timer register map type"]
#[repr(C)]
pub struct timer_bas_reg_map {
    #[doc = "< Control register 1"]
    pub CR1: uint32,
    #[doc = "< Control register 2"]
    pub CR2: uint32,
    #[doc = "< Reserved"]
    pub RESERVED1: uint32,
    #[doc = "< DMA/interrupt enable register"]
    pub DIER: uint32,
    #[doc = "< Status register"]
    pub SR: uint32,
    #[doc = "< Event generation register"]
    pub EGR: uint32,
    #[doc = "< Reserved"]
    pub RESERVED2: uint32,
    #[doc = "< Reserved"]
    pub RESERVED3: uint32,
    #[doc = "< Reserved"]
    pub RESERVED4: uint32,
    #[doc = "< Counter"]
    pub CNT: uint32,
    #[doc = "< Prescaler"]
    pub PSC: uint32,
    #[doc = "< Auto-reload register"]
    pub ARR: uint32,
}
#[test]
fn bindgen_test_layout_timer_bas_reg_map() {
    assert_eq!(
        ::core::mem::size_of::<timer_bas_reg_map>(),
        48usize,
        concat!("Size of: ", stringify!(timer_bas_reg_map))
    );
    assert_eq!(
        ::core::mem::align_of::<timer_bas_reg_map>(),
        4usize,
        concat!("Alignment of ", stringify!(timer_bas_reg_map))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<timer_bas_reg_map>())).CR1 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timer_bas_reg_map),
            "::",
            stringify!(CR1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<timer_bas_reg_map>())).CR2 as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(timer_bas_reg_map),
            "::",
            stringify!(CR2)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<timer_bas_reg_map>())).RESERVED1 as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timer_bas_reg_map),
            "::",
            stringify!(RESERVED1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<timer_bas_reg_map>())).DIER as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(timer_bas_reg_map),
            "::",
            stringify!(DIER)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<timer_bas_reg_map>())).SR as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(timer_bas_reg_map),
            "::",
            stringify!(SR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<timer_bas_reg_map>())).EGR as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(timer_bas_reg_map),
            "::",
            stringify!(EGR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<timer_bas_reg_map>())).RESERVED2 as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(timer_bas_reg_map),
            "::",
            stringify!(RESERVED2)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<timer_bas_reg_map>())).RESERVED3 as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(timer_bas_reg_map),
            "::",
            stringify!(RESERVED3)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<timer_bas_reg_map>())).RESERVED4 as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(timer_bas_reg_map),
            "::",
            stringify!(RESERVED4)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<timer_bas_reg_map>())).CNT as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(timer_bas_reg_map),
            "::",
            stringify!(CNT)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<timer_bas_reg_map>())).PSC as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(timer_bas_reg_map),
            "::",
            stringify!(PSC)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<timer_bas_reg_map>())).ARR as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(timer_bas_reg_map),
            "::",
            stringify!(ARR)
        )
    );
}
#[doc = " @brief Timer register map type."]
#[doc = ""]
#[doc = " Just holds a pointer to the correct type of register map, based on"]
#[doc = " the timer's type."]
#[repr(C)]
pub struct timer_reg_map {
    #[doc = "< Advanced register map"]
    pub adv: __BindgenUnionField<*mut timer_adv_reg_map>,
    #[doc = "< General purpose register map"]
    pub gen: __BindgenUnionField<*mut timer_gen_reg_map>,
    #[doc = "< Basic register map"]
    pub bas: __BindgenUnionField<*mut timer_bas_reg_map>,
    pub bindgen_union_field: u32,
}
#[test]
fn bindgen_test_layout_timer_reg_map() {
    assert_eq!(
        ::core::mem::size_of::<timer_reg_map>(),
        4usize,
        concat!("Size of: ", stringify!(timer_reg_map))
    );
    assert_eq!(
        ::core::mem::align_of::<timer_reg_map>(),
        4usize,
        concat!("Alignment of ", stringify!(timer_reg_map))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<timer_reg_map>())).adv as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timer_reg_map),
            "::",
            stringify!(adv)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<timer_reg_map>())).gen as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timer_reg_map),
            "::",
            stringify!(gen)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<timer_reg_map>())).bas as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timer_reg_map),
            "::",
            stringify!(bas)
        )
    );
}
#[doc = "< Advanced type"]
pub const timer_type_TIMER_ADVANCED: timer_type = 0;
#[doc = "< General purpose type"]
pub const timer_type_TIMER_GENERAL: timer_type = 1;
#[doc = "< Basic type"]
pub const timer_type_TIMER_BASIC: timer_type = 2;
#[doc = " @brief Timer type"]
#[doc = ""]
#[doc = " Type marker for timer_dev."]
#[doc = ""]
#[doc = " @see timer_dev"]
pub type timer_type = u32;
#[doc = " Timer device type"]
#[repr(C)]
pub struct timer_dev {
    #[doc = "< Register map"]
    pub regs: timer_reg_map,
    #[doc = "< RCC clock information"]
    pub clk_id: rcc_clk_id,
    #[doc = "< Timer's type"]
    pub type_: timer_type,
    #[doc = "<"]
    #[doc = " Don't touch these. Use these instead:"]
    #[doc = " @see timer_attach_interrupt()"]
    #[doc = " @see timer_detach_interrupt()"]
    pub handlers: __IncompleteArrayField<voidFuncPtr>,
}
#[test]
fn bindgen_test_layout_timer_dev() {
    assert_eq!(
        ::core::mem::size_of::<timer_dev>(),
        12usize,
        concat!("Size of: ", stringify!(timer_dev))
    );
    assert_eq!(
        ::core::mem::align_of::<timer_dev>(),
        4usize,
        concat!("Alignment of ", stringify!(timer_dev))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<timer_dev>())).regs as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timer_dev),
            "::",
            stringify!(regs)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<timer_dev>())).clk_id as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(timer_dev),
            "::",
            stringify!(clk_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<timer_dev>())).type_ as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timer_dev),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<timer_dev>())).handlers as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(timer_dev),
            "::",
            stringify!(handlers)
        )
    );
}
extern "C" {
    pub static mut timer1: timer_dev;
}
extern "C" {
    pub static mut timer2: timer_dev;
}
extern "C" {
    pub static mut timer3: timer_dev;
}
extern "C" {
    pub static mut timer4: timer_dev;
}
#[doc = " The timer stops counting, channel interrupts are detached, and"]
#[doc = " no state changes are output."]
pub const timer_mode_TIMER_DISABLED: timer_mode = 0;
#[doc = " PWM output."]
pub const timer_mode_TIMER_PWM: timer_mode = 1;
#[doc = " The timer counts from 0 to its reload value repeatedly; every"]
#[doc = " time the counter value reaches one of the channel compare"]
#[doc = " values, the corresponding interrupt is fired."]
pub const timer_mode_TIMER_OUTPUT_COMPARE: timer_mode = 2;
#[doc = " The timer counts from 0 to its reload value repeatedly; every"]
#[doc = " time the counter value reaches one of the channel compare"]
#[doc = " values, the corresponding interrupt is fired."]
pub const timer_mode_TIMER_ENCODER: timer_mode = 3;
#[doc = " The timer counts from 0 to its reload value repeatedly; every"]
#[doc = " time the counter value reaches one of the channel compare"]
#[doc = " values, the corresponding interrupt is fired."]
pub const timer_mode_TIMER_INPUT_CAPTURE: timer_mode = 4;
#[doc = " @brief Used to configure the behavior of a timer channel."]
#[doc = ""]
#[doc = " Be careful: not all timers can be configured in every mode."]
pub type timer_mode = u32;
#[doc = "< Channel 1"]
pub const timer_channel_TIMER_CH1: timer_channel = 1;
#[doc = "< Channel 2"]
pub const timer_channel_TIMER_CH2: timer_channel = 2;
#[doc = "< Channel 3"]
pub const timer_channel_TIMER_CH3: timer_channel = 3;
#[doc = "< Channel 4"]
pub const timer_channel_TIMER_CH4: timer_channel = 4;
#[doc = " Timer channel numbers"]
pub type timer_channel = u32;
extern "C" {
    pub fn timer_init(dev: *mut timer_dev);
}
extern "C" {
    pub fn timer_disable(dev: *mut timer_dev);
}
extern "C" {
    pub fn timer_set_mode(dev: *mut timer_dev, channel: uint8, mode: timer_mode);
}
extern "C" {
    pub fn timer_foreach(fn_: ::core::option::Option<unsafe extern "C" fn(arg1: *mut timer_dev)>);
}
extern "C" {
    pub fn timer_has_cc_channel(dev: *mut timer_dev, channel: uint8) -> super::c_int;
}
#[doc = "< Update interrupt."]
pub const timer_interrupt_id_TIMER_UPDATE_INTERRUPT: timer_interrupt_id = 0;
#[doc = "< Capture/compare 1 interrupt."]
pub const timer_interrupt_id_TIMER_CC1_INTERRUPT: timer_interrupt_id = 1;
#[doc = "< Capture/compare 2 interrupt."]
pub const timer_interrupt_id_TIMER_CC2_INTERRUPT: timer_interrupt_id = 2;
#[doc = "< Capture/compare 3 interrupt."]
pub const timer_interrupt_id_TIMER_CC3_INTERRUPT: timer_interrupt_id = 3;
#[doc = "< Capture/compare 4 interrupt."]
pub const timer_interrupt_id_TIMER_CC4_INTERRUPT: timer_interrupt_id = 4;
#[doc = "< COM interrupt."]
pub const timer_interrupt_id_TIMER_COM_INTERRUPT: timer_interrupt_id = 5;
#[doc = "< Trigger interrupt."]
pub const timer_interrupt_id_TIMER_TRG_INTERRUPT: timer_interrupt_id = 6;
#[doc = "< Break interrupt."]
pub const timer_interrupt_id_TIMER_BREAK_INTERRUPT: timer_interrupt_id = 7;
#[doc = " @brief Timer interrupt number."]
#[doc = ""]
#[doc = " Not all timers support all of these values. All timers support"]
#[doc = " TIMER_UPDATE_INTERRUPT. \"General purpose\" timers can be a special"]
#[doc = " nuisance in this regard, as they individually support different"]
#[doc = " subsets of the available interupts. Consult your target's reference"]
#[doc = " manual for the details."]
pub type timer_interrupt_id = u32;
extern "C" {
    pub fn timer_attach_interrupt(dev: *mut timer_dev, interrupt: uint8, handler: voidFuncPtr);
}
extern "C" {
    pub fn timer_detach_interrupt(dev: *mut timer_dev, interrupt: uint8);
}
extern "C" {
    pub fn get_direction(dev: *mut timer_dev) -> uint8;
}
#[doc = " Base is control register 1"]
pub const timer_dma_base_addr_TIMER_DMA_BASE_CR1: timer_dma_base_addr = 0;
#[doc = " Base is control register 2"]
pub const timer_dma_base_addr_TIMER_DMA_BASE_CR2: timer_dma_base_addr = 1;
#[doc = " Base is slave mode control register"]
pub const timer_dma_base_addr_TIMER_DMA_BASE_SMCR: timer_dma_base_addr = 2;
#[doc = " Base is DMA interrupt enable register"]
pub const timer_dma_base_addr_TIMER_DMA_BASE_DIER: timer_dma_base_addr = 3;
#[doc = " Base is status register"]
pub const timer_dma_base_addr_TIMER_DMA_BASE_SR: timer_dma_base_addr = 4;
#[doc = " Base is event generation register"]
pub const timer_dma_base_addr_TIMER_DMA_BASE_EGR: timer_dma_base_addr = 5;
#[doc = " Base is capture/compare mode register 1"]
pub const timer_dma_base_addr_TIMER_DMA_BASE_CCMR1: timer_dma_base_addr = 6;
#[doc = " Base is capture/compare mode register 2"]
pub const timer_dma_base_addr_TIMER_DMA_BASE_CCMR2: timer_dma_base_addr = 7;
#[doc = " Base is capture/compare enable register"]
pub const timer_dma_base_addr_TIMER_DMA_BASE_CCER: timer_dma_base_addr = 8;
#[doc = " Base is counter"]
pub const timer_dma_base_addr_TIMER_DMA_BASE_CNT: timer_dma_base_addr = 9;
#[doc = " Base is prescaler"]
pub const timer_dma_base_addr_TIMER_DMA_BASE_PSC: timer_dma_base_addr = 10;
#[doc = " Base is auto-reload register"]
pub const timer_dma_base_addr_TIMER_DMA_BASE_ARR: timer_dma_base_addr = 11;
#[doc = " Base is repetition counter register"]
pub const timer_dma_base_addr_TIMER_DMA_BASE_RCR: timer_dma_base_addr = 12;
#[doc = " Base is capture/compare register 1"]
pub const timer_dma_base_addr_TIMER_DMA_BASE_CCR1: timer_dma_base_addr = 13;
#[doc = " Base is capture/compare register 2"]
pub const timer_dma_base_addr_TIMER_DMA_BASE_CCR2: timer_dma_base_addr = 14;
#[doc = " Base is capture/compare register 3"]
pub const timer_dma_base_addr_TIMER_DMA_BASE_CCR3: timer_dma_base_addr = 15;
#[doc = " Base is capture/compare register 4"]
pub const timer_dma_base_addr_TIMER_DMA_BASE_CCR4: timer_dma_base_addr = 16;
#[doc = " Base is break and dead-time register"]
pub const timer_dma_base_addr_TIMER_DMA_BASE_BDTR: timer_dma_base_addr = 17;
#[doc = " Base is DMA control register"]
pub const timer_dma_base_addr_TIMER_DMA_BASE_DCR: timer_dma_base_addr = 18;
#[doc = " Base is DMA address for full transfer"]
pub const timer_dma_base_addr_TIMER_DMA_BASE_DMAR: timer_dma_base_addr = 19;
#[doc = " @brief Timer DMA base address."]
#[doc = ""]
#[doc = " Defines the base address for DMA transfers."]
pub type timer_dma_base_addr = u32;
#[doc = " Frozen: comparison between output compare register and counter"]
#[doc = " has no effect on the outputs."]
pub const timer_oc_mode_TIMER_OC_MODE_FROZEN: timer_oc_mode = 0;
#[doc = " OCxREF signal is forced high when the count matches the channel"]
#[doc = " capture/compare register."]
pub const timer_oc_mode_TIMER_OC_MODE_ACTIVE_ON_MATCH: timer_oc_mode = 16;
#[doc = " OCxREF signal is forced low when the counter matches the"]
#[doc = " channel capture/compare register."]
pub const timer_oc_mode_TIMER_OC_MODE_INACTIVE_ON_MATCH: timer_oc_mode = 32;
#[doc = " OCxREF toggles when counter matches the channel capture/compare"]
#[doc = " register."]
pub const timer_oc_mode_TIMER_OC_MODE_TOGGLE: timer_oc_mode = 48;
#[doc = " OCxREF is forced low."]
pub const timer_oc_mode_TIMER_OC_MODE_FORCE_INACTIVE: timer_oc_mode = 64;
#[doc = " OCxREF is forced high."]
pub const timer_oc_mode_TIMER_OC_MODE_FORCE_ACTIVE: timer_oc_mode = 80;
#[doc = " PWM mode 1.  In upcounting, channel is active as long as count"]
#[doc = " is less than channel capture/compare register, else inactive."]
#[doc = " In downcounting, channel is inactive as long as count exceeds"]
#[doc = " capture/compare register, else active."]
pub const timer_oc_mode_TIMER_OC_MODE_PWM_1: timer_oc_mode = 96;
#[doc = " PWM mode 2. In upcounting, channel is inactive as long as count"]
#[doc = " is less than capture/compare register, else active.  In"]
#[doc = " downcounting, channel is active as long as count exceeds"]
#[doc = " capture/compare register, else inactive."]
pub const timer_oc_mode_TIMER_OC_MODE_PWM_2: timer_oc_mode = 112;
#[doc = " Timer output compare modes."]
pub type timer_oc_mode = u32;
#[doc = "< Output compare clear enable."]
pub const timer_oc_mode_flags_TIMER_OC_CE: timer_oc_mode_flags = 128;
#[doc = "< Output compare preload enable."]
pub const timer_oc_mode_flags_TIMER_OC_PE: timer_oc_mode_flags = 8;
#[doc = "< Output compare fast enable."]
pub const timer_oc_mode_flags_TIMER_OC_FE: timer_oc_mode_flags = 4;
#[doc = " Timer output compare mode flags."]
#[doc = " @see timer_oc_set_mode()"]
pub type timer_oc_mode_flags = u32;
pub const timer_ic_input_select_TIMER_IC_INPUT_DEFAULT: timer_ic_input_select = 1;
pub const timer_ic_input_select_TIMER_IC_INPUT_SWITCH: timer_ic_input_select = 2;
pub const timer_ic_input_select_TIMER_IC_INPUT_TRC: timer_ic_input_select = 3;
#[doc = " Timer output compare modes."]
pub type timer_ic_input_select = u32;
extern "C" {
    pub fn input_capture_mode(dev: *mut timer_dev, channel: uint8, input: timer_ic_input_select);
}
#[doc = " ADC register map type."]
#[repr(C)]
pub struct adc_reg_map {
    #[doc = "< Status register"]
    pub SR: uint32,
    #[doc = "< Control register 1"]
    pub CR1: uint32,
    #[doc = "< Control register 2"]
    pub CR2: uint32,
    #[doc = "< Sample time register 1"]
    pub SMPR1: uint32,
    #[doc = "< Sample time register 2"]
    pub SMPR2: uint32,
    #[doc = "< Injected channel data offset register 1"]
    pub JOFR1: uint32,
    #[doc = "< Injected channel data offset register 2"]
    pub JOFR2: uint32,
    #[doc = "< Injected channel data offset register 3"]
    pub JOFR3: uint32,
    #[doc = "< Injected channel data offset register 4"]
    pub JOFR4: uint32,
    #[doc = "< Watchdog high threshold register"]
    pub HTR: uint32,
    #[doc = "< Watchdog low threshold register"]
    pub LTR: uint32,
    #[doc = "< Regular sequence register 1"]
    pub SQR1: uint32,
    #[doc = "< Regular sequence register 2"]
    pub SQR2: uint32,
    #[doc = "< Regular sequence register 3"]
    pub SQR3: uint32,
    #[doc = "< Injected sequence register"]
    pub JSQR: uint32,
    #[doc = "< Injected data register 1"]
    pub JDR1: uint32,
    #[doc = "< Injected data register 2"]
    pub JDR2: uint32,
    #[doc = "< Injected data register 3"]
    pub JDR3: uint32,
    #[doc = "< Injected data register 4"]
    pub JDR4: uint32,
    #[doc = "< Regular data register"]
    pub DR: uint32,
}
#[test]
fn bindgen_test_layout_adc_reg_map() {
    assert_eq!(
        ::core::mem::size_of::<adc_reg_map>(),
        80usize,
        concat!("Size of: ", stringify!(adc_reg_map))
    );
    assert_eq!(
        ::core::mem::align_of::<adc_reg_map>(),
        4usize,
        concat!("Alignment of ", stringify!(adc_reg_map))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<adc_reg_map>())).SR as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(adc_reg_map),
            "::",
            stringify!(SR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<adc_reg_map>())).CR1 as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(adc_reg_map),
            "::",
            stringify!(CR1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<adc_reg_map>())).CR2 as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(adc_reg_map),
            "::",
            stringify!(CR2)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<adc_reg_map>())).SMPR1 as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(adc_reg_map),
            "::",
            stringify!(SMPR1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<adc_reg_map>())).SMPR2 as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(adc_reg_map),
            "::",
            stringify!(SMPR2)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<adc_reg_map>())).JOFR1 as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(adc_reg_map),
            "::",
            stringify!(JOFR1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<adc_reg_map>())).JOFR2 as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(adc_reg_map),
            "::",
            stringify!(JOFR2)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<adc_reg_map>())).JOFR3 as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(adc_reg_map),
            "::",
            stringify!(JOFR3)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<adc_reg_map>())).JOFR4 as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(adc_reg_map),
            "::",
            stringify!(JOFR4)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<adc_reg_map>())).HTR as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(adc_reg_map),
            "::",
            stringify!(HTR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<adc_reg_map>())).LTR as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(adc_reg_map),
            "::",
            stringify!(LTR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<adc_reg_map>())).SQR1 as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(adc_reg_map),
            "::",
            stringify!(SQR1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<adc_reg_map>())).SQR2 as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(adc_reg_map),
            "::",
            stringify!(SQR2)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<adc_reg_map>())).SQR3 as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(adc_reg_map),
            "::",
            stringify!(SQR3)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<adc_reg_map>())).JSQR as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(adc_reg_map),
            "::",
            stringify!(JSQR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<adc_reg_map>())).JDR1 as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(adc_reg_map),
            "::",
            stringify!(JDR1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<adc_reg_map>())).JDR2 as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(adc_reg_map),
            "::",
            stringify!(JDR2)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<adc_reg_map>())).JDR3 as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(adc_reg_map),
            "::",
            stringify!(JDR3)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<adc_reg_map>())).JDR4 as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(adc_reg_map),
            "::",
            stringify!(JDR4)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<adc_reg_map>())).DR as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(adc_reg_map),
            "::",
            stringify!(DR)
        )
    );
}
#[doc = " ADC device type."]
#[repr(C)]
pub struct adc_dev {
    #[doc = "< Register map"]
    pub regs: *mut adc_reg_map,
    #[doc = "< RCC clock information"]
    pub clk_id: rcc_clk_id,
    pub irq_num: nvic_irq_num,
    pub handlers: __IncompleteArrayField<voidFuncPtr>,
}
#[test]
fn bindgen_test_layout_adc_dev() {
    assert_eq!(
        ::core::mem::size_of::<adc_dev>(),
        12usize,
        concat!("Size of: ", stringify!(adc_dev))
    );
    assert_eq!(
        ::core::mem::align_of::<adc_dev>(),
        4usize,
        concat!("Alignment of ", stringify!(adc_dev))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<adc_dev>())).regs as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(adc_dev),
            "::",
            stringify!(regs)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<adc_dev>())).clk_id as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(adc_dev),
            "::",
            stringify!(clk_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<adc_dev>())).irq_num as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(adc_dev),
            "::",
            stringify!(irq_num)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<adc_dev>())).handlers as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(adc_dev),
            "::",
            stringify!(handlers)
        )
    );
}
#[doc = "< Update interrupt."]
pub const adc_interrupt_id_ADC_EOC: adc_interrupt_id = 0;
#[doc = "< Capture/compare 1 interrupt."]
pub const adc_interrupt_id_ADC_AWD: adc_interrupt_id = 1;
pub const adc_interrupt_id_ADC_JEOC: adc_interrupt_id = 2;
pub type adc_interrupt_id = u32;
extern "C" {
    pub fn adc_enable_irq(dev: *mut adc_dev, interrupt: uint8);
}
extern "C" {
    pub fn adc_attach_interrupt(dev: *mut adc_dev, interrupt: uint8, handler: voidFuncPtr);
}
extern "C" {
    pub static mut adc1: adc_dev;
}
extern "C" {
    pub static mut ADC1: *mut adc_dev;
}
extern "C" {
    pub static mut adc2: adc_dev;
}
extern "C" {
    pub static mut ADC2: *mut adc_dev;
}
#[doc = "< ADC1, ADC2: Timer 1 CC1 event"]
pub const adc_extsel_event_ADC_EXT_EV_TIM1_CC1: adc_extsel_event = 0;
#[doc = "< ADC1, ADC2: Timer 1 CC2 event"]
pub const adc_extsel_event_ADC_EXT_EV_TIM1_CC2: adc_extsel_event = 131072;
#[doc = "< ADC1, ADC2: Timer 2 CC2 event"]
pub const adc_extsel_event_ADC_EXT_EV_TIM2_CC2: adc_extsel_event = 393216;
#[doc = "< ADC1, ADC2: Timer 3 TRGO event"]
pub const adc_extsel_event_ADC_EXT_EV_TIM3_TRGO: adc_extsel_event = 524288;
#[doc = "< ADC1, ADC2: Timer 4 CC4 event"]
pub const adc_extsel_event_ADC_EXT_EV_TIM4_CC4: adc_extsel_event = 655360;
#[doc = "< ADC1, ADC2: EXTI11 event"]
pub const adc_extsel_event_ADC_EXT_EV_EXTI11: adc_extsel_event = 786432;
#[doc = "< ADC1, ADC2, ADC3: Timer 1 CC3 event"]
pub const adc_extsel_event_ADC_EXT_EV_TIM1_CC3: adc_extsel_event = 262144;
#[doc = "< ADC1, ADC2, ADC3: Software start"]
pub const adc_extsel_event_ADC_EXT_EV_SWSTART: adc_extsel_event = 917504;
#[doc = "<"]
#[doc = " ADC3: Timer 3 CC1 event"]
#[doc = " Availability: high- and XL-density."]
pub const adc_extsel_event_ADC_EXT_EV_TIM3_CC1: adc_extsel_event = 0;
#[doc = "<"]
#[doc = " ADC3: Timer 2 CC3 event"]
#[doc = " Availability: high- and XL-density."]
pub const adc_extsel_event_ADC_EXT_EV_TIM2_CC3: adc_extsel_event = 131072;
#[doc = "<"]
#[doc = " ADC3: Timer 8 CC1 event"]
#[doc = " Availability: high- and XL-density."]
pub const adc_extsel_event_ADC_EXT_EV_TIM8_CC1: adc_extsel_event = 393216;
#[doc = "<"]
#[doc = " ADC3: Timer 8 TRGO event"]
#[doc = " Availability: high- and XL-density."]
pub const adc_extsel_event_ADC_EXT_EV_ADC3_TIM8_TRGO: adc_extsel_event = 524288;
#[doc = "<"]
#[doc = " ADC3: Timer 5 CC1 event"]
#[doc = " Availability: high- and XL-density."]
pub const adc_extsel_event_ADC_EXT_EV_TIM5_CC1: adc_extsel_event = 655360;
#[doc = "<"]
#[doc = " ADC1, ADC2: Timer 8 TRGO event"]
#[doc = " Availability: high- and XL-density."]
pub const adc_extsel_event_ADC_EXT_EV_ADC12_TIM8_TRGO: adc_extsel_event = 786432;
#[doc = "<"]
#[doc = " ADC3: Timer 5 CC3 event"]
#[doc = " Availability: high- and XL-density."]
pub const adc_extsel_event_ADC_EXT_EV_TIM5_CC3: adc_extsel_event = 786432;
#[doc = " @brief STM32F1 external event selectors for regular group"]
#[doc = "        conversion."]
#[doc = ""]
#[doc = " Some external events are only available on ADCs 1 and 2, others"]
#[doc = " only on ADC3, while others are available on all three ADCs."]
#[doc = " Additionally, some events are only available on high- and"]
#[doc = " XL-density STM32F1 MCUs, as they use peripherals only available on"]
#[doc = " those MCU densities."]
#[doc = ""]
#[doc = " For ease of use, each event selector is given along with the ADCs"]
#[doc = " it's available on, along with any other availability restrictions."]
#[doc = ""]
#[doc = " @see adc_set_extsel()"]
pub type adc_extsel_event = u32;
#[doc = "< 1.5 ADC cycles"]
pub const adc_smp_rate_ADC_SMPR_1_5: adc_smp_rate = 0;
#[doc = "< 7.5 ADC cycles"]
pub const adc_smp_rate_ADC_SMPR_7_5: adc_smp_rate = 1;
#[doc = "< 13.5 ADC cycles"]
pub const adc_smp_rate_ADC_SMPR_13_5: adc_smp_rate = 2;
#[doc = "< 28.5 ADC cycles"]
pub const adc_smp_rate_ADC_SMPR_28_5: adc_smp_rate = 3;
#[doc = "< 41.5 ADC cycles"]
pub const adc_smp_rate_ADC_SMPR_41_5: adc_smp_rate = 4;
#[doc = "< 55.5 ADC cycles"]
pub const adc_smp_rate_ADC_SMPR_55_5: adc_smp_rate = 5;
#[doc = "< 71.5 ADC cycles"]
pub const adc_smp_rate_ADC_SMPR_71_5: adc_smp_rate = 6;
#[doc = "< 239.5 ADC cycles"]
pub const adc_smp_rate_ADC_SMPR_239_5: adc_smp_rate = 7;
#[doc = " @brief STM32F1 sample times, in ADC clock cycles."]
#[doc = ""]
#[doc = " These control the amount of time spent sampling the input voltage."]
pub type adc_smp_rate = u32;
#[doc = " PCLK2 divided by 2"]
pub const adc_prescaler_ADC_PRE_PCLK2_DIV_2: adc_prescaler = 0;
#[doc = " PCLK2 divided by 4"]
pub const adc_prescaler_ADC_PRE_PCLK2_DIV_4: adc_prescaler = 16384;
#[doc = " PCLK2 divided by 6"]
pub const adc_prescaler_ADC_PRE_PCLK2_DIV_6: adc_prescaler = 32768;
#[doc = " PCLK2 divided by 8"]
pub const adc_prescaler_ADC_PRE_PCLK2_DIV_8: adc_prescaler = 49152;
#[doc = " @brief STM32F1 ADC prescalers, as divisors of PCLK2."]
pub type adc_prescaler = u32;
extern "C" {
    pub fn adc_calibrate(dev: *mut adc_dev);
}
extern "C" {
    pub fn adc_init(dev: *mut adc_dev);
}
extern "C" {
    pub fn adc_set_extsel(dev: *mut adc_dev, event: adc_extsel_event);
}
extern "C" {
    pub fn adc_set_sample_rate(dev: *mut adc_dev, smp_rate: adc_smp_rate);
}
extern "C" {
    pub fn adc_read(dev: *mut adc_dev, channel: uint8) -> uint16;
}
extern "C" {
    #[doc = " @brief Set the ADC prescaler."]
    #[doc = ""]
    #[doc = " This determines the ADC clock for all devices."]
    pub fn adc_set_prescaler(pre: adc_prescaler);
}
extern "C" {
    #[doc = " @brief Call a function on all ADC devices."]
    #[doc = " @param fn Function to call on each ADC device."]
    pub fn adc_foreach(fn_: ::core::option::Option<unsafe extern "C" fn(arg1: *mut adc_dev)>);
}
extern "C" {
    #[doc = " @brief Configure a GPIO pin for ADC conversion."]
    #[doc = " @param dev ADC device to use for conversion (currently ignored on"]
    #[doc = "            all targets)."]
    #[doc = " @param gdev GPIO device to configure."]
    #[doc = " @param bit Bit on gdev to configure for ADC conversion."]
    pub fn adc_config_gpio(dev: *mut adc_dev, gdev: *mut gpio_dev, bit: uint8);
}
extern "C" {
    #[doc = " @brief Enable an ADC and configure it for single conversion mode."]
    #[doc = ""]
    #[doc = " This function performs any initialization necessary to allow the"]
    #[doc = " ADC device to perform a single synchronous regular software"]
    #[doc = " triggered conversion, using adc_read()."]
    #[doc = ""]
    #[doc = " @param dev Device to enable."]
    #[doc = " @see adc_read()"]
    pub fn adc_enable_single_swstart(dev: *mut adc_dev);
}
#[doc = " @brief Stores STM32-specific information related to a given Maple pin."]
#[doc = " @see PIN_MAP"]
#[repr(C)]
pub struct stm32_pin_info {
    #[doc = "< Maple pin's GPIO device"]
    pub gpio_device: *mut gpio_dev,
    #[doc = "< Pin's timer device, if any."]
    pub timer_device: *mut timer_dev,
    #[doc = "< ADC device, if any."]
    pub adc_device: *mut adc_dev,
    #[doc = "< Pin's GPIO port bit."]
    pub gpio_bit: uint8,
    #[doc = "< Timer channel, or 0 if none."]
    pub timer_channel: uint8,
    #[doc = "< Pin ADC channel, or ADCx if none."]
    pub adc_channel: uint8,
}
#[test]
fn bindgen_test_layout_stm32_pin_info() {
    assert_eq!(
        ::core::mem::size_of::<stm32_pin_info>(),
        16usize,
        concat!("Size of: ", stringify!(stm32_pin_info))
    );
    assert_eq!(
        ::core::mem::align_of::<stm32_pin_info>(),
        4usize,
        concat!("Alignment of ", stringify!(stm32_pin_info))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<stm32_pin_info>())).gpio_device as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(stm32_pin_info),
            "::",
            stringify!(gpio_device)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<stm32_pin_info>())).timer_device as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(stm32_pin_info),
            "::",
            stringify!(timer_device)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<stm32_pin_info>())).adc_device as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(stm32_pin_info),
            "::",
            stringify!(adc_device)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<stm32_pin_info>())).gpio_bit as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(stm32_pin_info),
            "::",
            stringify!(gpio_bit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<stm32_pin_info>())).timer_channel as *const _ as usize },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(stm32_pin_info),
            "::",
            stringify!(timer_channel)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<stm32_pin_info>())).adc_channel as *const _ as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(stm32_pin_info),
            "::",
            stringify!(adc_channel)
        )
    );
}
pub type boolean = bool;
pub type byte = uint8;
pub const PB11: _bindgen_ty_1 = 0;
pub const PB10: _bindgen_ty_1 = 1;
pub const PB2: _bindgen_ty_1 = 2;
pub const PB0: _bindgen_ty_1 = 3;
pub const PA7: _bindgen_ty_1 = 4;
pub const PA6: _bindgen_ty_1 = 5;
pub const PA5: _bindgen_ty_1 = 6;
pub const PA4: _bindgen_ty_1 = 7;
pub const PA3: _bindgen_ty_1 = 8;
pub const PA2: _bindgen_ty_1 = 9;
pub const PA1: _bindgen_ty_1 = 10;
pub const PA0: _bindgen_ty_1 = 11;
pub const PC15: _bindgen_ty_1 = 12;
pub const PC14: _bindgen_ty_1 = 13;
pub const PC13: _bindgen_ty_1 = 14;
pub const PB7: _bindgen_ty_1 = 15;
pub const PB6: _bindgen_ty_1 = 16;
pub const PB5: _bindgen_ty_1 = 17;
pub const PB4: _bindgen_ty_1 = 18;
pub const PB3: _bindgen_ty_1 = 19;
pub const PA15: _bindgen_ty_1 = 20;
pub const PA14: _bindgen_ty_1 = 21;
pub const PA13: _bindgen_ty_1 = 22;
pub const PA12: _bindgen_ty_1 = 23;
pub const PA11: _bindgen_ty_1 = 24;
pub const PA10: _bindgen_ty_1 = 25;
pub const PA9: _bindgen_ty_1 = 26;
pub const PA8: _bindgen_ty_1 = 27;
pub const PB15: _bindgen_ty_1 = 28;
pub const PB14: _bindgen_ty_1 = 29;
pub const PB13: _bindgen_ty_1 = 30;
pub const PB12: _bindgen_ty_1 = 31;
pub const PB8: _bindgen_ty_1 = 32;
pub const PB1: _bindgen_ty_1 = 33;
pub type _bindgen_ty_1 = u32;
pub const D0: _bindgen_ty_2 = 0;
pub const D1: _bindgen_ty_2 = 1;
pub const D2: _bindgen_ty_2 = 2;
pub const D3: _bindgen_ty_2 = 3;
pub const D4: _bindgen_ty_2 = 4;
pub const D5: _bindgen_ty_2 = 5;
pub const D6: _bindgen_ty_2 = 6;
pub const D7: _bindgen_ty_2 = 7;
pub const D8: _bindgen_ty_2 = 8;
pub const D9: _bindgen_ty_2 = 9;
pub const D10: _bindgen_ty_2 = 10;
pub const D11: _bindgen_ty_2 = 11;
pub const D12: _bindgen_ty_2 = 12;
pub const D13: _bindgen_ty_2 = 13;
pub const D14: _bindgen_ty_2 = 14;
pub const D15: _bindgen_ty_2 = 15;
pub const D16: _bindgen_ty_2 = 16;
pub const D17: _bindgen_ty_2 = 17;
pub const D18: _bindgen_ty_2 = 18;
pub const D19: _bindgen_ty_2 = 19;
pub const D20: _bindgen_ty_2 = 20;
pub const D21: _bindgen_ty_2 = 21;
pub const D22: _bindgen_ty_2 = 22;
pub const D23: _bindgen_ty_2 = 23;
pub const D24: _bindgen_ty_2 = 24;
pub const D25: _bindgen_ty_2 = 25;
pub const D26: _bindgen_ty_2 = 26;
pub const D27: _bindgen_ty_2 = 27;
pub const D28: _bindgen_ty_2 = 28;
pub const D29: _bindgen_ty_2 = 29;
pub const D30: _bindgen_ty_2 = 30;
pub const D31: _bindgen_ty_2 = 31;
pub const D32: _bindgen_ty_2 = 32;
pub const D33: _bindgen_ty_2 = 33;
pub const D34: _bindgen_ty_2 = 34;
pub const D35: _bindgen_ty_2 = 35;
pub const D36: _bindgen_ty_2 = 36;
pub const D37: _bindgen_ty_2 = 37;
pub const D38: _bindgen_ty_2 = 38;
pub const D39: _bindgen_ty_2 = 39;
pub const D40: _bindgen_ty_2 = 40;
pub const D41: _bindgen_ty_2 = 41;
pub const D42: _bindgen_ty_2 = 42;
pub const D43: _bindgen_ty_2 = 43;
pub const D44: _bindgen_ty_2 = 44;
pub const D45: _bindgen_ty_2 = 45;
pub const D46: _bindgen_ty_2 = 46;
pub const D47: _bindgen_ty_2 = 47;
pub const D48: _bindgen_ty_2 = 48;
pub const D49: _bindgen_ty_2 = 49;
pub const D50: _bindgen_ty_2 = 50;
pub const D51: _bindgen_ty_2 = 51;
pub const D52: _bindgen_ty_2 = 52;
pub const D53: _bindgen_ty_2 = 53;
pub const D54: _bindgen_ty_2 = 54;
pub const D55: _bindgen_ty_2 = 55;
pub const D56: _bindgen_ty_2 = 56;
pub const D57: _bindgen_ty_2 = 57;
pub const D58: _bindgen_ty_2 = 58;
pub const D59: _bindgen_ty_2 = 59;
pub const D60: _bindgen_ty_2 = 60;
pub const D61: _bindgen_ty_2 = 61;
pub const D62: _bindgen_ty_2 = 62;
pub const D63: _bindgen_ty_2 = 63;
pub const D64: _bindgen_ty_2 = 64;
pub const D65: _bindgen_ty_2 = 65;
pub const D66: _bindgen_ty_2 = 66;
pub const D67: _bindgen_ty_2 = 67;
pub const D68: _bindgen_ty_2 = 68;
pub const D69: _bindgen_ty_2 = 69;
pub const D70: _bindgen_ty_2 = 70;
pub const D71: _bindgen_ty_2 = 71;
pub const D72: _bindgen_ty_2 = 72;
pub const D73: _bindgen_ty_2 = 73;
pub const D74: _bindgen_ty_2 = 74;
pub const D75: _bindgen_ty_2 = 75;
pub const D76: _bindgen_ty_2 = 76;
pub const D77: _bindgen_ty_2 = 77;
pub const D78: _bindgen_ty_2 = 78;
pub const D79: _bindgen_ty_2 = 79;
pub const D80: _bindgen_ty_2 = 80;
pub const D81: _bindgen_ty_2 = 81;
pub const D82: _bindgen_ty_2 = 82;
pub const D83: _bindgen_ty_2 = 83;
pub const D84: _bindgen_ty_2 = 84;
pub const D85: _bindgen_ty_2 = 85;
pub const D86: _bindgen_ty_2 = 86;
pub const D87: _bindgen_ty_2 = 87;
pub const D88: _bindgen_ty_2 = 88;
pub const D89: _bindgen_ty_2 = 89;
pub const D90: _bindgen_ty_2 = 90;
pub const D91: _bindgen_ty_2 = 91;
pub const D92: _bindgen_ty_2 = 92;
pub const D93: _bindgen_ty_2 = 93;
pub const D94: _bindgen_ty_2 = 94;
pub const D95: _bindgen_ty_2 = 95;
pub const D96: _bindgen_ty_2 = 96;
pub const D97: _bindgen_ty_2 = 97;
pub const D98: _bindgen_ty_2 = 98;
pub const D99: _bindgen_ty_2 = 99;
pub const D100: _bindgen_ty_2 = 100;
pub const D101: _bindgen_ty_2 = 101;
pub const D102: _bindgen_ty_2 = 102;
pub const D103: _bindgen_ty_2 = 103;
pub const D104: _bindgen_ty_2 = 104;
pub const D105: _bindgen_ty_2 = 105;
pub const D106: _bindgen_ty_2 = 106;
pub const D107: _bindgen_ty_2 = 107;
pub const D108: _bindgen_ty_2 = 108;
pub const D109: _bindgen_ty_2 = 109;
pub const D110: _bindgen_ty_2 = 110;
pub const D111: _bindgen_ty_2 = 111;
pub type _bindgen_ty_2 = u32;
extern "C" {
    pub static mut PIN_MAP: [stm32_pin_info; 0usize];
}
extern "C" {
    pub static mut boardPWMPins: [uint8; 0usize];
}
extern "C" {
    pub static mut boardADCPins: [uint8; 0usize];
}
extern "C" {
    pub static mut boardUsedPins: [uint8; 0usize];
}
extern "C" {
    #[doc = " @brief Generic board initialization function."]
    #[doc = ""]
    #[doc = " This function is called before main().  It ensures that the clocks"]
    #[doc = " and peripherals are configured properly for use with wirish, then"]
    #[doc = " calls boardInit()."]
    #[doc = ""]
    #[doc = " @see boardInit()"]
    #[link_name = "\u{1}_Z4initv"]
    pub fn init();
}
extern "C" {
    #[doc = " @brief Board-specific initialization function."]
    #[doc = ""]
    #[doc = " This function is called from init() after all generic board"]
    #[doc = " initialization has been performed.  Each board is required to"]
    #[doc = " define its own."]
    #[doc = ""]
    #[doc = " @see init()"]
    #[link_name = "\u{1}_Z9boardInitv"]
    pub fn boardInit();
}
extern "C" {
    #[doc = " @brief Test if a pin is used for a special purpose on your board."]
    #[doc = " @param pin Pin to test"]
    #[doc = " @return true if the given pin is in boardUsedPins, and false otherwise."]
    #[doc = " @see boardUsedPins"]
    #[link_name = "\u{1}_Z12boardUsesPinh"]
    pub fn boardUsesPin(pin: uint8) -> bool;
}
#[doc = "< Basic digital output: when the pin is HIGH, the"]
#[doc = "voltage is held at +3.3v (Vcc) and when it is LOW, it"]
#[doc = "is pulled down to ground."]
pub const WiringPinMode_OUTPUT: WiringPinMode = 0;
#[doc = "< In open drain mode, the pin indicates"]
#[doc = "\"low\" by accepting current flow to ground"]
#[doc = "and \"high\" by providing increased"]
#[doc = "impedance. An example use would be to"]
#[doc = "connect a pin to a bus line (which is pulled"]
#[doc = "up to a positive voltage by a separate"]
#[doc = "supply through a large resistor). When the"]
#[doc = "pin is high, not much current flows through"]
#[doc = "to ground and the line stays at positive"]
#[doc = "voltage; when the pin is low, the bus"]
#[doc = "\"drains\" to ground with a small amount of"]
#[doc = "current constantly flowing through the large"]
#[doc = "resistor from the external supply. In this"]
#[doc = "mode, no current is ever actually sourced"]
#[doc = "from the pin."]
pub const WiringPinMode_OUTPUT_OPEN_DRAIN: WiringPinMode = 1;
#[doc = "< Basic digital input. The pin voltage is sampled; when"]
#[doc = "it is closer to 3.3v (Vcc) the pin status is high, and"]
#[doc = "when it is closer to 0v (ground) it is low. If no"]
#[doc = "external circuit is pulling the pin voltage to high or"]
#[doc = "low, it will tend to randomly oscillate and be very"]
#[doc = "sensitive to noise (e.g., a breath of air across the pin"]
#[doc = "might cause the state to flip)."]
pub const WiringPinMode_INPUT: WiringPinMode = 2;
#[doc = "< This is a special mode for when the pin will be"]
#[doc = "used for analog (not digital) reads.  Enables ADC"]
#[doc = "conversion to be performed on the voltage at the"]
#[doc = "pin."]
pub const WiringPinMode_INPUT_ANALOG: WiringPinMode = 3;
#[doc = "< The state of the pin in this mode is reported"]
#[doc = "the same way as with INPUT, but the pin voltage"]
#[doc = "is gently \"pulled up\" towards +3.3v. This means"]
#[doc = "the state will be high unless an external device"]
#[doc = "is specifically pulling the pin down to ground,"]
#[doc = "in which case the \"gentle\" pull up will not"]
#[doc = "affect the state of the input."]
pub const WiringPinMode_INPUT_PULLUP: WiringPinMode = 4;
#[doc = "< The state of the pin in this mode is reported"]
#[doc = "the same way as with INPUT, but the pin voltage"]
#[doc = "is gently \"pulled down\" towards 0v. This means"]
#[doc = "the state will be low unless an external device"]
#[doc = "is specifically pulling the pin up to 3.3v, in"]
#[doc = "which case the \"gentle\" pull down will not"]
#[doc = "affect the state of the input."]
pub const WiringPinMode_INPUT_PULLDOWN: WiringPinMode = 5;
#[doc = "< Synonym for INPUT."]
pub const WiringPinMode_INPUT_FLOATING: WiringPinMode = 6;
#[doc = "< This is a special mode for when the pin will be used for"]
#[doc = "PWM output (a special case of digital output)."]
pub const WiringPinMode_PWM: WiringPinMode = 7;
#[doc = "< Like PWM, except that instead of alternating"]
#[doc = "cycles of LOW and HIGH, the voltage on the pin"]
#[doc = "consists of alternating cycles of LOW and"]
#[doc = "floating (disconnected)."]
pub const WiringPinMode_PWM_OPEN_DRAIN: WiringPinMode = 8;
#[doc = " Specifies a GPIO pin behavior."]
#[doc = " @see pinMode()"]
pub type WiringPinMode = u32;
extern "C" {
    #[doc = " Configure behavior of a GPIO pin."]
    #[doc = ""]
    #[doc = " @param pin Number of pin to configure."]
    #[doc = " @param mode Mode corresponding to desired pin behavior."]
    #[doc = " @see WiringPinMode"]
    #[link_name = "\u{1}_Z7pinModeh13WiringPinMode"]
    pub fn pinMode(pin: uint8, mode: WiringPinMode);
}
extern "C" {
    #[doc = " Writes a (digital) value to a pin.  The pin must have its"]
    #[doc = " mode set to OUTPUT or OUTPUT_OPEN_DRAIN."]
    #[doc = ""]
    #[doc = " @param pin Pin to write to."]
    #[doc = " @param value Either LOW (write a 0) or HIGH (write a 1)."]
    #[doc = " @see pinMode()"]
    #[link_name = "\u{1}_Z12digitalWritehh"]
    pub fn digitalWrite(pin: uint8, value: uint8);
}
extern "C" {
    #[doc = " Read a digital value from a pin.  The pin must have its mode set to"]
    #[doc = " one of INPUT, INPUT_PULLUP, and INPUT_PULLDOWN."]
    #[doc = ""]
    #[doc = " @param pin Pin to read from."]
    #[doc = " @return LOW or HIGH."]
    #[doc = " @see pinMode()"]
    #[link_name = "\u{1}_Z11digitalReadh"]
    pub fn digitalRead(pin: uint8) -> uint32;
}
extern "C" {
    #[doc = " Read an analog value from pin.  This function blocks during ADC"]
    #[doc = " conversion, and has 12 bits of resolution.  The pin must have its"]
    #[doc = " mode set to INPUT_ANALOG."]
    #[doc = ""]
    #[doc = " @param pin Pin to read from."]
    #[doc = " @return Converted voltage, in the range 0--4095, (i.e. a 12-bit ADC"]
    #[doc = "         conversion)."]
    #[doc = " @see pinMode()"]
    #[link_name = "\u{1}_Z10analogReadh"]
    pub fn analogRead(pin: uint8) -> uint16;
}
extern "C" {
    #[doc = " Shift out a byte of data, one bit at a time."]
    #[doc = ""]
    #[doc = " This function starts at either the most significant or least"]
    #[doc = " significant bit in a byte value, and shifts out each byte in order"]
    #[doc = " onto a data pin.  After each bit is written to the data pin, a"]
    #[doc = " separate clock pin is pulsed to indicate that the new bit is"]
    #[doc = " available."]
    #[doc = ""]
    #[doc = " @param dataPin  Pin to shift data out on"]
    #[doc = " @param clockPin Pin to pulse after each bit is shifted out"]
    #[doc = " @param bitOrder Either MSBFIRST (big-endian) or LSBFIRST (little-endian)."]
    #[doc = " @param value    Value to shift out"]
    #[link_name = "\u{1}_Z8shiftOuthhhh"]
    pub fn shiftOut(dataPin: uint8, clockPin: uint8, bitOrder: uint8, value: uint8);
}
extern "C" {
    #[link_name = "\u{1}_Z7shiftInjjj"]
    pub fn shiftIn(ulDataPin: uint32, ulClockPin: uint32, ulBitOrder: uint32) -> uint32;
}
extern "C" {
    #[doc = " Set the PWM duty on the given pin."]
    #[doc = ""]
    #[doc = " User code is expected to determine and honor the maximum value"]
    #[doc = " (based on the configured period)."]
    #[doc = ""]
    #[doc = " @param pin PWM output pin"]
    #[doc = " @param duty_cycle Duty cycle to set. (Range is 0 to 65535)"]
    #[link_name = "\u{1}_Z8pwmWriteht"]
    pub fn pwmWrite(pin: uint8, duty_cycle16: uint16);
}
extern "C" {
    #[doc = " Roger Clark. 20140103"]
    #[doc = " Added function to replicate the Arduino PWM functionality or range 0 to 255"]
    #[doc = " User code is expected to determine and honor the maximum value"]
    #[doc = " (based on the configured period)."]
    #[doc = ""]
    #[doc = " @param pin PWM output pin"]
    #[doc = " @param duty_cycle Duty cycle to set. (Range is 0 to 255)"]
    #[link_name = "\u{1}_Z11analogWritehi"]
    pub fn analogWrite(pin: uint8, duty_cycle8: super::c_int);
}
#[doc = "< To trigger an interrupt when the pin transitions LOW"]
#[doc = "to HIGH"]
pub const ExtIntTriggerMode_RISING: ExtIntTriggerMode = 0;
#[doc = "< To trigger an interrupt when the pin transitions"]
#[doc = "HIGH to LOW"]
pub const ExtIntTriggerMode_FALLING: ExtIntTriggerMode = 1;
#[doc = "< To trigger an interrupt when the pin transitions from"]
#[doc = "LOW to HIGH or HIGH to LOW (i.e., when the pin"]
#[doc = "changes)."]
pub const ExtIntTriggerMode_CHANGE: ExtIntTriggerMode = 2;
#[doc = " The kind of transition on an external pin which should trigger an"]
#[doc = " interrupt."]
pub type ExtIntTriggerMode = u32;
extern "C" {
    #[doc = "  @brief Registers an interrupt handler on a pin."]
    #[doc = ""]
    #[doc = "  The interrupt will be triggered on a given transition on the pin,"]
    #[doc = "  as specified by the mode parameter.  The handler runs in interrupt"]
    #[doc = "  context.  The new handler will replace whatever handler is"]
    #[doc = "  currently registered for the pin, if any."]
    #[doc = ""]
    #[doc = "  @param pin Pin number"]
    #[doc = "  @param handler Function to run upon external interrupt trigger."]
    #[doc = "                 The handler should take no arguments, and have void"]
    #[doc = "                 return type."]
    #[doc = "  @param mode Type of transition to trigger on, e.g. falling, rising, etc."]
    #[doc = ""]
    #[doc = "  @sideeffect Registers a handler"]
    #[doc = "  @see detachInterrupt()"]
    #[link_name = "\u{1}_Z15attachInterrupthPFvvE17ExtIntTriggerMode"]
    pub fn attachInterrupt(pin: uint8, handler: voidFuncPtr, mode: ExtIntTriggerMode);
}
extern "C" {
    #[doc = "  @brief Registers an interrupt handler on a pin."]
    #[doc = ""]
    #[doc = "  The interrupt will be triggered on a given transition on the pin,"]
    #[doc = "  as specified by the mode parameter.  The handler runs in interrupt"]
    #[doc = "  context.  The new handler will replace whatever handler is"]
    #[doc = "  currently registered for the pin, if any."]
    #[doc = ""]
    #[doc = "  @param pin Pin number"]
    #[doc = "  @param handler Static class member function to run upon external interrupt"]
    #[doc = "                 trigger. The handler should take 1 argument and return void"]
    #[doc = "  @param arg Argument that the handler will be passed when it's called. One"]
    #[doc = "             use of this is to pass the specific instance of the class that"]
    #[doc = "             will handle the interrupt."]
    #[doc = "  @param mode Type of transition to trigger on, e.g. falling, rising, etc."]
    #[doc = ""]
    #[doc = "  @sideeffect Registers a handler"]
    #[doc = "  @see detachInterrupt()"]
    #[link_name = "\u{1}_Z15attachInterrupthPFvPvES_17ExtIntTriggerMode"]
    pub fn attachInterrupt1(
        pin: uint8,
        handler: voidArgumentFuncPtr,
        arg: *mut super::c_void,
        mode: ExtIntTriggerMode,
    );
}
extern "C" {
    #[doc = " @brief Disable any registered external interrupt."]
    #[doc = " @param pin Maple pin number"]
    #[doc = " @sideeffect unregisters external interrupt handler"]
    #[doc = " @see attachInterrupt()"]
    #[link_name = "\u{1}_Z15detachInterrupth"]
    pub fn detachInterrupt(pin: uint8);
}
extern "C" {
    #[doc = " @brief Disable the JTAG and Serial Wire (SW) debug ports."]
    #[doc = ""]
    #[doc = " You can call this function in order to use the JTAG and SW debug"]
    #[doc = " pins as ordinary GPIOs."]
    #[doc = ""]
    #[doc = " @see enableDebugPorts()"]
    #[link_name = "\u{1}_Z17disableDebugPortsv"]
    pub fn disableDebugPorts();
}
extern "C" {
    #[doc = " @brief Enable the JTAG and Serial Wire (SW) debug ports."]
    #[doc = ""]
    #[doc = " After you call this function, the JTAG and SW debug pins will no"]
    #[doc = " longer be usable as GPIOs."]
    #[doc = ""]
    #[doc = " @see disableDebugPorts()"]
    #[link_name = "\u{1}_Z16enableDebugPortsv"]
    pub fn enableDebugPorts();
}
extern "C" {
    pub fn atan(arg1: f64) -> f64;
}
extern "C" {
    #[doc = " Compute the cosine of an angle, in radians."]
    #[doc = " @param x The radian measure of the angle."]
    #[doc = " @return The cosine of x.  This value will be between -1 and 1."]
    pub fn cos(arg1: f64) -> f64;
}
extern "C" {
    #[doc = " Compute the sine of an angle, in radians."]
    #[doc = " @param x The radian measure of the angle."]
    #[doc = " @return The sine of x.  This value will be between -1 and 1."]
    pub fn sin(arg1: f64) -> f64;
}
extern "C" {
    #[doc = " Compute the tangent of an angle, in radians."]
    #[doc = " @param x The radian measure of the angle."]
    #[doc = " @return The tangent of x.  There are no limits on the return value"]
    #[doc = " of this function."]
    pub fn tan(arg1: f64) -> f64;
}
extern "C" {
    pub fn tanh(arg1: f64) -> f64;
}
extern "C" {
    pub fn frexp(arg1: f64, arg2: *mut super::c_int) -> f64;
}
extern "C" {
    pub fn modf(arg1: f64, arg2: *mut f64) -> f64;
}
extern "C" {
    pub fn ceil(arg1: f64) -> f64;
}
extern "C" {
    pub fn fabs(arg1: f64) -> f64;
}
extern "C" {
    pub fn floor(arg1: f64) -> f64;
}
extern "C" {
    pub fn acos(arg1: f64) -> f64;
}
extern "C" {
    pub fn asin(arg1: f64) -> f64;
}
extern "C" {
    pub fn atan2(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn cosh(arg1: f64) -> f64;
}
extern "C" {
    pub fn sinh(arg1: f64) -> f64;
}
extern "C" {
    pub fn exp(arg1: f64) -> f64;
}
extern "C" {
    pub fn ldexp(arg1: f64, arg2: super::c_int) -> f64;
}
extern "C" {
    pub fn log(arg1: f64) -> f64;
}
extern "C" {
    pub fn log10(arg1: f64) -> f64;
}
extern "C" {
    #[doc = " Compute an exponentiation."]
    #[doc = " @param x the base. This value cannot be zero if y <= 0.  This value"]
    #[doc = " cannot be negative if y is not an integral value."]
    #[doc = " @param y the exponent."]
    #[doc = " @return x raised to the power y."]
    pub fn pow(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    #[doc = " Compute the square root of a number."]
    #[doc = " @param x The number whose square root to find.  This value cannot"]
    #[doc = " be negative."]
    #[doc = " @return The square root of x.  The return value is never negative."]
    pub fn sqrt(arg1: f64) -> f64;
}
extern "C" {
    pub fn fmod(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn finite(arg1: f64) -> super::c_int;
}
extern "C" {
    pub fn finitef(arg1: f32) -> super::c_int;
}
extern "C" {
    pub fn finitel(arg1: f64) -> super::c_int;
}
extern "C" {
    pub fn isinff(arg1: f32) -> super::c_int;
}
extern "C" {
    pub fn isnanf(arg1: f32) -> super::c_int;
}
pub type float_t = f32;
pub type double_t = f64;
extern "C" {
    pub fn __isinff(x: f32) -> super::c_int;
}
extern "C" {
    pub fn __isinfd(x: f64) -> super::c_int;
}
extern "C" {
    pub fn __isnanf(x: f32) -> super::c_int;
}
extern "C" {
    pub fn __isnand(x: f64) -> super::c_int;
}
extern "C" {
    pub fn __fpclassifyf(x: f32) -> super::c_int;
}
extern "C" {
    pub fn __fpclassifyd(x: f64) -> super::c_int;
}
extern "C" {
    pub fn __signbitf(x: f32) -> super::c_int;
}
extern "C" {
    pub fn __signbitd(x: f64) -> super::c_int;
}
extern "C" {
    pub fn infinity() -> f64;
}
extern "C" {
    pub fn nan(arg1: *const super::c_char) -> f64;
}
extern "C" {
    pub fn copysign(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn logb(arg1: f64) -> f64;
}
extern "C" {
    pub fn ilogb(arg1: f64) -> super::c_int;
}
extern "C" {
    pub fn asinh(arg1: f64) -> f64;
}
extern "C" {
    pub fn cbrt(arg1: f64) -> f64;
}
extern "C" {
    pub fn nextafter(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn rint(arg1: f64) -> f64;
}
extern "C" {
    pub fn scalbn(arg1: f64, arg2: super::c_int) -> f64;
}
extern "C" {
    pub fn exp2(arg1: f64) -> f64;
}
extern "C" {
    pub fn scalbln(arg1: f64, arg2: super::c_long) -> f64;
}
extern "C" {
    pub fn tgamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn nearbyint(arg1: f64) -> f64;
}
extern "C" {
    pub fn lrint(arg1: f64) -> super::c_long;
}
extern "C" {
    pub fn llrint(arg1: f64) -> super::c_longlong;
}
extern "C" {
    pub fn round(arg1: f64) -> f64;
}
extern "C" {
    pub fn lround(arg1: f64) -> super::c_long;
}
extern "C" {
    pub fn llround(arg1: f64) -> super::c_longlong;
}
extern "C" {
    pub fn trunc(arg1: f64) -> f64;
}
extern "C" {
    pub fn remquo(arg1: f64, arg2: f64, arg3: *mut super::c_int) -> f64;
}
extern "C" {
    pub fn fdim(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn fmax(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn fmin(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn fma(arg1: f64, arg2: f64, arg3: f64) -> f64;
}
extern "C" {
    pub fn log1p(arg1: f64) -> f64;
}
extern "C" {
    pub fn expm1(arg1: f64) -> f64;
}
extern "C" {
    pub fn acosh(arg1: f64) -> f64;
}
extern "C" {
    pub fn atanh(arg1: f64) -> f64;
}
extern "C" {
    pub fn remainder(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn gamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn lgamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn erf(arg1: f64) -> f64;
}
extern "C" {
    pub fn erfc(arg1: f64) -> f64;
}
extern "C" {
    pub fn log2(arg1: f64) -> f64;
}
extern "C" {
    pub fn hypot(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn atanf(arg1: f32) -> f32;
}
extern "C" {
    pub fn cosf(arg1: f32) -> f32;
}
extern "C" {
    pub fn sinf(arg1: f32) -> f32;
}
extern "C" {
    pub fn tanf(arg1: f32) -> f32;
}
extern "C" {
    pub fn tanhf(arg1: f32) -> f32;
}
extern "C" {
    pub fn frexpf(arg1: f32, arg2: *mut super::c_int) -> f32;
}
extern "C" {
    pub fn modff(arg1: f32, arg2: *mut f32) -> f32;
}
extern "C" {
    pub fn ceilf(arg1: f32) -> f32;
}
extern "C" {
    pub fn fabsf(arg1: f32) -> f32;
}
extern "C" {
    pub fn floorf(arg1: f32) -> f32;
}
extern "C" {
    pub fn acosf(arg1: f32) -> f32;
}
extern "C" {
    pub fn asinf(arg1: f32) -> f32;
}
extern "C" {
    pub fn atan2f(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    pub fn coshf(arg1: f32) -> f32;
}
extern "C" {
    pub fn sinhf(arg1: f32) -> f32;
}
extern "C" {
    pub fn expf(arg1: f32) -> f32;
}
extern "C" {
    pub fn ldexpf(arg1: f32, arg2: super::c_int) -> f32;
}
extern "C" {
    pub fn logf(arg1: f32) -> f32;
}
extern "C" {
    pub fn log10f(arg1: f32) -> f32;
}
extern "C" {
    pub fn powf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    pub fn sqrtf(arg1: f32) -> f32;
}
extern "C" {
    pub fn fmodf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    pub fn exp2f(arg1: f32) -> f32;
}
extern "C" {
    pub fn scalblnf(arg1: f32, arg2: super::c_long) -> f32;
}
extern "C" {
    pub fn tgammaf(arg1: f32) -> f32;
}
extern "C" {
    pub fn nearbyintf(arg1: f32) -> f32;
}
extern "C" {
    pub fn lrintf(arg1: f32) -> super::c_long;
}
extern "C" {
    pub fn llrintf(arg1: f32) -> super::c_longlong;
}
extern "C" {
    pub fn roundf(arg1: f32) -> f32;
}
extern "C" {
    pub fn lroundf(arg1: f32) -> super::c_long;
}
extern "C" {
    pub fn llroundf(arg1: f32) -> super::c_longlong;
}
extern "C" {
    pub fn truncf(arg1: f32) -> f32;
}
extern "C" {
    pub fn remquof(arg1: f32, arg2: f32, arg3: *mut super::c_int) -> f32;
}
extern "C" {
    pub fn fdimf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    pub fn fmaxf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    pub fn fminf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    pub fn fmaf(arg1: f32, arg2: f32, arg3: f32) -> f32;
}
extern "C" {
    pub fn infinityf() -> f32;
}
extern "C" {
    pub fn nanf(arg1: *const super::c_char) -> f32;
}
extern "C" {
    pub fn copysignf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    pub fn logbf(arg1: f32) -> f32;
}
extern "C" {
    pub fn ilogbf(arg1: f32) -> super::c_int;
}
extern "C" {
    pub fn asinhf(arg1: f32) -> f32;
}
extern "C" {
    pub fn cbrtf(arg1: f32) -> f32;
}
extern "C" {
    pub fn nextafterf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    pub fn rintf(arg1: f32) -> f32;
}
extern "C" {
    pub fn scalbnf(arg1: f32, arg2: super::c_int) -> f32;
}
extern "C" {
    pub fn log1pf(arg1: f32) -> f32;
}
extern "C" {
    pub fn expm1f(arg1: f32) -> f32;
}
extern "C" {
    pub fn acoshf(arg1: f32) -> f32;
}
extern "C" {
    pub fn atanhf(arg1: f32) -> f32;
}
extern "C" {
    pub fn remainderf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    pub fn gammaf(arg1: f32) -> f32;
}
extern "C" {
    pub fn lgammaf(arg1: f32) -> f32;
}
extern "C" {
    pub fn erff(arg1: f32) -> f32;
}
extern "C" {
    pub fn erfcf(arg1: f32) -> f32;
}
extern "C" {
    pub fn log2f(arg1: f32) -> f32;
}
extern "C" {
    pub fn hypotf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    pub fn atanl(arg1: f64) -> f64;
}
extern "C" {
    pub fn cosl(arg1: f64) -> f64;
}
extern "C" {
    pub fn sinl(arg1: f64) -> f64;
}
extern "C" {
    pub fn tanl(arg1: f64) -> f64;
}
extern "C" {
    pub fn tanhl(arg1: f64) -> f64;
}
extern "C" {
    pub fn frexpl(arg1: f64, arg2: *mut super::c_int) -> f64;
}
extern "C" {
    pub fn modfl(arg1: f64, arg2: *mut f64) -> f64;
}
extern "C" {
    pub fn ceill(arg1: f64) -> f64;
}
extern "C" {
    pub fn fabsl(arg1: f64) -> f64;
}
extern "C" {
    pub fn floorl(arg1: f64) -> f64;
}
extern "C" {
    pub fn log1pl(arg1: f64) -> f64;
}
extern "C" {
    pub fn expm1l(arg1: f64) -> f64;
}
extern "C" {
    pub fn acosl(arg1: f64) -> f64;
}
extern "C" {
    pub fn asinl(arg1: f64) -> f64;
}
extern "C" {
    pub fn atan2l(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn coshl(arg1: f64) -> f64;
}
extern "C" {
    pub fn sinhl(arg1: f64) -> f64;
}
extern "C" {
    pub fn expl(arg1: f64) -> f64;
}
extern "C" {
    pub fn ldexpl(arg1: f64, arg2: super::c_int) -> f64;
}
extern "C" {
    pub fn logl(arg1: f64) -> f64;
}
extern "C" {
    pub fn log10l(arg1: f64) -> f64;
}
extern "C" {
    pub fn powl(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn sqrtl(arg1: f64) -> f64;
}
extern "C" {
    pub fn fmodl(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn hypotl(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn copysignl(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn nanl(arg1: *const super::c_char) -> f64;
}
extern "C" {
    pub fn ilogbl(arg1: f64) -> super::c_int;
}
extern "C" {
    pub fn asinhl(arg1: f64) -> f64;
}
extern "C" {
    pub fn cbrtl(arg1: f64) -> f64;
}
extern "C" {
    pub fn nextafterl(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn nexttowardf(arg1: f32, arg2: f64) -> f32;
}
extern "C" {
    pub fn nexttoward(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn nexttowardl(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn logbl(arg1: f64) -> f64;
}
extern "C" {
    pub fn log2l(arg1: f64) -> f64;
}
extern "C" {
    pub fn rintl(arg1: f64) -> f64;
}
extern "C" {
    pub fn scalbnl(arg1: f64, arg2: super::c_int) -> f64;
}
extern "C" {
    pub fn exp2l(arg1: f64) -> f64;
}
extern "C" {
    pub fn scalblnl(arg1: f64, arg2: super::c_long) -> f64;
}
extern "C" {
    pub fn tgammal(arg1: f64) -> f64;
}
extern "C" {
    pub fn nearbyintl(arg1: f64) -> f64;
}
extern "C" {
    pub fn lrintl(arg1: f64) -> super::c_long;
}
extern "C" {
    pub fn llrintl(arg1: f64) -> super::c_longlong;
}
extern "C" {
    pub fn roundl(arg1: f64) -> f64;
}
extern "C" {
    pub fn lroundl(arg1: f64) -> super::c_long;
}
extern "C" {
    pub fn llroundl(arg1: f64) -> super::c_longlong;
}
extern "C" {
    pub fn truncl(arg1: f64) -> f64;
}
extern "C" {
    pub fn remquol(arg1: f64, arg2: f64, arg3: *mut super::c_int) -> f64;
}
extern "C" {
    pub fn fdiml(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn fmaxl(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn fminl(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn fmal(arg1: f64, arg2: f64, arg3: f64) -> f64;
}
extern "C" {
    pub fn acoshl(arg1: f64) -> f64;
}
extern "C" {
    pub fn atanhl(arg1: f64) -> f64;
}
extern "C" {
    pub fn remainderl(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn lgammal(arg1: f64) -> f64;
}
extern "C" {
    pub fn erfl(arg1: f64) -> f64;
}
extern "C" {
    pub fn erfcl(arg1: f64) -> f64;
}
extern "C" {
    pub fn drem(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn dremf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    pub fn gamma_r(arg1: f64, arg2: *mut super::c_int) -> f64;
}
extern "C" {
    pub fn lgamma_r(arg1: f64, arg2: *mut super::c_int) -> f64;
}
extern "C" {
    pub fn gammaf_r(arg1: f32, arg2: *mut super::c_int) -> f32;
}
extern "C" {
    pub fn lgammaf_r(arg1: f32, arg2: *mut super::c_int) -> f32;
}
extern "C" {
    pub fn y0(arg1: f64) -> f64;
}
extern "C" {
    pub fn y1(arg1: f64) -> f64;
}
extern "C" {
    pub fn yn(arg1: super::c_int, arg2: f64) -> f64;
}
extern "C" {
    pub fn j0(arg1: f64) -> f64;
}
extern "C" {
    pub fn j1(arg1: f64) -> f64;
}
extern "C" {
    pub fn jn(arg1: super::c_int, arg2: f64) -> f64;
}
extern "C" {
    pub fn y0f(arg1: f32) -> f32;
}
extern "C" {
    pub fn y1f(arg1: f32) -> f32;
}
extern "C" {
    pub fn ynf(arg1: super::c_int, arg2: f32) -> f32;
}
extern "C" {
    pub fn j0f(arg1: f32) -> f32;
}
extern "C" {
    pub fn j1f(arg1: f32) -> f32;
}
extern "C" {
    pub fn jnf(arg1: super::c_int, arg2: f32) -> f32;
}
extern "C" {
    pub fn __signgam() -> *mut super::c_int;
}
#[repr(C)]
pub struct __exception {
    pub type_: super::c_int,
    pub name: *mut super::c_char,
    pub arg1: f64,
    pub arg2: f64,
    pub retval: f64,
    pub err: super::c_int,
}
#[test]
fn bindgen_test_layout___exception() {
    assert_eq!(
        ::core::mem::size_of::<__exception>(),
        40usize,
        concat!("Size of: ", stringify!(__exception))
    );
    assert_eq!(
        ::core::mem::align_of::<__exception>(),
        8usize,
        concat!("Alignment of ", stringify!(__exception))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__exception>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__exception),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__exception>())).name as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__exception),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__exception>())).arg1 as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__exception),
            "::",
            stringify!(arg1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__exception>())).arg2 as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__exception),
            "::",
            stringify!(arg2)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__exception>())).retval as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__exception),
            "::",
            stringify!(retval)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__exception>())).err as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__exception),
            "::",
            stringify!(err)
        )
    );
}
extern "C" {
    pub fn matherr(e: *mut __exception) -> super::c_int;
}
pub const __fdlibm_version___fdlibm_ieee: __fdlibm_version = -1;
pub const __fdlibm_version___fdlibm_svid: __fdlibm_version = 0;
pub const __fdlibm_version___fdlibm_xopen: __fdlibm_version = 1;
pub const __fdlibm_version___fdlibm_posix: __fdlibm_version = 2;
pub type __fdlibm_version = i32;
extern "C" {
    pub static mut __fdlib_version: __fdlibm_version;
}
extern "C" {
    #[doc = " @brief Initialize the pseudo-random number generator."]
    #[doc = " @param seed the number used to initialize the seed; cannot be zero."]
    #[link_name = "\u{1}_Z10randomSeedj"]
    pub fn randomSeed(seed: super::c_uint);
}
extern "C" {
    #[link_name = "\u{1}_Z8makeWordt"]
    pub fn makeWord(w: u16) -> u16;
}
extern "C" {
    #[link_name = "\u{1}_Z8makeWordhh"]
    pub fn makeWord1(h: u8, l: u8) -> u16;
}
#[doc = " SysTick register map type"]
#[repr(C)]
pub struct systick_reg_map {
    #[doc = "< Control and status register"]
    pub CSR: uint32,
    #[doc = "< Reload value register"]
    pub RVR: uint32,
    #[doc = "< Current value register (\"count\")"]
    pub CNT: uint32,
    #[doc = "< Calibration value register"]
    pub CVR: uint32,
}
#[test]
fn bindgen_test_layout_systick_reg_map() {
    assert_eq!(
        ::core::mem::size_of::<systick_reg_map>(),
        16usize,
        concat!("Size of: ", stringify!(systick_reg_map))
    );
    assert_eq!(
        ::core::mem::align_of::<systick_reg_map>(),
        4usize,
        concat!("Alignment of ", stringify!(systick_reg_map))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<systick_reg_map>())).CSR as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(systick_reg_map),
            "::",
            stringify!(CSR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<systick_reg_map>())).RVR as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(systick_reg_map),
            "::",
            stringify!(RVR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<systick_reg_map>())).CNT as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(systick_reg_map),
            "::",
            stringify!(CNT)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<systick_reg_map>())).CVR as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(systick_reg_map),
            "::",
            stringify!(CVR)
        )
    );
}
extern "C" {
    pub static mut systick_uptime_millis: uint32;
}
extern "C" {
    pub fn systick_init(reload_val: uint32);
}
extern "C" {
    pub fn systick_disable();
}
extern "C" {
    pub fn systick_enable();
}
extern "C" {
    #[doc = " @brief prototype for systick_attach_callback"]
    #[doc = ""]
    pub fn systick_attach_callback(callback: ::core::option::Option<unsafe extern "C" fn()>);
}
extern "C" {
    #[doc = " Delay for at least the given number of milliseconds."]
    #[doc = ""]
    #[doc = " Interrupts, etc. may cause the actual number of milliseconds to"]
    #[doc = " exceed ms.  However, this function will return no less than ms"]
    #[doc = " milliseconds from the time it is called."]
    #[doc = ""]
    #[doc = " @param ms the number of milliseconds to delay."]
    #[doc = " @see delayMicroseconds()"]
    #[link_name = "\u{1}_Z5delaym"]
    pub fn delay(ms: super::c_ulong);
}
extern "C" {
    #[doc = " Delay for at least the given number of microseconds."]
    #[doc = ""]
    #[doc = " Interrupts, etc. may cause the actual number of microseconds to"]
    #[doc = " exceed us.  However, this function will return no less than us"]
    #[doc = " microseconds from the time it is called."]
    #[doc = ""]
    #[doc = " @param us the number of microseconds to delay."]
    #[doc = " @see delay()"]
    #[link_name = "\u{1}_Z17delayMicrosecondsj"]
    pub fn delayMicroseconds(us: uint32);
}
pub const BitOrder_LSBFIRST: BitOrder = 0;
pub const BitOrder_MSBFIRST: BitOrder = 1;
pub type BitOrder = u32;
extern "C" {
    #[link_name = "\u{1}_Z7pulseInjjj"]
    pub fn pulseIn(ulPin: u32, ulState: u32, ulTimeout: u32) -> u32;
}
#[repr(C)]
pub struct Printable__bindgen_vtable(super::c_void);
#[doc = " The Printable class provides a way for new classes to allow themselves to be printed."]
#[doc = "By deriving from Printable and implementing the printTo method, it will then be possible"]
#[doc = "for users to print out instances of this class by passing them into the usual"]
#[doc = "Print::print and Print::println methods."]
#[repr(C)]
pub struct Printable {
    pub vtable_: *const Printable__bindgen_vtable,
}
#[test]
fn bindgen_test_layout_Printable() {
    assert_eq!(
        ::core::mem::size_of::<Printable>(),
        4usize,
        concat!("Size of: ", stringify!(Printable))
    );
    assert_eq!(
        ::core::mem::align_of::<Printable>(),
        4usize,
        concat!("Alignment of ", stringify!(Printable))
    );
}
pub const BIN: _bindgen_ty_3 = 2;
pub const OCT: _bindgen_ty_3 = 8;
pub const DEC: _bindgen_ty_3 = 10;
pub const HEX: _bindgen_ty_3 = 16;
pub type _bindgen_ty_3 = u32;
#[repr(C)]
pub struct Print__bindgen_vtable(super::c_void);
#[repr(C)]
pub struct Print {
    pub vtable_: *const Print__bindgen_vtable,
    pub write_error: super::c_int,
}
#[test]
fn bindgen_test_layout_Print() {
    assert_eq!(
        ::core::mem::size_of::<Print>(),
        8usize,
        concat!("Size of: ", stringify!(Print))
    );
    assert_eq!(
        ::core::mem::align_of::<Print>(),
        4usize,
        concat!("Alignment of ", stringify!(Print))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Print>())).write_error as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(Print),
            "::",
            stringify!(write_error)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN5Print5printERK6String"]
    pub fn Print_print(this: *mut Print, arg1: *const String) -> size_t;
}
extern "C" {
    #[link_name = "\u{1}_ZN5Print5printEc"]
    pub fn Print_print1(this: *mut Print, arg1: super::c_char) -> size_t;
}
extern "C" {
    #[link_name = "\u{1}_ZN5Print5printEPKc"]
    pub fn Print_print2(this: *mut Print, arg1: *const super::c_char) -> size_t;
}
extern "C" {
    #[link_name = "\u{1}_ZN5Print5printEhi"]
    pub fn Print_print3(this: *mut Print, arg1: uint8, arg2: super::c_int) -> size_t;
}
extern "C" {
    #[link_name = "\u{1}_ZN5Print5printEii"]
    pub fn Print_print4(this: *mut Print, arg1: super::c_int, arg2: super::c_int) -> size_t;
}
extern "C" {
    #[link_name = "\u{1}_ZN5Print5printEji"]
    pub fn Print_print5(this: *mut Print, arg1: super::c_uint, arg2: super::c_int) -> size_t;
}
extern "C" {
    #[link_name = "\u{1}_ZN5Print5printEli"]
    pub fn Print_print6(this: *mut Print, arg1: super::c_long, arg2: super::c_int) -> size_t;
}
extern "C" {
    #[link_name = "\u{1}_ZN5Print5printEmi"]
    pub fn Print_print7(this: *mut Print, arg1: super::c_ulong, arg2: super::c_int) -> size_t;
}
extern "C" {
    #[link_name = "\u{1}_ZN5Print5printExi"]
    pub fn Print_print8(this: *mut Print, arg1: super::c_longlong, arg2: super::c_int) -> size_t;
}
extern "C" {
    #[link_name = "\u{1}_ZN5Print5printEyi"]
    pub fn Print_print9(this: *mut Print, arg1: super::c_ulonglong, arg2: super::c_int) -> size_t;
}
extern "C" {
    #[link_name = "\u{1}_ZN5Print5printEdi"]
    pub fn Print_print10(this: *mut Print, arg1: f64, arg2: super::c_int) -> size_t;
}
extern "C" {
    #[link_name = "\u{1}_ZN5Print5printEPK19__FlashStringHelper"]
    pub fn Print_print11(this: *mut Print, arg1: *const __FlashStringHelper) -> size_t;
}
extern "C" {
    #[link_name = "\u{1}_ZN5Print5printERK9Printable"]
    pub fn Print_print12(this: *mut Print, arg1: *const Printable) -> size_t;
}
extern "C" {
    #[link_name = "\u{1}_ZN5Print7printlnEv"]
    pub fn Print_println(this: *mut Print) -> size_t;
}
extern "C" {
    #[link_name = "\u{1}_ZN5Print7printlnERK6String"]
    pub fn Print_println1(this: *mut Print, s: *const String) -> size_t;
}
extern "C" {
    #[link_name = "\u{1}_ZN5Print7printlnEc"]
    pub fn Print_println2(this: *mut Print, arg1: super::c_char) -> size_t;
}
extern "C" {
    #[link_name = "\u{1}_ZN5Print7printlnEPKc"]
    pub fn Print_println3(this: *mut Print, arg1: *const super::c_char) -> size_t;
}
extern "C" {
    #[link_name = "\u{1}_ZN5Print7printlnEhi"]
    pub fn Print_println4(this: *mut Print, arg1: uint8, arg2: super::c_int) -> size_t;
}
extern "C" {
    #[link_name = "\u{1}_ZN5Print7printlnEii"]
    pub fn Print_println5(this: *mut Print, arg1: super::c_int, arg2: super::c_int) -> size_t;
}
extern "C" {
    #[link_name = "\u{1}_ZN5Print7printlnEji"]
    pub fn Print_println6(this: *mut Print, arg1: super::c_uint, arg2: super::c_int) -> size_t;
}
extern "C" {
    #[link_name = "\u{1}_ZN5Print7printlnEli"]
    pub fn Print_println7(this: *mut Print, arg1: super::c_long, arg2: super::c_int) -> size_t;
}
extern "C" {
    #[link_name = "\u{1}_ZN5Print7printlnEmi"]
    pub fn Print_println8(this: *mut Print, arg1: super::c_ulong, arg2: super::c_int) -> size_t;
}
extern "C" {
    #[link_name = "\u{1}_ZN5Print7printlnExi"]
    pub fn Print_println9(this: *mut Print, arg1: super::c_longlong, arg2: super::c_int) -> size_t;
}
extern "C" {
    #[link_name = "\u{1}_ZN5Print7printlnEyi"]
    pub fn Print_println10(
        this: *mut Print,
        arg1: super::c_ulonglong,
        arg2: super::c_int,
    ) -> size_t;
}
extern "C" {
    #[link_name = "\u{1}_ZN5Print7printlnEdi"]
    pub fn Print_println11(this: *mut Print, arg1: f64, arg2: super::c_int) -> size_t;
}
extern "C" {
    #[link_name = "\u{1}_ZN5Print7printlnEPK19__FlashStringHelper"]
    pub fn Print_println12(this: *mut Print, arg1: *const __FlashStringHelper) -> size_t;
}
extern "C" {
    #[link_name = "\u{1}_ZN5Print7printlnERK9Printable"]
    pub fn Print_println13(this: *mut Print, arg1: *const Printable) -> size_t;
}
impl Print {
    #[inline]
    pub unsafe fn print(&mut self, arg1: *const String) -> size_t {
        Print_print(self, arg1)
    }
    #[inline]
    pub unsafe fn print1(&mut self, arg1: super::c_char) -> size_t {
        Print_print1(self, arg1)
    }
    #[inline]
    pub unsafe fn print2(&mut self, arg1: *const super::c_char) -> size_t {
        Print_print2(self, arg1)
    }
    #[inline]
    pub unsafe fn print3(&mut self, arg1: uint8, arg2: super::c_int) -> size_t {
        Print_print3(self, arg1, arg2)
    }
    #[inline]
    pub unsafe fn print4(&mut self, arg1: super::c_int, arg2: super::c_int) -> size_t {
        Print_print4(self, arg1, arg2)
    }
    #[inline]
    pub unsafe fn print5(&mut self, arg1: super::c_uint, arg2: super::c_int) -> size_t {
        Print_print5(self, arg1, arg2)
    }
    #[inline]
    pub unsafe fn print6(&mut self, arg1: super::c_long, arg2: super::c_int) -> size_t {
        Print_print6(self, arg1, arg2)
    }
    #[inline]
    pub unsafe fn print7(&mut self, arg1: super::c_ulong, arg2: super::c_int) -> size_t {
        Print_print7(self, arg1, arg2)
    }
    #[inline]
    pub unsafe fn print8(&mut self, arg1: super::c_longlong, arg2: super::c_int) -> size_t {
        Print_print8(self, arg1, arg2)
    }
    #[inline]
    pub unsafe fn print9(&mut self, arg1: super::c_ulonglong, arg2: super::c_int) -> size_t {
        Print_print9(self, arg1, arg2)
    }
    #[inline]
    pub unsafe fn print10(&mut self, arg1: f64, arg2: super::c_int) -> size_t {
        Print_print10(self, arg1, arg2)
    }
    #[inline]
    pub unsafe fn print11(&mut self, arg1: *const __FlashStringHelper) -> size_t {
        Print_print11(self, arg1)
    }
    #[inline]
    pub unsafe fn print12(&mut self, arg1: *const Printable) -> size_t {
        Print_print12(self, arg1)
    }
    #[inline]
    pub unsafe fn println(&mut self) -> size_t {
        Print_println(self)
    }
    #[inline]
    pub unsafe fn println1(&mut self, s: *const String) -> size_t {
        Print_println1(self, s)
    }
    #[inline]
    pub unsafe fn println2(&mut self, arg1: super::c_char) -> size_t {
        Print_println2(self, arg1)
    }
    #[inline]
    pub unsafe fn println3(&mut self, arg1: *const super::c_char) -> size_t {
        Print_println3(self, arg1)
    }
    #[inline]
    pub unsafe fn println4(&mut self, arg1: uint8, arg2: super::c_int) -> size_t {
        Print_println4(self, arg1, arg2)
    }
    #[inline]
    pub unsafe fn println5(&mut self, arg1: super::c_int, arg2: super::c_int) -> size_t {
        Print_println5(self, arg1, arg2)
    }
    #[inline]
    pub unsafe fn println6(&mut self, arg1: super::c_uint, arg2: super::c_int) -> size_t {
        Print_println6(self, arg1, arg2)
    }
    #[inline]
    pub unsafe fn println7(&mut self, arg1: super::c_long, arg2: super::c_int) -> size_t {
        Print_println7(self, arg1, arg2)
    }
    #[inline]
    pub unsafe fn println8(&mut self, arg1: super::c_ulong, arg2: super::c_int) -> size_t {
        Print_println8(self, arg1, arg2)
    }
    #[inline]
    pub unsafe fn println9(&mut self, arg1: super::c_longlong, arg2: super::c_int) -> size_t {
        Print_println9(self, arg1, arg2)
    }
    #[inline]
    pub unsafe fn println10(&mut self, arg1: super::c_ulonglong, arg2: super::c_int) -> size_t {
        Print_println10(self, arg1, arg2)
    }
    #[inline]
    pub unsafe fn println11(&mut self, arg1: f64, arg2: super::c_int) -> size_t {
        Print_println11(self, arg1, arg2)
    }
    #[inline]
    pub unsafe fn println12(&mut self, arg1: *const __FlashStringHelper) -> size_t {
        Print_println12(self, arg1)
    }
    #[inline]
    pub unsafe fn println13(&mut self, arg1: *const Printable) -> size_t {
        Print_println13(self, arg1)
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN5Print5writeEPKc"]
    pub fn Print_write1(this: *mut super::c_void, str: *const super::c_char) -> size_t;
}
extern "C" {
    #[link_name = "\u{1}_ZN5Print5writeEPKvj"]
    pub fn Print_write2(this: *mut super::c_void, buf: *const super::c_void, len: uint32)
        -> size_t;
}
#[repr(C)]
pub struct Stream {
    pub _base: Print,
    pub _timeout: super::c_ulong,
    pub _startMillis: super::c_ulong,
}
#[repr(C)]
pub struct Stream_MultiTarget {
    pub str: *const super::c_char,
    pub len: size_t,
    pub index: size_t,
}
#[test]
fn bindgen_test_layout_Stream_MultiTarget() {
    assert_eq!(
        ::core::mem::size_of::<Stream_MultiTarget>(),
        12usize,
        concat!("Size of: ", stringify!(Stream_MultiTarget))
    );
    assert_eq!(
        ::core::mem::align_of::<Stream_MultiTarget>(),
        4usize,
        concat!("Alignment of ", stringify!(Stream_MultiTarget))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Stream_MultiTarget>())).str as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Stream_MultiTarget),
            "::",
            stringify!(str)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Stream_MultiTarget>())).len as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(Stream_MultiTarget),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Stream_MultiTarget>())).index as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Stream_MultiTarget),
            "::",
            stringify!(index)
        )
    );
}
#[test]
fn bindgen_test_layout_Stream() {
    assert_eq!(
        ::core::mem::size_of::<Stream>(),
        16usize,
        concat!("Size of: ", stringify!(Stream))
    );
    assert_eq!(
        ::core::mem::align_of::<Stream>(),
        4usize,
        concat!("Alignment of ", stringify!(Stream))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Stream>()))._timeout as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Stream),
            "::",
            stringify!(_timeout)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Stream>()))._startMillis as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(Stream),
            "::",
            stringify!(_startMillis)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN6Stream9timedReadEv"]
    pub fn Stream_timedRead(this: *mut Stream) -> super::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZN6Stream9timedPeekEv"]
    pub fn Stream_timedPeek(this: *mut Stream) -> super::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZN6Stream13peekNextDigitEv"]
    pub fn Stream_peekNextDigit(this: *mut Stream) -> super::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZN6Stream10setTimeoutEm"]
    pub fn Stream_setTimeout(this: *mut Stream, timeout: super::c_ulong);
}
extern "C" {
    #[link_name = "\u{1}_ZN6Stream4findEPc"]
    pub fn Stream_find(this: *mut Stream, target: *mut super::c_char) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN6Stream4findEPcj"]
    pub fn Stream_find1(this: *mut Stream, target: *mut super::c_char, length: size_t) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN6Stream9findUntilEPcS0_"]
    pub fn Stream_findUntil(
        this: *mut Stream,
        target: *mut super::c_char,
        terminator: *mut super::c_char,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN6Stream9findUntilEPcjS0_j"]
    pub fn Stream_findUntil1(
        this: *mut Stream,
        target: *mut super::c_char,
        targetLen: size_t,
        terminate: *mut super::c_char,
        termLen: size_t,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN6Stream8parseIntEv"]
    pub fn Stream_parseInt(this: *mut Stream) -> super::c_long;
}
extern "C" {
    #[link_name = "\u{1}_ZN6Stream10parseFloatEv"]
    pub fn Stream_parseFloat(this: *mut Stream) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_ZN6Stream9readBytesEPcj"]
    pub fn Stream_readBytes(
        this: *mut Stream,
        buffer: *mut super::c_char,
        length: size_t,
    ) -> size_t;
}
extern "C" {
    #[link_name = "\u{1}_ZN6Stream14readBytesUntilEcPcj"]
    pub fn Stream_readBytesUntil(
        this: *mut Stream,
        terminator: super::c_char,
        buffer: *mut super::c_char,
        length: size_t,
    ) -> size_t;
}
extern "C" {
    #[link_name = "\u{1}_ZN6Stream10readStringEv"]
    pub fn Stream_readString(this: *mut Stream) -> String;
}
extern "C" {
    #[link_name = "\u{1}_ZN6Stream15readStringUntilEc"]
    pub fn Stream_readStringUntil(this: *mut Stream, terminator: super::c_char) -> String;
}
extern "C" {
    #[link_name = "\u{1}_ZN6Stream8parseIntEc"]
    pub fn Stream_parseInt1(this: *mut Stream, skipChar: super::c_char) -> super::c_long;
}
extern "C" {
    #[link_name = "\u{1}_ZN6Stream10parseFloatEc"]
    pub fn Stream_parseFloat1(this: *mut Stream, skipChar: super::c_char) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_ZN6Stream9findMultiEPNS_11MultiTargetEi"]
    pub fn Stream_findMulti(
        this: *mut Stream,
        targets: *mut Stream_MultiTarget,
        tCount: super::c_int,
    ) -> super::c_int;
}
impl Stream {
    #[inline]
    pub unsafe fn timedRead(&mut self) -> super::c_int {
        Stream_timedRead(self)
    }
    #[inline]
    pub unsafe fn timedPeek(&mut self) -> super::c_int {
        Stream_timedPeek(self)
    }
    #[inline]
    pub unsafe fn peekNextDigit(&mut self) -> super::c_int {
        Stream_peekNextDigit(self)
    }
    #[inline]
    pub unsafe fn setTimeout(&mut self, timeout: super::c_ulong) {
        Stream_setTimeout(self, timeout)
    }
    #[inline]
    pub unsafe fn find(&mut self, target: *mut super::c_char) -> bool {
        Stream_find(self, target)
    }
    #[inline]
    pub unsafe fn find1(&mut self, target: *mut super::c_char, length: size_t) -> bool {
        Stream_find1(self, target, length)
    }
    #[inline]
    pub unsafe fn findUntil(
        &mut self,
        target: *mut super::c_char,
        terminator: *mut super::c_char,
    ) -> bool {
        Stream_findUntil(self, target, terminator)
    }
    #[inline]
    pub unsafe fn findUntil1(
        &mut self,
        target: *mut super::c_char,
        targetLen: size_t,
        terminate: *mut super::c_char,
        termLen: size_t,
    ) -> bool {
        Stream_findUntil1(self, target, targetLen, terminate, termLen)
    }
    #[inline]
    pub unsafe fn parseInt(&mut self) -> super::c_long {
        Stream_parseInt(self)
    }
    #[inline]
    pub unsafe fn parseFloat(&mut self) -> f32 {
        Stream_parseFloat(self)
    }
    #[inline]
    pub unsafe fn readBytes(&mut self, buffer: *mut super::c_char, length: size_t) -> size_t {
        Stream_readBytes(self, buffer, length)
    }
    #[inline]
    pub unsafe fn readBytesUntil(
        &mut self,
        terminator: super::c_char,
        buffer: *mut super::c_char,
        length: size_t,
    ) -> size_t {
        Stream_readBytesUntil(self, terminator, buffer, length)
    }
    #[inline]
    pub unsafe fn readString(&mut self) -> String {
        Stream_readString(self)
    }
    #[inline]
    pub unsafe fn readStringUntil(&mut self, terminator: super::c_char) -> String {
        Stream_readStringUntil(self, terminator)
    }
    #[inline]
    pub unsafe fn parseInt1(&mut self, skipChar: super::c_char) -> super::c_long {
        Stream_parseInt1(self, skipChar)
    }
    #[inline]
    pub unsafe fn parseFloat1(&mut self, skipChar: super::c_char) -> f32 {
        Stream_parseFloat1(self, skipChar)
    }
    #[inline]
    pub unsafe fn findMulti(
        &mut self,
        targets: *mut Stream_MultiTarget,
        tCount: super::c_int,
    ) -> super::c_int {
        Stream_findMulti(self, targets, tCount)
    }
}
pub type tx_buffer_index_t = u8;
pub type rx_buffer_index_t = u8;
#[repr(C)]
pub struct usart_dev {
    _unused: [u8; 0],
}
#[repr(C)]
pub struct HardwareSerial {
    pub _base: Stream,
    pub usart_device: *mut usart_dev,
    pub tx_pin: uint8,
    pub rx_pin: uint8,
}
#[test]
fn bindgen_test_layout_HardwareSerial() {
    assert_eq!(
        ::core::mem::size_of::<HardwareSerial>(),
        24usize,
        concat!("Size of: ", stringify!(HardwareSerial))
    );
    assert_eq!(
        ::core::mem::align_of::<HardwareSerial>(),
        4usize,
        concat!("Alignment of ", stringify!(HardwareSerial))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<HardwareSerial>())).usart_device as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(HardwareSerial),
            "::",
            stringify!(usart_device)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<HardwareSerial>())).tx_pin as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(HardwareSerial),
            "::",
            stringify!(tx_pin)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<HardwareSerial>())).rx_pin as *const _ as usize },
        21usize,
        concat!(
            "Offset of field: ",
            stringify!(HardwareSerial),
            "::",
            stringify!(rx_pin)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN14HardwareSerial5beginEj"]
    pub fn HardwareSerial_begin(this: *mut HardwareSerial, baud: uint32);
}
extern "C" {
    #[link_name = "\u{1}_ZN14HardwareSerial5beginEjh"]
    pub fn HardwareSerial_begin1(this: *mut HardwareSerial, baud: uint32, config: u8);
}
extern "C" {
    #[link_name = "\u{1}_ZN14HardwareSerial3endEv"]
    pub fn HardwareSerial_end(this: *mut HardwareSerial);
}
extern "C" {
    #[link_name = "\u{1}_ZN14HardwareSerial17availableForWriteEv"]
    pub fn HardwareSerial_availableForWrite(this: *mut HardwareSerial) -> super::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZN14HardwareSerialC1EP9usart_devhh"]
    pub fn HardwareSerial_HardwareSerial(
        this: *mut HardwareSerial,
        usart_device: *mut usart_dev,
        tx_pin: uint8,
        rx_pin: uint8,
    );
}
impl HardwareSerial {
    #[inline]
    pub unsafe fn begin(&mut self, baud: uint32) {
        HardwareSerial_begin(self, baud)
    }
    #[inline]
    pub unsafe fn begin1(&mut self, baud: uint32, config: u8) {
        HardwareSerial_begin1(self, baud, config)
    }
    #[inline]
    pub unsafe fn end(&mut self) {
        HardwareSerial_end(self)
    }
    #[inline]
    pub unsafe fn availableForWrite(&mut self) -> super::c_int {
        HardwareSerial_availableForWrite(self)
    }
    #[inline]
    pub unsafe fn new(usart_device: *mut usart_dev, tx_pin: uint8, rx_pin: uint8) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        HardwareSerial_HardwareSerial(__bindgen_tmp.as_mut_ptr(), usart_device, tx_pin, rx_pin);
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN14HardwareSerial9availableEv"]
    pub fn HardwareSerial_available(this: *mut super::c_void) -> super::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZN14HardwareSerial4peekEv"]
    pub fn HardwareSerial_peek(this: *mut super::c_void) -> super::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZN14HardwareSerial4readEv"]
    pub fn HardwareSerial_read(this: *mut super::c_void) -> super::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZN14HardwareSerial5flushEv"]
    pub fn HardwareSerial_flush(this: *mut super::c_void);
}
extern "C" {
    #[link_name = "\u{1}_ZN14HardwareSerial5writeEh"]
    pub fn HardwareSerial_write(this: *mut super::c_void, arg1: u8) -> size_t;
}
extern "C" {
    pub static mut Serial1: HardwareSerial;
}
extern "C" {
    pub static mut Serial2: HardwareSerial;
}
extern "C" {
    pub static mut Serial3: HardwareSerial;
}
#[doc = " Timer mode."]
pub use self::timer_mode as TimerMode;
#[doc = " @brief Interface to one of the 16-bit timer peripherals."]
#[repr(C)]
pub struct HardwareTimer {
    pub dev: *mut timer_dev,
}
#[test]
fn bindgen_test_layout_HardwareTimer() {
    assert_eq!(
        ::core::mem::size_of::<HardwareTimer>(),
        4usize,
        concat!("Size of: ", stringify!(HardwareTimer))
    );
    assert_eq!(
        ::core::mem::align_of::<HardwareTimer>(),
        4usize,
        concat!("Alignment of ", stringify!(HardwareTimer))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<HardwareTimer>())).dev as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HardwareTimer),
            "::",
            stringify!(dev)
        )
    );
}
extern "C" {
    #[doc = " @brief Stop the counter, without affecting its configuration."]
    #[doc = ""]
    #[doc = " @see HardwareTimer::resume()"]
    #[link_name = "\u{1}_ZN13HardwareTimer5pauseEv"]
    pub fn HardwareTimer_pause(this: *mut HardwareTimer);
}
extern "C" {
    #[doc = " @brief Resume a paused timer, without affecting its configuration."]
    #[doc = ""]
    #[doc = " The timer will resume counting and firing interrupts as"]
    #[doc = " appropriate."]
    #[doc = ""]
    #[doc = " Note that there is some function call overhead associated with"]
    #[doc = " using this method, so using it in concert with"]
    #[doc = " HardwareTimer::pause() is not a robust way to align multiple"]
    #[doc = " timers to the same count value."]
    #[doc = ""]
    #[doc = " @see HardwareTimer::pause()"]
    #[link_name = "\u{1}_ZN13HardwareTimer6resumeEv"]
    pub fn HardwareTimer_resume(this: *mut HardwareTimer);
}
extern "C" {
    #[doc = " @brief Get the timer's prescale factor."]
    #[doc = " @return Timer prescaler, from 1 to 65,536."]
    #[doc = " @see HardwareTimer::setPrescaleFactor()"]
    #[link_name = "\u{1}_ZN13HardwareTimer17getPrescaleFactorEv"]
    pub fn HardwareTimer_getPrescaleFactor(this: *mut HardwareTimer) -> uint32;
}
extern "C" {
    #[doc = " @brief Set the timer's prescale factor."]
    #[doc = ""]
    #[doc = " The new value won't take effect until the next time the counter"]
    #[doc = " overflows.  You can force the counter to reset using"]
    #[doc = " HardwareTimer::refresh()."]
    #[doc = ""]
    #[doc = " @param factor The new prescale value to set, from 1 to 65,536."]
    #[doc = " @see HardwareTimer::refresh()"]
    #[link_name = "\u{1}_ZN13HardwareTimer17setPrescaleFactorEj"]
    pub fn HardwareTimer_setPrescaleFactor(this: *mut HardwareTimer, factor: uint32);
}
extern "C" {
    #[doc = " @brief Get the timer overflow value."]
    #[doc = " @see HardwareTimer::setOverflow()"]
    #[link_name = "\u{1}_ZN13HardwareTimer11getOverflowEv"]
    pub fn HardwareTimer_getOverflow(this: *mut HardwareTimer) -> uint16;
}
extern "C" {
    #[doc = " @brief Set the timer overflow (or \"reload\") value."]
    #[doc = ""]
    #[doc = " The new value won't take effect until the next time the counter"]
    #[doc = " overflows.  You can force the counter to reset using"]
    #[doc = " HardwareTimer::refresh()."]
    #[doc = ""]
    #[doc = " @param val The new overflow value to set"]
    #[doc = " @see HardwareTimer::refresh()"]
    #[link_name = "\u{1}_ZN13HardwareTimer11setOverflowEt"]
    pub fn HardwareTimer_setOverflow(this: *mut HardwareTimer, val: uint16);
}
extern "C" {
    #[doc = " @brief Get the current timer count."]
    #[doc = ""]
    #[doc = " @return The timer's current count value"]
    #[link_name = "\u{1}_ZN13HardwareTimer8getCountEv"]
    pub fn HardwareTimer_getCount(this: *mut HardwareTimer) -> uint16;
}
extern "C" {
    #[doc = " @brief Set the current timer count."]
    #[doc = ""]
    #[doc = " @param val The new count value to set.  If this value exceeds"]
    #[doc = "            the timer's overflow value, it is truncated to the"]
    #[doc = "            overflow value."]
    #[link_name = "\u{1}_ZN13HardwareTimer8setCountEt"]
    pub fn HardwareTimer_setCount(this: *mut HardwareTimer, val: uint16);
}
extern "C" {
    #[doc = " @brief Set the timer's period in microseconds."]
    #[doc = ""]
    #[doc = " Configures the prescaler and overflow values to generate a timer"]
    #[doc = " reload with a period as close to the given number of"]
    #[doc = " microseconds as possible."]
    #[doc = ""]
    #[doc = " @param microseconds The desired period of the timer.  This must be"]
    #[doc = "                     greater than zero."]
    #[doc = " @return The new overflow value."]
    #[link_name = "\u{1}_ZN13HardwareTimer9setPeriodEj"]
    pub fn HardwareTimer_setPeriod(this: *mut HardwareTimer, microseconds: uint32) -> uint16;
}
extern "C" {
    #[doc = " @brief Configure a timer channel's mode."]
    #[doc = " @param channel Timer channel, from 1 to 4"]
    #[doc = " @param mode Mode to set"]
    #[link_name = "\u{1}_ZN13HardwareTimer7setModeEi10timer_mode"]
    pub fn HardwareTimer_setMode(this: *mut HardwareTimer, channel: super::c_int, mode: timer_mode);
}
extern "C" {
    #[doc = " @brief Get the compare value for the given channel."]
    #[doc = " @see HardwareTimer::setCompare()"]
    #[link_name = "\u{1}_ZN13HardwareTimer10getCompareEi"]
    pub fn HardwareTimer_getCompare(this: *mut HardwareTimer, channel: super::c_int) -> uint16;
}
extern "C" {
    #[doc = " @brief Set the compare value for the given channel."]
    #[doc = ""]
    #[doc = " @param channel the channel whose compare to set, from 1 to 4."]
    #[doc = " @param compare The compare value to set.  If greater than this"]
    #[doc = "                timer's overflow value, it will be truncated to"]
    #[doc = "                the overflow value."]
    #[doc = ""]
    #[doc = " @see timer_mode"]
    #[doc = " @see HardwareTimer::setMode()"]
    #[doc = " @see HardwareTimer::attachInterrupt()"]
    #[link_name = "\u{1}_ZN13HardwareTimer10setCompareEit"]
    pub fn HardwareTimer_setCompare(
        this: *mut HardwareTimer,
        channel: super::c_int,
        compare: uint16,
    );
}
extern "C" {
    #[doc = " @brief Attach an interrupt handler to the given channel."]
    #[doc = ""]
    #[doc = " This interrupt handler will be called when the timer's counter"]
    #[doc = " reaches the given channel compare value."]
    #[doc = ""]
    #[doc = " @param channel the channel to attach the ISR to, from 0 to 4."]
    #[doc = "   Channel 0 is for overflow interrupt (update interrupt)."]
    #[doc = " @param handler The ISR to attach to the given channel."]
    #[doc = " @see voidFuncPtr"]
    #[link_name = "\u{1}_ZN13HardwareTimer15attachInterruptEiPFvvE"]
    pub fn HardwareTimer_attachInterrupt(
        this: *mut HardwareTimer,
        channel: super::c_int,
        handler: voidFuncPtr,
    );
}
extern "C" {
    #[doc = " @brief Remove the interrupt handler attached to the given"]
    #[doc = "        channel, if any."]
    #[doc = ""]
    #[doc = " The handler will no longer be called by this timer."]
    #[doc = ""]
    #[doc = " @param channel the channel whose interrupt to detach, from 0 to 4."]
    #[doc = "   Channel 0 is for overflow interrupt (update interrupt)."]
    #[doc = " @see HardwareTimer::attachInterrupt()"]
    #[link_name = "\u{1}_ZN13HardwareTimer15detachInterruptEi"]
    pub fn HardwareTimer_detachInterrupt(this: *mut HardwareTimer, channel: super::c_int);
}
extern "C" {
    #[doc = " @brief Reset the counter, and update the prescaler and overflow"]
    #[doc = "        values."]
    #[doc = ""]
    #[doc = " This will reset the counter to 0 in upcounting mode (the"]
    #[doc = " default).  It will also update the timer's prescaler and"]
    #[doc = " overflow, if you have set them up to be changed using"]
    #[doc = " HardwareTimer::setPrescaleFactor() or"]
    #[doc = " HardwareTimer::setOverflow()."]
    #[doc = ""]
    #[doc = " @see HardwareTimer::setPrescaleFactor()"]
    #[doc = " @see HardwareTimer::setOverflow()"]
    #[link_name = "\u{1}_ZN13HardwareTimer7refreshEv"]
    pub fn HardwareTimer_refresh(this: *mut HardwareTimer);
}
extern "C" {
    #[doc = " @brief Set the Master mode TRGO signal"]
    #[doc = "        These bits allow to select the information to be sent in master mode to slave timers for"]
    #[doc = "        synchronization (TRGO)."]
    #[doc = "\tmode:"]
    #[doc = " \t\tTIMER_CR2_MMS_RESET"]
    #[doc = " \t\tTIMER_CR2_MMS_ENABLE"]
    #[doc = " \t\tTIMER_CR2_MMS_UPDATE"]
    #[doc = " \t\tTIMER_CR2_MMS_COMPARE_PULSE"]
    #[doc = " \t\tTIMER_CR2_MMS_COMPARE_OC1REF"]
    #[doc = " \t\tTIMER_CR2_MMS_COMPARE_OC2REF"]
    #[doc = " \t\tTIMER_CR2_MMS_COMPARE_OC3REF"]
    #[doc = " \t\tTIMER_CR2_MMS_COMPARE_OC4REF"]
    #[link_name = "\u{1}_ZN13HardwareTimer17setMasterModeTrGoEj"]
    pub fn HardwareTimer_setMasterModeTrGo(this: *mut HardwareTimer, mode: u32);
}
extern "C" {
    #[doc = " @brief Enable/disable DMA request for the input channel."]
    #[link_name = "\u{1}_ZN13HardwareTimer9enableDMAEi"]
    pub fn HardwareTimer_enableDMA(this: *mut HardwareTimer, channel: super::c_int);
}
extern "C" {
    #[link_name = "\u{1}_ZN13HardwareTimer10disableDMAEi"]
    pub fn HardwareTimer_disableDMA(this: *mut HardwareTimer, channel: super::c_int);
}
extern "C" {
    #[doc = " @brief Construct a new HardwareTimer instance."]
    #[doc = " @param timerNum number of the timer to control."]
    #[link_name = "\u{1}_ZN13HardwareTimerC1Eh"]
    pub fn HardwareTimer_HardwareTimer(this: *mut HardwareTimer, timerNum: uint8);
}
impl HardwareTimer {
    #[inline]
    pub unsafe fn pause(&mut self) {
        HardwareTimer_pause(self)
    }
    #[inline]
    pub unsafe fn resume(&mut self) {
        HardwareTimer_resume(self)
    }
    #[inline]
    pub unsafe fn getPrescaleFactor(&mut self) -> uint32 {
        HardwareTimer_getPrescaleFactor(self)
    }
    #[inline]
    pub unsafe fn setPrescaleFactor(&mut self, factor: uint32) {
        HardwareTimer_setPrescaleFactor(self, factor)
    }
    #[inline]
    pub unsafe fn getOverflow(&mut self) -> uint16 {
        HardwareTimer_getOverflow(self)
    }
    #[inline]
    pub unsafe fn setOverflow(&mut self, val: uint16) {
        HardwareTimer_setOverflow(self, val)
    }
    #[inline]
    pub unsafe fn getCount(&mut self) -> uint16 {
        HardwareTimer_getCount(self)
    }
    #[inline]
    pub unsafe fn setCount(&mut self, val: uint16) {
        HardwareTimer_setCount(self, val)
    }
    #[inline]
    pub unsafe fn setPeriod(&mut self, microseconds: uint32) -> uint16 {
        HardwareTimer_setPeriod(self, microseconds)
    }
    #[inline]
    pub unsafe fn setMode(&mut self, channel: super::c_int, mode: timer_mode) {
        HardwareTimer_setMode(self, channel, mode)
    }
    #[inline]
    pub unsafe fn getCompare(&mut self, channel: super::c_int) -> uint16 {
        HardwareTimer_getCompare(self, channel)
    }
    #[inline]
    pub unsafe fn setCompare(&mut self, channel: super::c_int, compare: uint16) {
        HardwareTimer_setCompare(self, channel, compare)
    }
    #[inline]
    pub unsafe fn attachInterrupt(&mut self, channel: super::c_int, handler: voidFuncPtr) {
        HardwareTimer_attachInterrupt(self, channel, handler)
    }
    #[inline]
    pub unsafe fn detachInterrupt(&mut self, channel: super::c_int) {
        HardwareTimer_detachInterrupt(self, channel)
    }
    #[inline]
    pub unsafe fn refresh(&mut self) {
        HardwareTimer_refresh(self)
    }
    #[inline]
    pub unsafe fn setMasterModeTrGo(&mut self, mode: u32) {
        HardwareTimer_setMasterModeTrGo(self, mode)
    }
    #[inline]
    pub unsafe fn enableDMA(&mut self, channel: super::c_int) {
        HardwareTimer_enableDMA(self, channel)
    }
    #[inline]
    pub unsafe fn disableDMA(&mut self, channel: super::c_int) {
        HardwareTimer_disableDMA(self, channel)
    }
    #[inline]
    pub unsafe fn new(timerNum: uint8) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        HardwareTimer_HardwareTimer(__bindgen_tmp.as_mut_ptr(), timerNum);
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    pub static mut Timer1: HardwareTimer;
}
extern "C" {
    pub static mut Timer2: HardwareTimer;
}
extern "C" {
    pub static mut Timer3: HardwareTimer;
}
extern "C" {
    pub static mut Timer4: HardwareTimer;
}
#[doc = " @brief Virtual serial terminal."]
#[repr(C)]
pub struct USBSerial {
    pub _base: Stream,
}
extern "C" {
    #[link_name = "\u{1}_ZN9USBSerial9_hasBegunE"]
    pub static mut USBSerial__hasBegun: bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN9USBSerial11_isBlockingE"]
    pub static mut USBSerial__isBlocking: bool;
}
#[test]
fn bindgen_test_layout_USBSerial() {
    assert_eq!(
        ::core::mem::size_of::<USBSerial>(),
        16usize,
        concat!("Size of: ", stringify!(USBSerial))
    );
    assert_eq!(
        ::core::mem::align_of::<USBSerial>(),
        4usize,
        concat!("Alignment of ", stringify!(USBSerial))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN9USBSerial5beginEv"]
    pub fn USBSerial_begin(this: *mut USBSerial);
}
extern "C" {
    #[link_name = "\u{1}_ZN9USBSerial5beginEm"]
    pub fn USBSerial_begin1(this: *mut USBSerial, arg1: super::c_ulong);
}
extern "C" {
    #[link_name = "\u{1}_ZN9USBSerial5beginEmh"]
    pub fn USBSerial_begin2(this: *mut USBSerial, arg1: super::c_ulong, arg2: u8);
}
extern "C" {
    #[link_name = "\u{1}_ZN9USBSerial3endEv"]
    pub fn USBSerial_end(this: *mut USBSerial);
}
extern "C" {
    #[link_name = "\u{1}_ZN9USBSerial9readBytesEPcRKj"]
    pub fn USBSerial_readBytes(
        this: *mut USBSerial,
        buf: *mut super::c_char,
        len: *const size_t,
    ) -> size_t;
}
extern "C" {
    #[link_name = "\u{1}_ZN9USBSerial4readEPhj"]
    pub fn USBSerial_read(this: *mut USBSerial, buf: *mut uint8, len: uint32) -> uint32;
}
extern "C" {
    #[link_name = "\u{1}_ZN9USBSerial17availableForWriteEv"]
    pub fn USBSerial_availableForWrite(this: *mut USBSerial) -> super::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZN9USBSerial5writeEPKhj"]
    pub fn USBSerial_write2(this: *mut USBSerial, arg1: *const uint8, arg2: uint32) -> size_t;
}
extern "C" {
    #[link_name = "\u{1}_ZN9USBSerial6getRTSEv"]
    pub fn USBSerial_getRTS(this: *mut USBSerial) -> uint8;
}
extern "C" {
    #[link_name = "\u{1}_ZN9USBSerial6getDTREv"]
    pub fn USBSerial_getDTR(this: *mut USBSerial) -> uint8;
}
extern "C" {
    #[link_name = "\u{1}_ZN9USBSerial7pendingEv"]
    pub fn USBSerial_pending(this: *mut USBSerial) -> uint8;
}
extern "C" {
    #[link_name = "\u{1}_ZN9USBSerial16enableBlockingTxEv"]
    pub fn USBSerial_enableBlockingTx(this: *mut USBSerial);
}
extern "C" {
    #[link_name = "\u{1}_ZN9USBSerial17disableBlockingTxEv"]
    pub fn USBSerial_disableBlockingTx(this: *mut USBSerial);
}
extern "C" {
    #[link_name = "\u{1}_ZN9USBSerialC1Ev"]
    pub fn USBSerial_USBSerial(this: *mut USBSerial);
}
impl USBSerial {
    #[inline]
    pub unsafe fn begin(&mut self) {
        USBSerial_begin(self)
    }
    #[inline]
    pub unsafe fn begin1(&mut self, arg1: super::c_ulong) {
        USBSerial_begin1(self, arg1)
    }
    #[inline]
    pub unsafe fn begin2(&mut self, arg1: super::c_ulong, arg2: u8) {
        USBSerial_begin2(self, arg1, arg2)
    }
    #[inline]
    pub unsafe fn end(&mut self) {
        USBSerial_end(self)
    }
    #[inline]
    pub unsafe fn readBytes(&mut self, buf: *mut super::c_char, len: *const size_t) -> size_t {
        USBSerial_readBytes(self, buf, len)
    }
    #[inline]
    pub unsafe fn read(&mut self, buf: *mut uint8, len: uint32) -> uint32 {
        USBSerial_read(self, buf, len)
    }
    #[inline]
    pub unsafe fn availableForWrite(&mut self) -> super::c_int {
        USBSerial_availableForWrite(self)
    }
    #[inline]
    pub unsafe fn write(&mut self, arg1: *const uint8, arg2: uint32) -> size_t {
        USBSerial_write2(self, arg1, arg2)
    }
    #[inline]
    pub unsafe fn getRTS(&mut self) -> uint8 {
        USBSerial_getRTS(self)
    }
    #[inline]
    pub unsafe fn getDTR(&mut self) -> uint8 {
        USBSerial_getDTR(self)
    }
    #[inline]
    pub unsafe fn pending(&mut self) -> uint8 {
        USBSerial_pending(self)
    }
    #[inline]
    pub unsafe fn enableBlockingTx(&mut self) {
        USBSerial_enableBlockingTx(self)
    }
    #[inline]
    pub unsafe fn disableBlockingTx(&mut self) {
        USBSerial_disableBlockingTx(self)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        USBSerial_USBSerial(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN9USBSerial9availableEv"]
    pub fn USBSerial_available(this: *mut super::c_void) -> super::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZN9USBSerial4peekEv"]
    pub fn USBSerial_peek(this: *mut super::c_void) -> super::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZN9USBSerial4readEv"]
    pub fn USBSerial_read1(this: *mut super::c_void) -> super::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZN9USBSerial5flushEv"]
    pub fn USBSerial_flush(this: *mut super::c_void);
}
extern "C" {
    #[link_name = "\u{1}_ZN9USBSerial5writeEh"]
    pub fn USBSerial_write(this: *mut super::c_void, arg1: uint8) -> size_t;
}
extern "C" {
    #[link_name = "\u{1}_ZN9USBSerial5writeEPKc"]
    pub fn USBSerial_write1(this: *mut super::c_void, str: *const super::c_char) -> size_t;
}
extern "C" {
    pub static mut Serial: USBSerial;
}
extern "C" {
    #[link_name = "\u{1}_Z4tonejjj"]
    pub fn tone(_pin: u32, frequency: u32, duration: u32);
}
extern "C" {
    #[link_name = "\u{1}_Z6noTonej"]
    pub fn noTone(_pin: u32);
}
pub type word = super::c_uint;
extern "C" {
    #[link_name = "\u{1}_Z4loopv"]
    pub fn loop_();
}
extern "C" {
    #[link_name = "\u{1}yield"]
    pub fn yield_();
}
pub const SS: u8 = 7;
pub const SS1: u8 = 31;
pub const MOSI: u8 = 4;
pub const MISO: u8 = 5;
pub const SCK: u8 = 6;
